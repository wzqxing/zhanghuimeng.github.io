<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2019 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2019'}
    </script>




  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-990-satisfiability-of-equality-equations/">
              
                  Leetcode 990. Satisfiability of Equality Equations
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-11
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Leetcode/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/description/" target="_blank" rel="noopener">https://leetcode.com/problems/satisfiability-of-equality-equations/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：16ms</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一系列等式，每个等式形如<code>a==b</code>或<code>a!=b</code>，变量名为单个英文小写字母，问这些等式组能否成立？</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这道题的思路很简单：首先将所有<code>a==b</code>等式转化成<code>a</code>和<code>b</code>之间的连边，然后做并查集或DFS，然后再判断形如<code>a!=b</code>的等式中的两个变量是否在同一个连通集中。总之用并查集和DFS都差不多……</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<p>所以我就直接写了并查集……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _fa[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            _fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> _fa[x] = fa(_fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = fa(x);</span><br><span class="line">        y = fa(y);</span><br><span class="line">        _fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'='</span>)</span><br><span class="line">                merge(s[<span class="number">0</span>] - <span class="string">'a'</span>, s[<span class="number">3</span>] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">                <span class="keyword">if</span> (fa(s[<span class="number">0</span>] - <span class="string">'a'</span>) == fa(s[<span class="number">3</span>] - <span class="string">'a'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Depth-first-Search/"><i class="fas fa-hashtag fa-fw"></i>alg:Depth-first Search</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/computational-geometry-usaco-translation/">
              
                  翻译：计算几何（USACO）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-10
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/USACO/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              USACO
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。</p>
<!-- Prerequisites -->
<h2 id="先决条件"><a class="markdownIt-Anchor" href="#先决条件"></a> 先决条件</h2>
<!-- Graph Theory
Shortest Path -->
<blockquote>
<ul>
<li>图论</li>
<li>最短路</li>
</ul>
</blockquote>
<!-- Tools -->
<h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2>
<!-- This module discusses several algorithms that calculate various geometric properties, mostly based on only two operations described below: cross product and arctangent. -->
<blockquote>
<p>本节讨论了几种用于计算各类几何属性的算法，主要基于下面描述的两种操作：叉积和反正切。</p>
</blockquote>
<!-- Cross Product -->
<h3 id="叉积"><a class="markdownIt-Anchor" href="#叉积"></a> 叉积</h3>
<!-- The cross product of u and v is written as u x v. Computationally, the cross product of two three-dimensional vectors u and v is the vector determinant of the following matrix (where i, j, and k are unit vectors in the x, y, and z directions respectively):  -->
<blockquote>
<p>u和v的叉积写作u x v。在计算中，两个三维向量u和v的叉积是下列矩阵的矢量行列式（其中i、j和k分别是x、y和z方向的单位向量）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| i  j  k  |</span><br><span class="line">| ux uy uz |</span><br><span class="line">| vx vy vz |</span><br></pre></td></tr></table></figure>
<!-- That equation works out to: -->
<blockquote>
<p>这个式子的值为：</p>
</blockquote>
<blockquote>
<p>(uyvz-vyuz)i + (uzvx-uxvz)j + (uxvy-uyvx)k</p>
</blockquote>
<p><img src="geom6.gif" alt></p>
<!-- This definition can be used for vectors in two dimensions by using three-dimensional vectors with a z component of 0. The resulting vector will only have a z value. -->
<blockquote>
<p>通过将三维向量的z分量置为0，这一定义可用于二维向量。得到的向量只有z分量有值。</p>
</blockquote>
<!-- The cross product has three properties: -->
<blockquote>
<p>叉积有三条性质：</p>
</blockquote>
<!-- The cross product of two vectors is perpendicular to both vectors.
The length of the cross product is equal to the product of:
the length of u,
the length of v, and
the sine of the angle between the vectors. -->
<blockquote><ul>
<li>两个向量的<em>叉积</em>垂直于这两个向量。</li>
<li>叉积的长度等于以下几项的乘积：
<ul>
<li>u的长度</li>
<li>v的长度</li>
<li>u和v夹角的正弦值</li>
</ul>
</li>
</ul>
</blockquote>
<!-- Of the two different directions that are perpendicular to both u and v, the direction the cross product points depends on whether u is ``to the right'' of v or ``to the left.''  -->
<blockquote>
<p>在与u和v垂直的两个不同方向中，叉积指向的方向取决于u是在v的“右边”还是“左边”。</p>
</blockquote>
<p><img src="geom7.gif" alt></p>
<p>这就是右手定则吧。</p>
<!-- Dot product -->
<h3 id="点积"><a class="markdownIt-Anchor" href="#点积"></a> 点积</h3>
<!-- The dot product of two vectors u and v is a scalar written as u · v. Computationally, it is defined in three dimensions as: uxvx + u yvy + uzv z -->
<blockquote>
<p>两个向量u和v的点积是写作u·v的标量。在计算中，它在三维向量中定义为： uxvx + uyvy + uzvz</p>
</blockquote>
<!-- The dot product is actually equal to the product of: -->
<blockquote>
<p>点积实际上等于以下几项的乘积：</p>
</blockquote>
<!-- the length of u
the length of v
the cosine of the angle between u and v. -->
<blockquote>
<ul>
<li>u的长度</li>
<li>v的长度</li>
<li>u和v之间夹角的余弦值。</li>
</ul>
</blockquote>
<!-- Presuming u and v are non-zero, if the dot product if negative, u and v make an angle greater than 90 degrees. If it is zero, then u and v are perpendicular. If u cdot v is positive, then the two vectors form an acute angle. -->
<blockquote>
<p>假定u和v不为零，如果点积为负，则u和v的夹角大于90度。如果它为零，则u和v垂直。如果点积为正，则两个向量的夹角为锐角。</p>
</blockquote>
<!-- Arctangent -->
<h3 id="反正切"><a class="markdownIt-Anchor" href="#反正切"></a> 反正切</h3>
<!-- The arctangentfunction calculates the (an) angle whose tangent is its argument and generally returns a real number between -pi/2 and pi/2. An additional function in C, atan2, takes two arguments: a DELTA y value and a DELTA x value (in that order!). It determines the angle between the given vector and the positive x axis and returns a value between -pi and pi. This has the advantage of removing concerns about dividing by zero or writing code to repair angles in order to handle the negative x cases. The atan2 function is almost always easier to use than the simpler atan function that takes only one argument. -->
<blockquote>
<p>反正切函数计算其正切值等于它的参数的角度，通常返回-pi/2和pi/2之间的一个实数。C中的函数<code>atan2</code>接收两个参数：y轴的差值和x轴的差值（按此顺序！）。它确定给定向量和x轴正半轴之间的角度，并返回一个-pi和pi之间的值。这可以解决除零或需要撰写代码处理x轴负半轴的问题。该<code>atan2</code>函数几乎总是比简单的只有一个参数的反正切函数容易使用。</p>
</blockquote>
<p>显然如果只接收一个参数，无法处理向量和x轴垂直的情况（因为会发生除0问题），而且只有正负也无法说明是和正半轴还是负半轴的夹角。</p>
<!-- Particular Debugging Problems -->
<h2 id="调试中的特殊问题"><a class="markdownIt-Anchor" href="#调试中的特殊问题"></a> 调试中的特殊问题</h2>
<!-- The main problem with geometric problems is that they spawn a lot of special cases. Be on the lookout for these special cases and make sure your program works for all of them. -->
<blockquote>
<p>计算几何题的主要问题是它们会产生<strong>许多</strong>特殊情况。请留意这些特殊情况，并<strong>确保你的程序适用于所有这些情况</strong>。</p>
</blockquote>
<!-- Floating point calculations also create a new set of problems. Floating point calculations are rarely precise, as the computer only maintains so many bits (digits) of accuracy: be aware of this. In particular, when checking if two values are equal, check to see if they are within some small tolerance of each other not precisely equal. -->
<blockquote>
<p>浮点数计算也会产生很多新问题。浮点计算很少是精确的，因为计算机只准确保留了若干比特（位）：要注意这一点。特别注意，在检查两个值是否相等时，不要检查它们是否精确相等，而是检查它们之间的差值是否小于某个范围。</p>
</blockquote>
<!-- Geometric Algorithms -->
<h2 id="计算几何算法"><a class="markdownIt-Anchor" href="#计算几何算法"></a> 计算几何算法</h2>
<!-- Here are some of snippets that can help you solve geometry problems. -->
<blockquote>
<p>下面是一些可以帮助你解决计算几何问题的代码片段。</p>
</blockquote>
<!-- Area of Triangle -->
<h3 id="三角形面积"><a class="markdownIt-Anchor" href="#三角形面积"></a> 三角形面积</h3>
<!-- To calculate the area of a triangle with vertices (a, b, c), pick a vertex (say a) and create a vector to the other two vertices (let u = b - a, and v = c - a). The area of the triangle (a, b, c) is one half the length of cross product u x v. -->
<blockquote>
<p>要计算顶点为(a，b，c)的三角形的面积，选择一个顶点（比如说a），并创建从a指向另外两个顶的向量（令u = b - a，v = c - a）。则三角形(a，b，c)的面积是u和v叉积长度的一半。</p>
</blockquote>
<p><img src="geom1.gif" alt></p>
<!-- An alternative method to find the area of triangle is to use Hero's formula. If the lengths of the sides of a triangle are a, b, and c, let s = (a+b+c)/2. The area of the triangle is then -->
<blockquote>
<p>另一种计算三角形面积的方法是海伦公式。如果三角形的三条边长度分别为a，b，c，令s = s = (a+b+c)/2，则三角形的面积为</p>
</blockquote>
<!-- sqrt(s* (s-a)*(s-b)*(s-c)) . -->
<blockquote>
<p>sqrt(s*(s-a)*(s-b)*(s-c))</p>
</blockquote>
<!-- Are Two Line Segments Parallel? -->
<h3 id="两条线段是否平行"><a class="markdownIt-Anchor" href="#两条线段是否平行"></a> 两条线段是否平行？</h3>
<!-- To check if two line segments are parallel, create vectors along each line segment and check to see if their cross product is (almost) zero. -->
<blockquote>
<p>为了检查两条线段是否平行，请沿每条线段创建向量，并检查它们的叉积是否（几乎）为零。</p>
</blockquote>
<!-- Area of polygon -->
<h3 id="多边形面积"><a class="markdownIt-Anchor" href="#多边形面积"></a> 多边形面积</h3>
<!-- The area of a polygon with vertices (x 1, y 1), ..., (x n, y n) is equal to the determinant:  -->
<blockquote>
<p>顶点为(x1, y1), …，(xn, yn)的多边形的面积等于行列式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1   | x1 x2 ... xn |</span><br><span class="line">---  |              |</span><br><span class="line"> 2   | y1 y2 ... yn |</span><br></pre></td></tr></table></figure>
<!-- where the determinate is defined to be similar to the 2 by 2 determinant: x1 y2 + x2y3 + ... + xn y1 - y1 x2 - y2x3 - ... - yn x1 -->
<blockquote>
<p>其中行列式的定义类似于2*2的行列式：x1y2 + x2y3 + … + xny1 - y1x2 - y2x3 - … - ynx1</p>
</blockquote>
<p>不过我觉得我一般只会把多边形分成若干个三角形来算……</p>
<!-- Distance from a point to a line -->
<h3 id="点到直线的距离"><a class="markdownIt-Anchor" href="#点到直线的距离"></a> 点到直线的距离</h3>
<!-- The distance from a point P to a line AB is given by the magnitude of the cross product. In particular, d(P,AB) = |(P - A) x (B - A)| / | B - A| . -->
<blockquote>
<p>从点P到线段AB的距离等于叉积的大小，即d(P，AB) = |(P-A）x (B-A)| / | B - A | 。</p>
</blockquote>
<!-- To determine the distance from a point P to the plane defined by A, B, and C, let n = (B - A) x (C - A). The distance is then give by the following equation: d(P,ABC) = (P-A) · n / |n|. -->
<blockquote>
<p>为了确定从点P到由点A、B和C定义的平面的距离，令n =(B-A) × (C-A)。下列等式即给出距离：d(P，ABC) = (P - A) · n / |n|。</p>
</blockquote>
<!-- Points on a line -->
<h3 id="点在直线上"><a class="markdownIt-Anchor" href="#点在直线上"></a> 点在直线上</h3>
<!-- A point is on a line if the distance from the point to the line is 0. -->
<blockquote>
<p>点在直线上当且仅当点到直线的距离为0。</p>
</blockquote>
<!-- Points on the same side of line -->
<h3 id="在直线同一侧的点"><a class="markdownIt-Anchor" href="#在直线同一侧的点"></a> 在直线同一侧的点</h3>
<!-- This notion only makes sense for two dimensions. To check if points C and D are on the same side of line AB, calculate the z component of (B - A) x (C - A) and (B - A) x (D - A). If the z components have the same sign (i.e., their product is positive), then C and D are on the same side of the line AB. -->
<p>这个概念只对二维平面有意义。要检查C点和D点是否在直线AB的同一侧，计算(B - A) x (C - A)和(B - A) x (D - A)的z分量。如果z分量具有相同的符号（即它们的乘积是正的），则C和D位于直线AB的同一侧。</p>
<!-- Point on line segment -->
<h3 id="点在线段上"><a class="markdownIt-Anchor" href="#点在线段上"></a> 点在线段上</h3>
<!-- To calculate if a point C is on the line segment AB, check if C is on the line AB. If it is, then check if the length of AB is equal to the sum of the lengths of AC and CB. -->
<blockquote>
<p>为了计算点C是否在线段AB上，检查C是否在直线AB上。如果是，则检查AB的长度是否等于AC和CB的长度之和。</p>
</blockquote>
<!-- Point in triangle -->
<h3 id="点在三角形中"><a class="markdownIt-Anchor" href="#点在三角形中"></a> 点在三角形中</h3>
<!-- To check if a point A is in a triangle, find another point B which is within the triangle (the average of the three vertices works well). Then, check if the point A is on the same side of the three lines defined by the edges of the triangle as B. -->
<blockquote>
<p>为了检查点A是否在三角形中，找到三角形内的另一个点B（三个顶点的平均值就可以）。然后，检查点A是否和点B在由三角形的边定义的三条直线的同一侧。</p>
</blockquote>
<p><img src="geom3.gif" alt></p>
<!-- Point in convex polygon -->
<h3 id="点在凸多边形中"><a class="markdownIt-Anchor" href="#点在凸多边形中"></a> 点在凸多边形中</h3>
<!-- The same trick works for a convex polygon:  -->
<blockquote>
<p>同样的技巧适用于凸多边形：</p>
</blockquote>
<p><img src="geom4.gif" alt></p>
<!-- Four (or more) points are coplanar -->
<h3 id="四或更多点共面"><a class="markdownIt-Anchor" href="#四或更多点共面"></a> 四（或更多）点共面</h3>
<!-- To determine if a collection of points is coplanar, select three points, A, B, and C. Now, if, for any other point D, (B - A) x (C - A)) · (D - A) = ~0, then the collection of points resides in some plane. -->
<blockquote>
<p>为了确定点集是否是共面的，选择三个点，A、B和C。如果对于任何其他点D，((B - A) x (C - A)) · (D - A) ≈ 0，则该点集共面。</p>
</blockquote>
<p>先算出三个点对应的平面的法向量……</p>
<!-- Two lines intersect -->
<h3 id="两条直线相交"><a class="markdownIt-Anchor" href="#两条直线相交"></a> 两条直线相交</h3>
<!-- Two lines intersect if and only if they are not parallel in two dimensions. -->
<blockquote>
<p>在二维平面中，两条线相交当且仅当它们不平行。</p>
</blockquote>
<!-- In three dimensions, two lines AB and CD intersect if they are not parallel and A, B, C, and D are coplanar. -->
<blockquote>
<p>在三维中，当直线AB和CD不平行且A、B、C、D共面时，AB和CD相交。</p>
</blockquote>
<!-- Two line segments intersect -->
<h3 id="两条线段相交"><a class="markdownIt-Anchor" href="#两条线段相交"></a> 两条线段相交</h3>
<!-- In two dimensions, two line segments AB and CD intersect if and only if A and B are on opposite sides of the line CD and C and D are on opposite sides of line AB. -->
<blockquote>
<p>在二维平面中，线段AB和CD相交，当且仅当A和B位于直线CD的不同侧且C和D位于直线AB的不同侧时。</p>
</blockquote>
<p><img src="geom5.gif" alt></p>
<!-- Note that both of the checks are necessary, as for the last case one of the checks returns true, while the other testifies to the fact that AB and CD do not intersect. In three dimensions, solve following system of equations, where i and j are the unknowns: -->
<p>请注意，两个检查都是必要的，因为在上图中最后一种情况中，一个检查返回true，而另一个检查才能证明AB和CD不相交。在三维情况中，求解下面的方程组，其中i和j是未知数：</p>
<!-- Ax + (Bx - Ax) i = Cx + (Dx - Cx) j 
Ay + (By - Ay) i = Cy + (Dy - Cy) j 
Az + (Bz - Az) i = Cz + (Dz - Cz) j  -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax) i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay) i = Cy + (Dy - Cy) j</span><br><span class="line">Az + (Bz - Az) i = Cz + (Dz - Cz) j</span><br></pre></td></tr></table></figure>
<!-- If this system has a solution (i, j), where 0 <= i <= 1 and 0 <= j <= 1, then the line segments intersect at: (Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i . -->
<blockquote>
<p>如果该方程组具有解(i，j)，其中0 &lt;= i &lt;= 1且0 &lt;= j &lt;= 1，则线段相交于点(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i。</p>
</blockquote>
<!-- Point of Intersection of Two Lines -->
<h3 id="两条直线的交点"><a class="markdownIt-Anchor" href="#两条直线的交点"></a> 两条直线的交点</h3>
<!-- For the lines AB and CD in two dimensions, the most straight-forward way to calculate the intersection of them is to solve the system of two equations and two unknowns: -->
<blockquote>
<p>对于二维平面中的直线AB和CD，计算它们交点的最直接方法是求解以下两方程两未知数的方程组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax)i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay)i = Cy + (Dy - Cy) j</span><br></pre></td></tr></table></figure>
<!-- The point of intersection is: -->
<blockquote>
<p>交点坐标为：<br>
(Ax + (Bx - Ax) i, Ay + (By - Ay) i)</p>
</blockquote>
<!-- In three dimensions, solve the same system of equations as was used to check line intersection, and the point of intersection is: -->
<blockquote>
<p>在三维情况下，求解与检查线段交叉时相同的方程组，则交点坐标为：<br>
(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az)i)</p>
</blockquote>
<!-- Checking convexity of 2-dimensional polygon -->
<h3 id="检查二维多边形的凸性"><a class="markdownIt-Anchor" href="#检查二维多边形的凸性"></a> 检查二维多边形的凸性</h3>
<!-- To check the convexity of a 2-dimensional polygon, walk the polygon in clock-wise order. For each triplet of consecutive points (A, B, C), calculate the cross product (B - A) x (C - A). If the z component of each of these vectors is positive, the polygon is convex. -->
<blockquote>
<p>为了检查二维多边形的凸性，按顺时针顺序遍历多边形的顶点。对于所有的连续三个顶点(A，B，C)，计算叉积(B - A) x (C - A)。如果 得到的所有向量的z分量都是正的，则多边形是凸的。</p>
</blockquote>
<!-- Point in non-convex polygon -->
<h3 id="点在非凸多边形中"><a class="markdownIt-Anchor" href="#点在非凸多边形中"></a> 点在非凸多边形中</h3>
<!-- To calculate if a point is within a nonconvex polygon, make a ray from that point in a random direction and count the number of times it intersects the polygon. If the ray intersects the polygon at a vertex or along an edge, pick a new direction. Otherwise, the point is within the polygon if and only if the ray intersects the polygon an odd number of times. -->
<blockquote>
<p>为了计算某点是否在非凸多边形内，从该点沿随机方向发出一条射线，并计算它与多边形相交的次数。如果射线在顶点或沿边缘与多边形相交，则选择一个新方向。否则，当且仅当射线与多边形相交奇数次时，该点才在多边形内。</p>
</blockquote>
<p><img src="geom8.gif" alt></p>
<!-- This method also extends to three dimensions (and higher), but the restriction on intersection is that it only intersects at faces and not at either a vertex or an edge. -->
<blockquote>
<p>此方法也适用于三维（和更高维度），但对相交的限制是只在面上相交，而不是在顶点或边上。</p>
</blockquote>
<!-- Geometry Methodologies -->
<h2 id="计算几何方法"><a class="markdownIt-Anchor" href="#计算几何方法"></a> 计算几何方法</h2>
<!-- Geometric problems introduce several different tricks that can be used to either reduce the run-time or approximate the solution. -->
<blockquote>
<p>计算几何题引入了几种不同的技巧，可用于减少运行时间或估计解。</p>
</blockquote>
<!-- Monte Carlo -->
<h3 id="蒙特卡洛方法"><a class="markdownIt-Anchor" href="#蒙特卡洛方法"></a> 蒙特卡洛方法</h3>
<!-- The first geometric trick is based on randomness. Instead of calculating the probability that something occurs, simulate a random event and calculate the fraction of times it occurs. If enough events are simulated, the difference between these two values becomes very small. -->
<blockquote>
<p>第一种计算几何技巧基于随机性。我们不是计算某事发生的概率，而是模拟随机事件并计算它发生的次数。如果模拟了足够多的事件，则这两个值之间的差异将变得非常小。</p>
</blockquote>
<!-- This can be helpful to determine something like the area of a figure. Instead of calculating the area directly, determine a bounding box, and throw ``darts'' at the box, and estimate what the probability of hitting the figure is. If this is calculated accurately enough, this can give a good estimate of the actual area. -->
<blockquote>
<p>这有助于确定图形面积大小之类内容。我们不是直接计算区域，而是确定一个边界框，然后向框中抛出“飞镖”，并估计击中图形的概率是多少。如果计算得足够准确，这可以很好地估计实际面积。</p>
</blockquote>
<!-- The problem with this method is to get a good relative error (error divided by the actual value) requires a large number of successful events. If the probability of the event occurring is very small, the method does not yield good results. -->
<blockquote>
<p>这种方法的问题是，获得良好的相对误差（误差除以实际值）需要大量成功的事件。如果事件发生的概率非常小，则该方法不会产生很好的结果。</p>
</blockquote>
<!-- Partitioning -->
<h3 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h3>
<!-- Partitioning is a method to improve the speed of a geometric algorithm. This entails dividing the plane up into sections (usually by a grid but sometimes into radial sections or some other method), and bucketing the objects into appropriate section(s). When looking for objects within some figure, only those sections which have a non-zero intersection with that figure need to be examined, thereby greatly reducing the cost of the algorithm. This is helpful to determine the set of objects within some distance of a given point (the figure is a circle) or to check for intersections (the figure is a line). -->
<blockquote>
<p>分区是一种提高计算几何算法速度的方法。这需要将平面分成多个部分（通常通过网格，但有时也会按辐射切开或其他方法），并将对象分到对应的区域中。当在某个图形中查找对象时，只需要检查与该图图形具有非零交点的那些部分，从而大大降低了算法的成本。这有助于确定到给定点的距离在某个范围内的对象集和（图形是圆）或检查交叉点（图形是一条直线）。</p>
</blockquote>
<p><img src="geom9.gif" alt></p>
<!-- Graph Problems -->
<h3 id="图论问题"><a class="markdownIt-Anchor" href="#图论问题"></a> 图论问题</h3>
<!-- Sometimes what may look like a geometric problem is really a graph problem. Just because the input is points in the plane does not mean it's a geometric algorithm. -->
<blockquote>
<p>有时看起来像计算几何问题的问题实际上是图论问题。仅仅因为输入是平面中的点并不意味着需要计算几何算法。</p>
</blockquote>
<!-- Example Problems -->
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<!-- Point Moving -->
<h3 id="移动点"><a class="markdownIt-Anchor" href="#移动点"></a> 移动点</h3>
<!-- Given a set of line segments in the plane, and two points A and B, is it possible to move from A to B without crossing any of the segments? -->
<blockquote>
<p>给定平面中的一组线段，以及两个点A和B，能否在不跨越任何线段的情况下从A移动到B？</p>
</blockquote>
<!-- The line segments partition the plane into regions. Determine these regions, and see if A and B reside in the same region. -->
<blockquote>
<p>分析：线段将平面划分为区域。确定这些区域，并检查A和B是否位于同一区域。</p>
</blockquote>
<p>问题是怎么确定这些区域，感觉有些麻烦……</p>
<!-- Bicycle Routing -->
<h3 id="自行车路线"><a class="markdownIt-Anchor" href="#自行车路线"></a> 自行车路线</h3>
<!-- Given a collection of non-intersecting buildings along with start and end locations, find the shortest path from A to B that doesn't go through any buildings. -->
<blockquote>
<p>给定一系列互不交叉建筑的以及它们的起点和终点位置，找到从A到B的不经过任何建筑物的最短路径。</p>
</blockquote>
<!-- Analysis: This is really a graph problem. The nodes are the start and end locations, along with the vertices of the buildings. There are edges between any two nodes such that the line segment between them does not intersect any buildings, with weight equal to the length of the length of the line segments. Once that graph has been calculated, the problem is shortest path. -->
<blockquote>
<p>分析：这实际上是一个图论问题。结点是起始位置和结束位置，以及建筑物的顶点。如果两个结点之间的线段不与任何建筑物相交，则它们之间有边，其权重等于线段的长度。构造完该图后，问题就变成了最短路。</p>
</blockquote>
<!-- Maximizing Line Intersections -->
<h3 id="最大化交叉点数量"><a class="markdownIt-Anchor" href="#最大化交叉点数量"></a> 最大化交叉点数量</h3>
<!-- Given a collection of segments in the plane, find the greatest number of segments which can by intersected by drawing a single line. -->
<blockquote>
<p>给定平面中的一组线段，找到可以与一条直线相交的线段的最大数量。</p>
</blockquote>
<!-- Analysis: With a little bit of thought, it is clear that the line segment must pass through two of the vertices of the collection of line segments. Thus, try all pairs of vertices, and calculate the crossing for each. Combining this with partitioning gives an algorithm that runs fairly quickly. -->
<blockquote>
<p>分析：经过一些思考，很显然直线必须通过线段集合中的两个顶点。因此，尝试所有顶点对，并计算每条直线的交叉点数量。将其与分区相结合，可以提供一种运行速度相当快的算法。</p>
</blockquote>
<p>或者说，一种最优解可以通过旋转变换成另一个一定至少通过两个顶点的最优解……</p>
<!-- Polygon Classification -->
<h3 id="多边形分类"><a class="markdownIt-Anchor" href="#多边形分类"></a> 多边形分类</h3>
<!-- Given a collection of segments defining a polygon, determine if it is simple (no two non-consecutive line segments intersect) and convex. -->
<blockquote>
<p>给定定义多边形的一组线段，确定它是否是简单多边形（没有两个非连续线段相交）和凸多边形。</p>
</blockquote>
<p>Q：凸多边形一定是简单的吗？</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/USACO/"><i class="fas fa-hashtag fa-fw"></i>USACO</a>
                
                    <a href="/tags/translation/"><i class="fas fa-hashtag fa-fw"></i>translation</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-989-add-to-array-form-of-integer/">
              
                  Leetcode 989. Add to Array-Form of Integer
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-10
          </a>
        </div>
      
      
        
          
          <div class="new-meta-item category">
            <a href="/categories/Leetcode/">
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/add-to-array-form-of-integer/description/" target="_blank" rel="noopener">https://leetcode.com/problems/add-to-array-form-of-integer/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：144ms</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一个自然数的各个数位从左到右的数组表示和另一个自然数，求这两个数的和的数组表示。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>很简单的加法题的一个小变形。题解的做法跟我差不多：开一个新的数组（因为原来的表示方法不符合一般从右往左表示的规律），从最后一位开始加，最后再把数组倒过来。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; addToArrayForm(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        a.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            a.back() += A[i];</span><br><span class="line">            a.back() += K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a.back() / <span class="number">10</span>;</span><br><span class="line">            a.back() %= <span class="number">10</span>;</span><br><span class="line">            a.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a.back() += K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a.back() / <span class="number">10</span>;</span><br><span class="line">            a.back() %= <span class="number">10</span>;</span><br><span class="line">            a.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a.size() &gt; <span class="number">1</span> &amp;&amp; a.back() == <span class="number">0</span>) a.pop_back();</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Array/"><i class="fas fa-hashtag fa-fw"></i>alg:Array</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/eulerian-tour-usaco-translation/">
              
                  翻译：欧拉路（USACO）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-09
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。</p>
<!-- Sample Problem: Riding The Fences -->
<h2 id="例题穿越栅栏"><a class="markdownIt-Anchor" href="#例题穿越栅栏"></a> 例题：穿越栅栏</h2>
<!-- Farmer John owns a large number of fences, which he must periodically check for integrity. Farmer John keeps track of his fences by maintaining a list of their intersection points, along with the fences which end at each point. Each fence has two end points, each at an intersection point, although the intersection point may be the end point of only a single fence. Of course, more than two fences might share an endpoint. -->
<blockquote>
<p>农夫约翰拥有大量围栏，他必须定期检查它们的完整性。农民约翰通过维护围栏的交叉点列表，以及在每个交叉点点结束的围栏来跟踪它们。每个围栏有两个端点，每个端点位于一个交叉点，交叉点可能只是单个围栏的终点。当然，两个以上的围栏也可能共享一个端点。</p>
</blockquote>
<!-- Given the fence layout, calculate if there is a way for Farmer John to ride his horse to all of his fences without riding along a fence more than once. Farmer John can start and end anywhere, but cannot cut across his fields (the only way he can travel between intersection points is along a fence). If there is a way, find one way. -->
<blockquote>
<p>给定围栏的布局，计算农夫约翰是否有办法骑马去他所有的围栏，且不需要不止一次地穿越围栏。约翰可以在任何地方开始和结束，但不能穿过他的田地（在交叉点之间穿行的唯一方法是沿着围栏）。如果有方法，找出一种方法。</p>
</blockquote>
<!-- The Abstraction -->
<h2 id="问题的抽象"><a class="markdownIt-Anchor" href="#问题的抽象"></a> 问题的抽象</h2>
<!-- Given: An undirected graph -->
<blockquote>
<p>给定：无向图</p>
</blockquote>
<!-- Find a path which uses every edge exactly once. This is called an Eulerian tour. If the path begins and ends at the same vertex, it is called a Eulerian circuit. -->
<blockquote>
<p>找到一条只使用每条边一次的路径。这样的路径称为欧拉路径。如果路径在同一顶点开始和结束，则称为欧拉回路。</p>
</blockquote>
<!-- The Algorithm -->
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<!-- Detecting whether a graph has an Eulerian tour or circuit is actually easy; two different rules apply. -->
<blockquote>
<p>检查图中是否有欧拉路径或回路实际上很容易; 使用下列两条规则。</p>
</blockquote>
<!-- A graph has an Eulerian circuit if and only if it is connected (once you throw out all nodes of degree 0) and every node has `even degree'. -->
<!-- A graph has an Eulerian path if and only if it is connected and every node except two has even degree. -->
<!-- In the second case, one of the two nodes which has odd degree must be the start node, while the other is the end node. -->
<blockquote>
<ul>
<li>图中有欧拉回路，当且仅当它是连通图（在去掉度数为0的所有结点之后），且每个结点具有“偶数度”。</li>
<li>图中有欧拉路径，当且仅当它是连通图，且除了两个结点之外的每个结点的度数均为偶数。</li>
<li>在第二种情况下，具有奇数度的两个结点中的一个必须是起始结点，而另一个是结束结点。</li>
</ul>
</blockquote>
<!-- The basic idea of the algorithm is to start at some node the graph and determine a circuit back to that same node. Now, as the circuit is added (in reverse order, as it turns out), the algorithm ensures that all the edges of all the nodes along that path have been used. If there is some node along that path which has an edge that has not been used, then the algorithm finds a circuit starting at that node which uses that edge and splices this new circuit into the current one. This continues until all the edges of every node in the original circuit have been used, which, since the graph is connected, implies that all the edges have been used, so the resulting circuit is Eulerian. -->
<blockquote>
<p>算法的基本思想是从图的某个结点开始，并确定回到同一结点的回路。现在，随着回路的添加（事实上是以逆序），算法确保从该路径上所有结点出发的所有边都已被使用。如果该路径上还存在一些具有未使用的边的结点，则算法找到从该结点开始的使用这条边的回路，并将该新回路拼接到当前回路中。这一直持续到原始回路中每个结点的所有边都被使用为止，由于图是连通的，这意味着已经使用了所有边，因此得到的回路是欧拉回路。</p>
</blockquote>
<!-- More formally, to determine a Eulerian circuit of a graph which has one, pick a starting node and recurse on it. At each recursive step: -->
<blockquote>
<p>更正式地说，要确定一个含有欧拉回路的图中的欧拉回路，选择一个起始结点并对其进行递归。在每个递归步骤中：</p>
</blockquote>
<!-- Pick a starting node and recurse on that node. At each step: -->
<!-- If the node has no neighbors, then append the node to the circuit and return -->
<!-- If the node has a neighbor, then make a list of the neighbors and process them (which includes deleting them from the list of nodes on which to work) until the node has no more neighbors -->
<!-- To process a node, delete the edge between the current node and its neighbor, recurse on the neighbor, and postpend the current node to the circuit. -->
<blockquote>
<ul>
<li>选择一个起始结点并对该结点进行递归。在每一步中：</li>
<li>如果结点没有邻居，则将结点加入到回路中并返回</li>
<li>如果结点具有邻居，则创建邻居列表并对其进行处理（包括从需要处理的结点列表中删除它们），直到该节点不再有邻居为止</li>
<li>为了处理结点，删除当前结点与其邻居之间的边，递归邻居，然后将当前结点加入到电路中。</li>
</ul>
</blockquote>
<!-- And here's the pseudocode: -->
<blockquote>
<p>这是伪代码：</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># circuit是一个全局数组</span></span><br><span class="line">find_euler_circuit</span><br><span class="line">    circuitpos = <span class="number">0</span></span><br><span class="line">    find_circuit(node <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nextnode和visited是局部数组</span></span><br><span class="line"><span class="comment"># 将以逆序找到路径</span></span><br><span class="line">find_circuit(node i)</span><br><span class="line">    <span class="keyword">if</span> 结点i没有邻居 then</span><br><span class="line">      circuit(circuitpos) = 结点i</span><br><span class="line">      circuitpos = circuitpos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">while</span> (结点i有邻居)</span><br><span class="line">          随机选择结点i的邻居结点j</span><br><span class="line">          delete_edges (结点j, 结点i)</span><br><span class="line">          find_circuit (结点j)</span><br><span class="line">      circuit(circuitpos) = 结点i</span><br><span class="line">      circuitpos = circuitpos + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<!-- To find an Eulerian tour, simply find one of the nodes which has odd degree and call find_circuit with it. -->
<blockquote>
<p>为了找到欧拉路径，只需找到其中一个具有奇数度的结点，并对它调用<code>find_circuit</code>。</p>
</blockquote>
<!-- Both of these algorithms run in O(m + n) time, where m is the number of edges and n is the number of nodes, if you store the graph in adjacency list form. With larger graphs, there's a danger of overflowing the run-time stack, so you might have to use your own stack. -->
<blockquote>
<p>这两种算法的时间复杂度都是O(m + n)，其中m是边数，n是结点数，如果图是以邻接表形式存储的话。对于较大的图，存在运行时栈溢出的风险，因此你可能需要使用自己的栈。</p>
</blockquote>
<!-- Execution Example -->
<h2 id="执行示例"><a class="markdownIt-Anchor" href="#执行示例"></a> 执行示例</h2>
<!-- Consider the following graph:  -->
<blockquote>
<p>考虑下图：</p>
</blockquote>
<p><img src="euler1.gif" alt></p>
<!-- Assume that selecting a random neighbor yields the lowest numbered neighbor, the execution goes as follows: -->
<blockquote>
<p>假设选择随机邻居时选择的是编号最小的邻居，算法执行过程如下：</p>
</blockquote>
<p><img src="euler2a.gif" alt></p>
<!-- Stack: 
Location: 1 
Circuit: -->
<blockquote>
<p>栈：<br>
当前位置：1<br>
回路：</p>
</blockquote>
<p><img src="euler2b.gif" alt></p>
<!-- Stack: 1 
Location: 4 
Circuit: -->
<blockquote>
<p>栈：1<br>
当前位置：4<br>
回路：</p>
</blockquote>
<p><img src="euler2c.gif" alt></p>
<!-- Stack: 1 4 
Location: 2 
Circuit: -->
<blockquote>
<p>栈：1 4<br>
当前位置：2<br>
回路：</p>
</blockquote>
<p><img src="euler2d.gif" alt></p>
<!-- Stack: 1 4 2 
Location: 5 
Circuit: -->
<blockquote>
<p>栈：1 4 2<br>
当前位置：5<br>
回路：</p>
</blockquote>
<p><img src="euler2e.gif" alt></p>
<!-- Stack: 1 4 2 5 
Location: 1 
Circuit: -->
<blockquote>
<p>栈：1 4 2 5<br>
当前位置：1<br>
回路：</p>
</blockquote>
<p><img src="euler2e.gif" alt></p>
<!-- Stack: 1 4 2 
Location: 5 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2<br>
当前位置：5<br>
回路：1</p>
</blockquote>
<p><img src="euler2f.gif" alt></p>
<!-- Stack: 1 4 2 5 
Location: 6 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5<br>
当前位置：6<br>
回路：1</p>
</blockquote>
<p><img src="euler2g.gif" alt></p>
<!-- Stack: 1 4 2 5 6 
Location: 2 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6<br>
当前位置：2<br>
回路：1</p>
</blockquote>
<p><img src="euler2h.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 
Location: 7 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2<br>
当前位置：7<br>
回路：1</p>
</blockquote>
<p><img src="euler2i.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 
Location: 3 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7<br>
当前位置：3<br>
回路：1</p>
</blockquote>
<p><img src="euler2j.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 
Location: 4 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3<br>
当前位置：4<br>
回路：1</p>
</blockquote>
<p><img src="euler2k.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 4 
Location: 6 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3 4<br>
当前位置：6<br>
回路：1</p>
</blockquote>
<p><img src="euler2l.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 4 6 
Location: 7 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3 4 6<br>
当前位置：7<br>
回路：1</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 4 6 7 
Location: 5 
Circuit: 1 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3 4 6 7<br>
当前位置：5<br>
回路：1</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 4 6 
Location: 7 
Circuit: 1 5 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3 4 6<br>
当前位置：7<br>
回路：1 5</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 4 
Location: 6 
Circuit: 1 5 7 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3 4<br>
当前位置：6<br>
回路：1 5 7</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 3 
Location: 4 
Circuit: 1 5 7 6 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7 3<br>
当前位置：4<br>
回路：1 5 7 6</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 7 
Location: 3 
Circuit: 1 5 7 6 4 -->
<blockquote>
<p>栈：1 4 2 5 6 2 7<br>
当前位置：3<br>
回路：1 5 7 6 4</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 2 
Location: 7 
Circuit: 1 5 7 6 4 3 -->
<blockquote>
<p>栈：1 4 2 5 6 2<br>
当前位置：7<br>
回路：1 5 7 6 4 3</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 6 
Location: 2 
Circuit: 1 5 7 6 4 3 7 -->
<blockquote>
<p>栈：1 4 2 5 6<br>
当前位置：2<br>
回路：1 5 7 6 4 3 7</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 5 
Location: 6 
Circuit: 1 5 7 6 4 3 7 2 -->
<blockquote>
<p>栈：1 4 2 5<br>
当前位置：6<br>
回路：1 5 7 6 4 3 7 2</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 2 
Location: 5 
Circuit: 1 5 7 6 4 3 7 2 6 -->
<blockquote>
<p>栈：1 4 2<br>
当前位置：5<br>
回路：1 5 7 6 4 3 7 2 6</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 4 
Location: 2 
Circuit: 1 5 7 6 4 3 7 2 6 5 -->
<blockquote>
<p>栈：1 4<br>
当前位置：2<br>
回路：1 5 7 6 4 3 7 2 6 5</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 1 
Location: 4 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 -->
<blockquote>
<p>栈：1<br>
当前位置：4<br>
回路：1 5 7 6 4 3 7 2 6 5 2</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 
Location: 1 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 -->
<blockquote>
<p>栈：<br>
当前位置：1<br>
回路：1 5 7 6 4 3 7 2 6 5 2 4</p>
</blockquote>
<p><img src="euler2m.gif" alt></p>
<!-- Stack: 
Location: 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 1 -->
<blockquote>
<p>栈：<br>
当前位置：<br>
回路：1 5 7 6 4 3 7 2 6 5 2 4 1</p>
</blockquote>
<!-- Extensions -->
<h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2>
<!-- Multiple edges between nodes can be handled by the exact same algorithm. -->
<blockquote>
<p>重边可以通过完全相同的算法来处理。</p>
</blockquote>
<!-- Self-loops can be handled by the exact same algorithm as well, if self-loops are considered to add 2 (one in and one out) to the degree of a node. -->
<blockquote>
<p>如果认为自环会为结点度数增加2（一进一出），则自环也可以通过完全相同的算法来处理。</p>
</blockquote>
<!-- A directed graph has a Eulerian circuit if it is strongly connected (except for nodes with both in-degree and out-degree of 0) and the indegree of each node equals its outdegree. The algorithm is exactly the same, except that because of the way this code finds the cycle, you must traverse arcs in reverse order. -->
<blockquote>
<p>有向图仅当强连通且每个结点的入度等于出度时才有欧拉回路（除了入度和出度均为0的节点）。算法完全相同，只是由于此代码找到环路的方式，您必须以相反的顺序遍历边。</p>
</blockquote>
<!-- Finding a Eulerian path in a directed graph is harder. Consult Sedgewick if you are interested. -->
<blockquote>
<p>在有向图中找到欧拉路径更难。如果您有兴趣，请阅读Sedgewick的书。</p>
</blockquote>
<!-- Example problems -->
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<!-- Airplane Hopping -->
<h3 id="飞机跳跃"><a class="markdownIt-Anchor" href="#飞机跳跃"></a> 飞机跳跃</h3>
<!-- Given a collection of cities, along with the flights between those cities, determine if there is a sequence of flights such that you take every flight exactly once, and end up at the place you started. -->
<blockquote>
<p>给定一系列城市，以及这些城市之间的航班，确定是否存在一个航班序列，使得你顺序搭乘每个航班一次，最后回到开始的地方。</p>
</blockquote>
<!-- Analysis: This is equivalent to finding a Eulerian circuit in a directed graph. -->
<blockquote>
<p>分析：这相当于在有向图中找到欧拉回路。</p>
</blockquote>
<!-- Cows on Parade -->
<h3 id="行进中的奶牛"><a class="markdownIt-Anchor" href="#行进中的奶牛"></a> 行进中的奶牛</h3>
<!-- Farmer John has two types of cows: black Angus and white Jerseys. While marching 19 of their cows to market the other day, John's wife Farmeress Joanne, noticed that all 16 possibilities of four successive black and white cows (e.g., bbbb, bbbw, bbwb, bbww, ..., wwww) were present. Of course, some of the combinations overlapped others. -->
<p>农夫约翰有两种类型的奶牛：黑色安格斯奶牛和白色泽西奶牛。前几天约翰的妻子琼安将19头奶牛赶到市场上时，注意到四只连续黑白奶牛的所有16种可能性（例如，bbbb，bbbw，bbwb，bbww，…，wwww）都存在。当然，有些组合与其他组合重叠。</p>
<!-- Given N (2 <= N <= 15), find the minimum length sequence of cows such that every combination of N successive black and white cows occurs in that sequence. -->
<blockquote>
<p>给定N（2 &lt;= N &lt;= 15），找到最小的奶牛长度序列，使得N个连续的黑色和白色奶牛的每个组合都出现在该序列中。</p>
</blockquote>
<!-- Analysis: The vertices of the graph are the possibilities of N-1 cows. Being at a node corresponds to the last N-1 cows matching the node in color. That is, for N = 4, if the last 3 cows were wbw, then you are at the wbw node. Each node has out-degree of 2, corresponding to adding a black or white cow to the end of the sequence. In addition, each node has in-degree of 2, corresponding to whether the cow just before the last N-1 cows is black or white. -->
<blockquote>
<p>分析：图的顶点是N-1头奶牛的可能颜色。位于一个结点处表示最后N-1头奶牛与该结点的颜色匹配。也就是说，对于N = 4，如果最后3头奶牛颜色是wbw，那么你就在wbw节点。每个节点的出度为2，对应于在序列末尾添加黑色或白色奶牛。另外，每个节点的入度为2，对应于最后N-1头奶牛之前的奶牛是黑色还是白色。</p>
</blockquote>
<p>嗯……为啥图的顶点是N-1头奶牛的可能颜色，而不是N头呢？</p>
<!-- The graph is strongly connected, and the in-degree of each node equals its out-degree, so the graph has a Eulerian circuit. -->
<blockquote>
<p>图是强连通的，并且每个结点的入度等于出度，因此图中有欧拉回路。</p>
</blockquote>
<!-- The sequence corresponding to the Eulerian circuit is the sequence of N-1 cows of the first node in the circuit, followed by cows corresponding to the color of the edge. -->
<blockquote>
<p>和欧拉回路相对应的序列是回路中第一个结点对应的N-1头母牛的序列，之后再加上每条边对应的颜色。</p>
</blockquote>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Translation/"><i class="fas fa-hashtag fa-fw"></i>Translation</a>
                
                    <a href="/tags/USACO/"><i class="fas fa-hashtag fa-fw"></i>USACO</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-988-smallest String Starting From Leaf（树）/">
              
                  Leetcode 988. Smallest String Starting From Leaf（树）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-05
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/description/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-string-starting-from-leaf/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：2/4</p>
<p>代码效率：</p>
<ul>
<li>BFS：4ms</li>
<li>暴力：0ms</li>
</ul>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一棵二叉树，令它的每个结点表示一个字符，问从每个叶结点开始，到树根结束的所有字符串中最小的字符串。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>考虑到这道题的数据范围（二叉树的最高层的叶结点数量大约最多是总结点数量的一半），完全可以把所有可能的字符串都生成出来，然后从里面找最小的……</p>
<p>另一种稍微不那么暴力的方法是做BFS，找到出现叶结点的第一层，然后再回溯（或者直接暴力……）。</p>
<hr>
<p>这道题实现过程中还有另一个问题：如何把单个char赋值给一个string？事实上，直接赋值和cast是不行的；如果想要采用<code>&quot;&quot; + 'a'</code>这种写法，就更是大错特错了，这相当于将指向字符串<code>&quot;&quot;</code>首位的指针加上<code>(int) 'a'</code>……</p>
<p>所以比较正确的方法是<code>string(1, 'a')</code>。不要把常量字符串加上char……<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h3>
<p>这份代码比较愚蠢的一点在于，它居然没有存每个结点对应的字符串，而是只存了每个结点的父节点的位置，这么写大概就是故意增加复杂度了……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;  <span class="comment">// node, father, depth</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end;</span><br><span class="line">        q.emplace_back(root, make_pair(<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (start &lt; q.size()) &#123;</span><br><span class="line">            end = q.size();</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                TreeNode* p = q[start].first;</span><br><span class="line">                <span class="keyword">int</span> depth = q[start].second.second;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) q.emplace_back(p-&gt;left, make_pair(start, depth + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) q.emplace_back(p-&gt;right, make_pair(start, depth + <span class="number">1</span>));</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; ans;  <span class="comment">// index, string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            TreeNode* p = q[i].first;</span><br><span class="line">            <span class="keyword">int</span> depth = q[i].second.second;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span> &amp;&amp; p-&gt;right == <span class="literal">NULL</span>) ans.emplace_back(i, <span class="built_in">string</span>(<span class="number">1</span>, p-&gt;val + <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> minimal;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; a;</span><br><span class="line">            minimal = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                minimal = minimal == <span class="string">""</span> || minimal &gt; ans[i].second ? ans[i].second : minimal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[i].second == minimal) &#123;</span><br><span class="line">                    <span class="keyword">int</span> last = q[ans[i].first].second.first;</span><br><span class="line">                    <span class="keyword">if</span> (last == <span class="number">-1</span>) <span class="keyword">return</span> minimal;</span><br><span class="line">                    a.emplace_back(last, minimal + (<span class="keyword">char</span>) (q[last].first-&gt;val + <span class="string">'a'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minimal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        s += (<span class="keyword">char</span>) (root-&gt;val + <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            reverse(s.begin(), s.end());</span><br><span class="line">            ans = ans == <span class="string">""</span> || s &lt; ans ? s : ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, s);</span><br><span class="line">        dfs(root-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://stackoverflow.com/questions/17201590/c-convert-from-1-char-to-string" target="_blank" rel="noopener">stackoverflow - C++ convert from 1 char to string? [closed]</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Tree</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-987-vertical-order-traversal-of-a-binary-tree/">
              
                  Leetcode 987. Vertical Order Traversal of a Binary Tree（树）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：0ms</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一棵二叉树，定义每个结点的坐标如下：如果父结点的坐标是<code>(X, Y)</code>，则左子结点的坐标是<code>(X - 1, Y - 1)</code>，右子结点的坐标是<code>(X - 1, Y + 1)</code>。将横坐标相同的结点的值放在一个列表中，按值排序，并将这些列表按横坐标排序。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>总的来说是道简单的题，用一个map存放横坐标相同的结点的值，然后再排序即可。不过我倒是复习了一下怎么遍历C++ map……（如果不用语法糖的话）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义迭代器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;::iterator it;</span><br><span class="line"><span class="comment">// 用迭代器进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (it = nodeMap.begin(); it != nodeMap.end(); it++) &#123;</span><br><span class="line">    <span class="comment">// 用指针进行访问</span></span><br><span class="line">    sort(it-&gt;second.begin(),it-&gt;second.end());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; nodeMap; <span class="comment">// x -&gt; (-y, value)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        nodeMap[x].emplace_back(-y, root-&gt;val);</span><br><span class="line">        dfs(x - <span class="number">1</span>, y - <span class="number">1</span>, root-&gt;left);</span><br><span class="line">        dfs(x + <span class="number">1</span>, y - <span class="number">1</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = nodeMap.begin(); it != nodeMap.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">            sort(it-&gt;second.begin(),it-&gt;second.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; it-&gt;second.size(); i++)</span><br><span class="line">                cols.push_back(it-&gt;second[i].second);</span><br><span class="line">            ans.push_back(cols);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://stackoverflow.com/questions/18424026/sort-vector-in-a-map-c" target="_blank" rel="noopener">stackoverflow - Sort Vector in a Map c++</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Tree</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-986-interval-list-intersections/">
              
                  Leetcode 986. Interval List Intersections
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/interval-list-intersections/description/" target="_blank" rel="noopener">https://leetcode.com/problems/interval-list-intersections/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：2/2</p>
<p>代码效率：</p>
<ul>
<li>奇怪的做法：28ms</li>
<li>正常的合并：24ms</li>
</ul>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>有<code>A</code>和<code>B</code>两个闭区间数组，它们分别都是排过序的，且每个数组里的区间之间互不相交。请求出两个数组中闭区间的交。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这道题的数据范围并不大（1000），所以我比赛的时候随便乱做了一下，也就过了。</p>
<p>不过正解是这样的：首先考虑最小的两个闭区间<code>A[0]</code>和<code>B[0]</code>，不失一般性，假设<code>A[0]</code>的右端点小于等于<code>B[0]</code>的右端点。由于<code>B</code>中的区间是互不相交的，因此<code>A[0]</code>只有可能与<code>B[0]</code>相交，不可能与<code>B</code>中其他的端点相交。因此我们可以在判断完后将<code>A[0]</code>丢掉，然后重新考虑新的<code>A</code>和<code>B</code>的相交情况。于是就得到了一个<code>O(N)</code>的算法。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="奇怪的做法"><a class="markdownIt-Anchor" href="#奇怪的做法"></a> 奇怪的做法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(Interval x1, Interval x2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1.end &lt; x2.start || x2.end &lt; x1.start) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; getIntsc(Interval x1, Interval x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> make_pair(max(x1.start, x2.start), min(x1.end, x2.end));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; intervalIntersection(<span class="built_in">vector</span>&lt;Interval&gt;&amp; A, <span class="built_in">vector</span>&lt;Interval&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; m &amp;&amp; B[start].end &lt; A[i].start &amp;&amp; !intersect(A[i], B[start])) start++;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (intersect(A[i], B[j]))</span><br><span class="line">                    a.push_back(getIntsc(A[i], B[j]));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">            ans.emplace_back(a[i].first, a[i].second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="正常的做法"><a class="markdownIt-Anchor" href="#正常的做法"></a> 正常的做法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; intervalIntersection(<span class="built_in">vector</span>&lt;Interval&gt;&amp; A, <span class="built_in">vector</span>&lt;Interval&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i].end &lt; B[j].start) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (B[j].end &lt; A[i].start) j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.emplace_back(max(A[i].start, B[j].start), min(A[i].end, B[j].end));</span><br><span class="line">                <span class="keyword">if</span> (A[i].end &lt; B[j].end) i++;</span><br><span class="line">                <span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/interval-list-intersections/solution/" target="_blank" rel="noopener">Leetcode Official Solution for 986</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Two-Pointers/"><i class="fas fa-hashtag fa-fw"></i>alg:Two Pointers</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-985-sum-of-even-numbers-after-queries/">
              
                  Leetcode 985. Sum of Even Numbers After Queries
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-03
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/sum-of-even-numbers-after-queries/description/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-even-numbers-after-queries/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：96ms</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一个数组<code>A</code>，对其中的数做以下操作：</p>
<ul>
<li>更新：<code>A[index] += val</code></li>
<li>查询：问<code>A</code>中所有偶数的和</li>
</ul>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>首先预处理出<code>A</code>中所有偶数的和，然后在每次更新的时候，对这个和相应地进行更新。总的来说是道水题……</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumEvenAfterQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum += A[i];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queries[i][<span class="number">0</span>], k = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (A[k] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) sum += x;</span><br><span class="line">                <span class="keyword">else</span> sum -= A[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) sum += A[k] + x;</span><br><span class="line">            &#125;</span><br><span class="line">            A[k] += x;</span><br><span class="line">            ans.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Array/"><i class="fas fa-hashtag fa-fw"></i>alg:Array</a>
                
                    <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-128-longest-consecutive-sequence/">
              
                  Leetcode 128. Longest Consecutive Sequence
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/description/</a></p>
<p>标记难度：Hard</p>
<p>提交次数：2/2</p>
<p>代码效率：</p>
<ul>
<li>排序：100.00%（4ms）</li>
<li>Hash Set：100.00%（4ms）</li>
</ul>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一个（未排序的）整数数组，找到最长的连续整数序列的长度。要求复杂度是<code>O(n)</code>。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>虽然说要求复杂度是<code>O(n)</code>，但是我想都没想就排了个序……然后直接扫描一遍数组就可以了。</p>
<p><a href="https://leetcode.com/articles/longest-consecutive-sequence/" target="_blank" rel="noopener">题解</a>里给出了不排序的做法：把每个数都存到一个哈希表里，然后对于每个数，如果它之前没有出现在某个连续序列里（也就是说比它少1的数不存在），则尝试寻找以它为开头的连续整数序列的长度。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// ……</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                ans = max(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            s.insert(num);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(num - <span class="number">1</span>) == s.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s.find(num + l) != s.end())</span><br><span class="line">                    l++;</span><br><span class="line">                maxn = max(maxn, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/codeforces-1107e-vasya-and-binary-string/">
              
                  Codeforces 1107E. Vasya and Binary String（DP）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-01-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://codeforces.com/contest/1107/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1107/problem/E</a></p>
<p>提交次数：1/1</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一个长度为<code>n</code>的只包含0和1的字符串，将该串中连续<code>i</code>个相同字符消去将得到<code>a[i]</code>的收益，问消去整个字符串能得到的最大收益是多少？</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>在不会做的三道题上鸽了好久，最后还是觉得DP最好写……</p>
<hr>
<p>这个题解[soln1]特别简明扼要，大概抓住了问题的本质，不过我可能还没有完全理解它：</p>
<ul>
<li>每一个状态都可以用<code>[start, end, prefix]</code>表示，其中<code>start</code>和<code>end</code>是字符串中的起始和结束index（不妨假设两端都是闭区间）（不是也行），<code>prefix</code>是字符串前面附加的和<code>s[start]</code>相等的字符的数量（包括<code>s[start]</code>）（不包括大概也行）</li>
<li>每一个状态都有两种递推方法：
<ul>
<li>第一种是直接消去字符串前面附加的字符：<code>dp[start, end, prefix] = a[prefix] + dp[start + 1, end, 1]</code></li>
<li>第二种是在字符串其他位置找到一个和<code>s[start]</code>相同的字符，然后消去中间的字符，获得一个更大的前缀：<code>dp[start, end, prefix] = max(dp[start+1, i-1, 1] + dp[i, end, prefix+1]) (start &lt; i &lt;= end, s[i] == s[start])</code></li>
</ul>
</li>
</ul>
<p>虽然这个做法看起来很有道理，但其实我会有几个疑问。比如说，一些状态看起来其实是等价的：对于字符串<code>&quot;0001&quot;</code>，<code>dp[0, 3, 1]</code>和<code>dp[2, 3, 3]</code>表示的都是整个字符串。显然我们在递推过程中更容易得到前一种（没有被简化的）状态。那这两种状态有什么关系呢？是否需要手动简化？事实上，并不需要手动简化，<code>dp[0, 3, 1]</code>在递推中会自动得到<code>dp[1, 3, 2]</code>这个状态，并且进一步得到<code>dp[2, 3, 3]</code>。所以，与其说后一种状态是“简化之后的”，不如说是另一种对状态的看法，而且是一种一般化的表示。</p>
<p>至于递推的顺序，大概是得<code>end - start</code>从小到大，且<code>prefix</code>从小到大。这听起来有点麻烦（而且可能会增加复杂度），不如就写成递归形式算了。</p>
<p>[soln1]: <a href="https://codeforces.com/blog/entry/64833" target="_blank" rel="noopener">Codeforces Blog - Quick unofficial editorial for Educational Round 59 (Div. 2)</a></p>
<p>[soln2]: <a href="https://codeforces.com/blog/entry/64847" target="_blank" rel="noopener">Codeforces Blog - Educational Codeforces Round 59 Editorial</a></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> s[<span class="number">105</span>];</span><br><span class="line">LL a[<span class="number">105</span>];</span><br><span class="line">LL f[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[start][end][p] != <span class="number">-1</span>) <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        f[start][end][p] = a[p];</span><br><span class="line">        <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">    &#125;</span><br><span class="line">    f[start][end][p] = a[p] + calc(start + <span class="number">1</span>, end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[start]) <span class="keyword">continue</span>;</span><br><span class="line">        f[start][end][p] = max(f[start][end][p], calc(start + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">1</span>) + calc(i, end, p + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">        s[i] = ch - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; calc(<span class="number">0</span>, n<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Codeforces/"><i class="fas fa-hashtag fa-fw"></i>Codeforces</a>
                
                    <a href="/tags/Codeforces-Contest/"><i class="fas fa-hashtag fa-fw"></i>Codeforces Contest</a>
                
                    <a href="/tags/alg-Dynamic-Programming/"><i class="fas fa-hashtag fa-fw"></i>alg:Dynamic Programming</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/archives/2019/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  2 / 6
              </p>
              
                  <a class="next" rel="next" href="/archives/2019/page/3/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->




        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
