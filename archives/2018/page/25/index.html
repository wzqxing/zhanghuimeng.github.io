<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018'}
    </script>




  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2014-final-exam-analysis/">
              
                  《操作系统》2014年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="一-信号12分"><a class="markdownIt-Anchor" href="#一-信号12分"></a> 一 信号（12分）</h2>
<p>在Linux/Unix中，一个用户从shell中执行了一个运行时间较长且不知何时能够结束的程序，Linux/UNIX可以让用户根据个人需求随时通过敲击Ctrl-C组合键来终止这个程序的执行。请回答如下问题。要求设计应该具有通用性，列出的设计实现不超过6点，每点不超过 4行。问题的执行流程描述不超过8行。</p>
<ol>
<li>如果要在ucore中实现Linux/UNIX同样的功能，请问应该如何修改ucore来支持此功能？</li>
<li>uCore的shell也是一个程序，我们希望避免这个shell在执行中被用户敲入的Ctrl-C所终止，请问在保证1的要求前提下，如何修改ucore和shell来支持此功能？</li>
<li>说明在你的设计下，shell和某一可被终止程序在执行过程中，用户敲击Ctrl-C后，uCore和shell的执行流程。</li>
</ol>
<hr>
<ol>
<li>很显然，应该通过信号机制来实现相应的功能。我觉得可以修改编译器，使得编译时为每个程序自动加入信号处理例程，进程启动时将相应的信号处理函数注册到内核，发生SIGKILL（Ctrl+C组合）时将信号分发给进程，进程执行信号处理例程并退出。</li>
<li>shell可以在程序中屏蔽Ctrl+C信号</li>
<li>ucore和shell的执行流程：</li>
<li>ucore接收到键盘中断</li>
<li>ucore识别出按下的键是Ctrl+C，发送信号</li>
<li>中断返回时检查到进程有未处理的信号，转入信号处理（这一步我们大概没有细讲……总之就是进入了正在执行的程序的信号处理例程）</li>
<li>信号处理例程使进程退出</li>
<li>shell继续wait</li>
</ol>
<h2 id="二-ipc机制"><a class="markdownIt-Anchor" href="#二-ipc机制"></a> 二 IPC机制</h2>
<p>在具备了执行用户态进程的能力之后，uCore要为这些进程提供的一个重要服务，是用户进程之间的消息传递机制（Inter-Process Communication，简写为 IPC）。现在，我们要为uCore实现以下两个系统调用，以实现一种同步的IPC机制（暂不考虑超时等功能）：</p>
<ul>
<li><code>int sys_send_event(int pid, int event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 该消息的目标进程的进程号；</li>
</ul>
</li>
</ul>
</li>
<li>event – 消息内容，用一个整型表示。</li>
<li>返回值：消息成功发送时，返回0；否则，返回相应的错误代码。</li>
<li><code>int sys_recv_event(int *pid, int *event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 函数返回时，<code>*pid</code>保存发出消息的进程的进程号，可以为NULL；</li>
<li>event – 函数返回时，<code>*event</code>保存消息内容，可以为NULL。</li>
</ul>
</li>
<li>返回值：消息成功接收时，返回 0；否则，返回相应的错误代码。</li>
</ul>
</li>
</ul>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>以下是一个基于上述IPC机制求质数的用户程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int total = 1000;</span><br><span class="line"></span><br><span class="line">void primeproc(void)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0, this, num, pid = 0;</span><br><span class="line">top:</span><br><span class="line">    recv_event(NULL, &amp;this);</span><br><span class="line">    cprintf(&quot;%d is a primer.\n&quot;, this);</span><br><span class="line"></span><br><span class="line">    while (recv_event(NULL, &amp;num) == 0) &#123;</span><br><span class="line">        if ((num % this) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            if (index + 1 == total) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((pid = fork()) == 0) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                goto top;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pid &lt; 0) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (send_event(pid, num) != 0) &#123;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    cprintf(&quot;[%04d] %d quit.\n&quot;, getpid(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, pid;</span><br><span class="line">    unsigned int time = gettime_msec();</span><br><span class="line">    if ((pid = fork()) == 0) &#123;</span><br><span class="line">        primeproc();</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pid &gt; 0);</span><br><span class="line"></span><br><span class="line">    for (i = 2;; i++) &#123;</span><br><span class="line">        if (send_event(pid, i) != 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(&quot;use %d msecs.\n&quot;, gettime_msec() - time);</span><br><span class="line">    cprintf(&quot;primer3 pass.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简述这个程序是如何判断并输出前五个质数的。</p>
<hr>
<p>主进程（称为P1）首先fork出一个子进程，子进程开始执行<code>primeproc()</code>函数（称为P2）。主进程从<code>i = 2</code>开始不断向P1发送内容为<code>i</code>的自然数，直到发送不成功为止。</p>
<p>P1进程不断循环：</p>
<ul>
<li>接收P0发送的消息，将这个整数保存下来，作为质数<code>this</code></li>
<li>不断接收P0发送的消息，保存为<code>num</code>；如果接收不成功，退出并打印信息</li>
<li>若<code>num</code>可以被<code>this</code>整除，显然<code>num</code>不是质数，跳出此次循环，继续等待消息</li>
</ul>
<p>。。。不会了</p>
<p>学长答案说：</p>
<blockquote>
<p>每个进程是一个输出一个素数，负责检验传进来的数是否整除这个素数，如果都过了在新建一个进程</p>
</blockquote>
<p>我觉得从理论上来说确实是这样，但是不够详细。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>给出一种基于等待队列的上述IPC机制的实现方案。</p>
<hr>
<p>在我的妄想中这个是这样实现的：</p>
<ul>
<li>建立两个等待队列：发送等待队列和接收等待队列</li>
<li>当进程发送消息时，检查目标进程是否在接收等待队列中，如果不在，则加入发送等待队列；如果在，则将目标进程取出，发送对应的消息</li>
<li>当进程接收消息时，检查发送等待队列中是否有进程发送的目标是它，如果有，则将该进程取出，接收对应的消息；否则加入接收等待队列</li>
</ul>
<h2 id="三-ucore中的信号量实现10分"><a class="markdownIt-Anchor" href="#三-ucore中的信号量实现10分"></a> 三 ucore中的信号量实现（10分）</h2>
<p>在uCore中，信号量的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line"> int value;</span><br><span class="line"> wait_queue_t wait_queue;</span><br><span class="line">&#125; semaphore_t;</span><br><span class="line"></span><br><span class="line">// __up 函数是信号量 V 操作的具体实现函数</span><br><span class="line">static __noinline void __up(semaphore_t *sem, uint32_t wait_state) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        wait_t *wait;</span><br><span class="line">        if ((wait=wait_queue_first(&amp;(sem-&gt;wait_queue)))==NULL) &#123;</span><br><span class="line">            ________;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> （1）</h3>
<p>补全程序中的空行________。</p>
<hr>
<p><code>sem-&gt;value++;</code></p>
<h3 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> （2）</h3>
<p>信号量的value值&gt;0时，表示________的数量；value值&lt;0时，表示________的数量。</p>
<hr>
<ol>
<li>剩余资源</li>
<li>等待队列中进程</li>
</ol>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p><code>local_intr_save</code>和<code>local_intr_restore</code>这两个函数的功能分别是什么？为什么要调用这两个函数？</p>
<hr>
<p>关中断和开中断；为了保证执行过程的原子性。</p>
<h2 id="四-学生看mooc同步问题15分"><a class="markdownIt-Anchor" href="#四-学生看mooc同步问题15分"></a> 四 学生看MOOC同步问题（15分）</h2>
<p>假设一个MOOC网站有1、2、3三种不同的课程视频可由学生选择学习，网站播放课程视频的规则为：</p>
<ol>
<li>任一时刻最多只能播放一种课程视频，正在播放的课程视频是自动循环播放的，最后一个学生主动离开时结束当前课程视频的播放；</li>
<li>选择当前正在播放的课程视频的学生可立即进入播放页面，允许同时有多位选择同一种课程视频的学生观看，同时观看的学生数量不受限制；</li>
<li>等待观看其它课程视频的学生按到达顺序排队，当一种新的课程视频开始放映时，所有等待观看该课程视频的学生可依次序进入播放页面同时观看。</li>
</ol>
<p>用一个进程代表一个学生，要求：用信号量的P、V操作实现上述规则，并给出信号量的<br>
定义和初始值。</p>
<hr>
<p>我认为这个问题有点像读者-写者问题。下面是我的实现方法（虽然我也觉得有一些问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#define COURSE 3</span><br><span class="line"></span><br><span class="line">semaphore mutex; // 保护互斥变量的锁</span><br><span class="line">semaphore wait[COURSE];  // 等待观看视频的学生队列</span><br><span class="line">int count[COURSE];  // 共享变量：等待/正在观看某视频的学生数量</span><br><span class="line">int cur;  // 当前正在播放的视频</span><br><span class="line"></span><br><span class="line">/* INITIALIZATION */</span><br><span class="line">void initialize() &#123;</span><br><span class="line">    mutex = new semaphore(1);</span><br><span class="line">    cur = -1;</span><br><span class="line">    for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">        wait[i] = new semaphore(0);</span><br><span class="line">        count[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Student Thread */</span><br><span class="line">void Student(int choice) &#123;</span><br><span class="line">    // 尝试开始观看</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]++;  // 更新等待人数</span><br><span class="line">    if (cur != choice) &#123;</span><br><span class="line">        if (cur &gt; 0) &#123;  // 当前播放的视频不符合要求，在期望视频的等待队列上睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">            wait[choice].P();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cur = choice;  // 当前未播放视频，直接睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        mutex.V();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Start to watch</span><br><span class="line"></span><br><span class="line">    // End watching</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]--;  // 更新等待人数</span><br><span class="line">    if (count[choice] &gt; 0) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count[choice]; i++) // 唤醒所有准备观看此视频的学生</span><br><span class="line">            wait[choice].V();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cur = -1;  // 寻找下一个播放的视频</span><br><span class="line">        for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">            if (count[i] &gt; 0) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                for (int j = 0; j &lt; count[i]; j++)</span><br><span class="line">                    wait[i].V();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学长的实现是这样的，说实话，我也不是很明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">avaid=1</span><br><span class="line">A=0,B=0,C=0</span><br><span class="line">waitA=waitB=waitC=0;</span><br><span class="line"></span><br><span class="line">观看:</span><br><span class="line">waitA+=1;</span><br><span class="line">P(avaid)</span><br><span class="line">if (countA+countB+countC==0)</span><br><span class="line"> V(A);</span><br><span class="line">V(avaid)</span><br><span class="line">P(A);</span><br><span class="line">waitA-=1;</span><br><span class="line">P(avaid)</span><br><span class="line">countA+=1;</span><br><span class="line">V(avaid)</span><br><span class="line">V(A);</span><br><span class="line"></span><br><span class="line">看完:</span><br><span class="line">P(avaid)</span><br><span class="line">countA-=1;</span><br><span class="line">if (countA==0) &#123;</span><br><span class="line"> V(avaid)</span><br><span class="line"> P(A);</span><br><span class="line"> if (waitB&gt;0) V(B);</span><br><span class="line"> else if (waitC&gt;0)  V(C);</span><br><span class="line">&#125; else</span><br><span class="line">V(avaid)</span><br></pre></td></tr></table></figure>
<h2 id="五-stride调度算法12分"><a class="markdownIt-Anchor" href="#五-stride调度算法12分"></a> 五 Stride调度算法（12分）</h2>
<p>在lab6中，我们实现了Stride Scheduling调度算法，并声称它对“进程的调度次数正比于其优先级”。对于优先级为2、3、5、7的4个进程，选取210为MAX_STRIDE，则：</p>
<ol>
<li>简要描述Stride Scheduling调度算法。</li>
<li>四个进程的步长分别为：<strong><strong><strong><strong>、</strong></strong></strong></strong>、<strong><strong><strong><strong>、</strong></strong></strong></strong>。</li>
<li>假设四个进程的初始stride值均为0，证明：总有一个时刻，四个进程的stride值都是210，且此时四个进程被调度的次数正比于其优先级。</li>
</ol>
<hr>
<p>Stride调度算法：</p>
<ul>
<li>每个进程有一个priority（优先级），pass和stride</li>
<li>stride = BigStride / priority</li>
<li>每次调度时选择pass值最小的进程，更新该进程的pass：pass += stride</li>
</ul>
<p>步长分别为105、70、42和30。</p>
<p>下列模拟过程假设在进程的pass值相等时，选择进程编号最小的执行。</p>
<p><img src="stride-sheet.png" alt="进程执行顺序表"></p>
<p><img src="stride-pass-fig.png" alt="各进程的Pass值变化过程"></p>
<p>此时，A被调度了2次，B被调度了3次，C被调度了5次，D被调度了7次，恰好与优先级成正比。之所以会这么规整，主要还是因为BigStride的值能够正好被各个优先级的值整除。</p>
<h2 id="六-银行家算法12分"><a class="markdownIt-Anchor" href="#六-银行家算法12分"></a> 六 银行家算法（12分）</h2>
<p>死锁是操作系统中资源共享时面临的一个难题。请回答下列与死锁相关的问题。</p>
<h3 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> （1）</h3>
<p>设系统中有下述解决死锁的方法：</p>
<ol>
<li>银行家算法；</li>
<li>检测死锁，终止处于死锁状态的进程，释放该进程占有的资源；</li>
<li>资源预分配。<br>
简述哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进？请按“并发性”从大到小对上述三种办法进行排序。</li>
</ol>
<hr>
<p>排序：2 &gt; 1 &gt; 3</p>
<p>原因：</p>
<ol>
<li>银行家算法每满足一个资源请求时都会进行安全状态检查。因为安全状态中实际上包含了一部分不会发生死锁的状态，所以它会拒绝一些本来可以接受的请求，所以降低了一点并发性。</li>
<li>显然在这种做法下所有进程都可以无等待地推进，直到真的出现了死锁再进行处理。</li>
<li>直觉上来说，资源预分配的并发性比银行家算法更低，因为银行家算法至少保留了一些动态性能，而资源预分配完全牺牲了动态性。</li>
</ol>
<h3 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> （2）</h3>
<p>假设一个使用银行家算法的系统，当前有5个进程P0, P1, P2, P3, P4，系统中有三类资源A、B、C，假设在某时刻有如下状态：</p>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Max矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Available向量：[1, 4, 0]</p>
<p>请问当前系统是否处于安全状态？如果系统中的可利用资源为（0, 6, 2），系统是否安全？如果系统处在安全状态，请给出安全序列；如果系统处在非安全状态，请简要说明原因。</p>
<hr>
<p>首先计算Need矩阵：Need = Max - Allocation</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>然后进行安全状态检测：</p>
<ol>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5] = [2, 7, 5]，Finish[P2] = true</li>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [2, 7, 8]，Finish[P0] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 0, 0] = [3, 7, 8]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [3, 7, 10]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [3, 7, 11]，Finish[P4] = true</li>
<li>发现系统处于安全状态。</li>
</ol>
<p>如果将Available向量修改为[0, 6, 2]，重新进行安全状态检测：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [0, 6, 5]，Finish[P0] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [0, 6, 7]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [0, 6, 5]，Finish[P4] = true</li>
<li>此时找不到满足条件的进程了，因此系统处于不安全状态。</li>
</ol>
<h2 id="七-sfs文件系统12分"><a class="markdownIt-Anchor" href="#七-sfs文件系统12分"></a> 七 SFS文件系统（12分）</h2>
<p>uCore实现了一个简单的文件系统Simple FS，假设该文件系统现已经装载到一个硬盘中（disk0），该硬盘的大小为20M，目前有三个文件A.txt，B.txt和C.txt存放在该硬盘中，三个文件的大小分别是48K，1M和4M。</p>
<h3 id="1-4"><a class="markdownIt-Anchor" href="#1-4"></a> （1）</h3>
<p>简要描述SFS文件系统中文件数据的组织结构（即：SFS文件的数据的存放位置组织方式）。</p>
<hr>
<p>以下答案来自<a href="https://github.com/chyyuu/os_course_exercise_library/blob/master/9/846.md" target="_blank" rel="noopener">os_course_exercise_library</a>，总之这个仓库让我感觉十分惊诧。</p>
<blockquote>
<p>一个superblock维护基本信息（1’），<br>
多个freemap（数量由分区大小确定，1’），<br>
一个根目录inode（1’）；<br>
目录和文件均由一个inode和具体数据块组成，其中inode包含文件的基本属性、12个直接索引和一级/二级索引表的块地址（1’），<br>
目录的数据块中存放（文件名 、inode地址）的数组（1’），<br>
文件的数据块中存放文件的具体内容（1’）。</p>
</blockquote>
<p>呃，有标答了哦。不过，要是我自己来回答，会这样说：</p>
<p><img src="disk-structure.png" alt="硬盘上按顺序排列着4类数据"></p>
<p>……然后就懒得说了，反正我还没做完Lab8，标答比我能总结出来的东西还是要强的。</p>
<h3 id="2-4"><a class="markdownIt-Anchor" href="#2-4"></a> （2）</h3>
<p>请根据Simple FS的设计实现情况，画出该文件系统当前在disk0上的布局情况，需要给出相应结构的名称和起始块号。</p>
<hr>
<p>答案来源同上。</p>
<blockquote>
<p>（除了0、1、2以外，其它块地址均可变，言之有理即可） （2分）<br>
0 superblock<br>
1 根目录inode<br>
2 freemap（640K，只需要1块）<br>
3 根目录的数据块（包含A.txt、B.txt、C.txt的inode的地址） （1分）<br>
4 A.txt的inode（包含12个直接索引块的地址）<br>
5-16 A.txt的数据块 （2分）<br>
17 B.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
18-29 B.txt的直接索引数据<br>
30 B.txt的一级间接索引（包含244个数据块地址）<br>
31-274 B.txt的一级间接索引块 （1分）<br>
275 C.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
276-287 C.txt的一级间接索引块<br>
288 C.txt的一级间接索引（包含1012个数据块地址）<br>
289-1300 C.txt的一级间接索引块</p>
</blockquote>
<p>这个硬盘的块大小是4KB（虽然不知道为什么），因此整个硬盘共有5120块，因此freemap的大小应该为5Kbit。第0块是superblock，第1块是根目录inode，第2块是freemap，用1块就够了。后面就开始链式存储具体的文件和目录内容。</p>
<ul>
<li>3：根目录的数据块</li>
<li>4：A的inode。因为A的大小为48KB，因此12个直接索引块恰好能够装下，不需要一级索引。</li>
<li>5-16：A的数据块</li>
<li>17：B的inode。因为B的大小为1M，所以需要12个直接索引、1个一级索引块和244个间接索引。</li>
<li>18-29：B的直接索引数据块</li>
<li>30：B的一级索引块</li>
<li>31-274：B的间接索引数据块</li>
<li>275：C的inode。因为C的大小为4M，所以需要12个直接索引、1个一级索引块和1012个间接索引。</li>
<li>276-287：C的直接索引数据块</li>
<li>288：C的一级索引块</li>
<li>289-1300：C的间接索引数据块</li>
</ul>
<h2 id="八-vfs文件系统12分"><a class="markdownIt-Anchor" href="#八-vfs文件系统12分"></a> 八 VFS文件系统（12分）</h2>
<p>uCore的文件管理主要由以下四个部分组成：通用文件系统访问接口层，文件系统抽象层(VFS)，具体文件系统层以及外设接口层，其中VFS层的作用是用来管理不同的文件系统并向上提供一致的接口给内核其他部分访问。在ucore中我们已经实现了一个具体的文件系统：Simple FS，并将该文件系统装载到了disk0上，假设ucore又实现了一个文件系统FAT32，并将这个新的文件系统装载到了disk1上。</p>
<h3 id="1-5"><a class="markdownIt-Anchor" href="#1-5"></a> （1）</h3>
<p>请简单描述一下如何修改VFS层的数据结构使其可以有效的管理上述已安装的具体文件系统。涉及VFS层的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;                                                   </span><br><span class="line">    bool readable;                                         </span><br><span class="line">    bool writable;   </span><br><span class="line">    int fd;                                                     </span><br><span class="line">    off_t pos;                                               </span><br><span class="line">    struct inode *node;                             </span><br><span class="line">    atomic_t open_count;                           </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">    union &#123;                                                                 </span><br><span class="line">        struct device __device_info;                   </span><br><span class="line">        struct sfs_inode __sfs_inode_info;       </span><br><span class="line">    &#125; in_info;  /* info */</span><br><span class="line">    enum &#123;</span><br><span class="line">        inode_type_device_info = 0x1234,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;  /* info */                                   </span><br><span class="line">    atomic_t ref_count;</span><br><span class="line">    atomic_t open_count;                               </span><br><span class="line">    struct fs *in_fs;                                     </span><br><span class="line">    const struct inode_ops *in_ops;                     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct fs &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct sfs_fs __sfs_info;                                     </span><br><span class="line">    &#125; fs_info; /* info */</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type; /* info */</span><br><span class="line"></span><br><span class="line">    int (*fs_sync)(struct fs *fs);                                                   </span><br><span class="line">    struct inode *(*fs_get_root)(struct fs *fs);     </span><br><span class="line">    int (*fs_unmount)(struct fs *fs);                                     </span><br><span class="line">    void (*fs_cleanup)(struct fs *fs);                                   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inode_ops &#123;</span><br><span class="line">    unsigned long vop_magic;</span><br><span class="line">    int (*vop_open)(struct inode *node, uint32_t open_flags);</span><br><span class="line">    int (*vop_close)(struct inode *node);</span><br><span class="line">    int (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_create)(struct inode *node, const char *name,</span><br><span class="line">    bool excl, struct inode **node_store);</span><br><span class="line">    int (*vop_lookup)(struct inode *node, char *path,</span><br><span class="line">    struct inode **node_store);</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>对VFS必要的修改并不多，原因很简单：这是<strong>V</strong>FS。需要在以下位置添加必要信息：</p>
<ul>
<li>在<code>inode.in_info</code>对应的匿名union中添加<code>struct fat32_inode __fat32_inode_info;</code></li>
<li>在<code>inode.in_type</code>对应的匿名<code>enum</code>中添加<code>inode_type_fat32_inode_info,</code></li>
<li>在<code>fs.fs_info</code>对应的匿名<code>union</code>中添加<code>struct fat32_fs __fat32_info;</code></li>
<li>在<code>fs.fs_type</code>对应的匿名<code>enum</code>中添加<code>fs_type_fat32_info,</code></li>
</ul>
<h3 id="3-2"><a class="markdownIt-Anchor" href="#3-2"></a> （3）</h3>
<p>两个具体文件系统均已实现了对数据文件的4种基本操作。现在有某个用户态进程执行了一个<code>copy(source_path, dest_path, ...)</code>函数，该函数是把disk1根目录下的一个文件A.txt拷贝到了disk0的根目录下（不用考虑文件的大小），请结合ucore中对数据文件的操作流程描述一下这个函数的执行过程。</p>
<hr>
<p>以下内容来自学长答案。</p>
<ol>
<li>根据源文件目录调用<code>vop_lookup</code>查找文件的inode，这将调用FAT32的查找实现</li>
<li>根据目的文件路径调用<code>vop_lookup</code>查找文件的inode，这将调用SFS的查找实现</li>
<li>判断合法性</li>
<li>可能需要创建文件</li>
<li>open文件</li>
<li>建立buffer，对A调用<code>vop_read</code>，对B调用<code>vop_write</code></li>
<li>关闭文件</li>
</ol>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-ucore-lab-4-report/">
              
                  《操作系统》ucore实验四“内核线程管理”报告
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h2>
<ul>
<li>了解内核线程创建/执行的管理过程</li>
<li>了解内核线程的切换和基本调度过程</li>
</ul>
<h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<p>实验2/3完成了物理和虚拟内存管理，这给创建内核线程（ 内核线程是一种特殊的进程） 打下了提供内存管理的基础。当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（ 这里用线程或进程表示） “感到”它们各自拥有“自己”的CPU。</p>
<p>本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li>内核线程只运行在内核态</li>
<li>用户进程会在在用户态和内核态交替运行</li>
<li>所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间</li>
<li>而用户进程需要维护各自的用户内存空间</li>
</ul>
<p>相关原理介绍可看附录B：【原理】进程/线程的属性与特征解析。</p>
<h3 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h3>
<p>本实验依赖实验1/2/3。请把你做的实验1/2/3的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。</p>
<hr>
<ul>
<li>Lab1：
<ul>
<li><code>kdebug.c:print_stackframe</code></li>
<li><code>trap.c:idt_init</code></li>
<li><code>trap.c:trap_dispatch</code></li>
</ul>
</li>
<li>Lab2：
<ul>
<li><code>default_pmm.c:default_init</code></li>
<li><code>default_pmm.c:default_init_memmap</code></li>
<li><code>default_pmm.c:default_alloc_pages</code></li>
<li><code>default_pmm.c:default_free_pages</code></li>
<li><code>pmm.c:get_pte</code></li>
<li><code>pmm.c:page_remove_pte</code></li>
</ul>
</li>
<li>Lab3：
<ul>
<li><code>vmm.c:do_pgfault</code></li>
<li><code>swap_fifo.c:__fifo_map_swappable</code></li>
<li><code>swap_fifo.c:__fifo_swap_out_victim</code></li>
</ul>
</li>
</ul>
<h3 id="练习1分配并初始化一个进程控制块需要编码"><a class="markdownIt-Anchor" href="#练习1分配并初始化一个进程控制块需要编码"></a> 练习1：分配并初始化一个进程控制块（需要编码）</h3>
<p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p>
<blockquote>
<p>【提示】在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括：state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。</p>
</blockquote>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请说明<code>proc_struct</code>中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</li>
</ul>
<hr>
<h4 id="11-具体实现"><a class="markdownIt-Anchor" href="#11-具体实现"></a> 1.1 具体实现</h4>
<p>注释中给出了以下域的说明，其中有些是不需要在这个函数中进行分配的：</p>
<ul>
<li><code>enum proc_state state</code>：表示进程状态，在此函数中应赋值为<code>PROC_UNINIT</code>，表示该进程的初始化尚未完成（对进程状态的修改在<code>do_fork</code>函数的最后，通过调用<code>sched.c:wakeup_proc</code>函数完成）</li>
<li><code>int pid</code>：初始赋值为-1，表示尚未分配（<code>pid</code>在<code>do_fork</code>函数中通过调用<code>get_pid</code>进行分配）</li>
<li><code>int runs</code>：已运行次数，此处赋值为0</li>
<li><code>uintptr_t kstack</code>：内核堆栈起始地址，此时堆栈尚未分配，因此置为0；实际在<code>do_fork</code>函数中通过调用<code>setup_kstack</code>进行分配</li>
<li><code>volatile bool need_resched</code>：当前进程是否需要调度；初始化为不需要（0）</li>
<li><code>struct proc_struct *parent</code>：当前进程的父进程，初始化为<code>NULL</code>；在<code>do_fork</code>中初始化为调用<code>do_fork</code>的当前进程</li>
<li><code>struct mm_struct *mm</code>：内存管理，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_mm</code>进行初始化（虽然实际上直接使用了内核的mm，因为是内核线程）</li>
<li><code>struct context context</code>：在Lab5中发现context需要清零，但在此处似乎不初始化也能正常运行；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>struct trapframe *tf</code>：当前的中断帧，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>uintptr_t cr3</code>：当前进程的页表基地址；直接初始化为kernel的页表基地址<code>boot_cr3</code></li>
<li><code>uint32_t flags</code>：当前进程属性，因为是初始化，所以置为0了</li>
<li><code>char name[PROC_NAME_LEN + 1]</code>：进程的名称，此处初始化似乎不是很重要，不过还是清零了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="line">static struct proc_struct *</span><br><span class="line">alloc_proc(void) &#123;</span><br><span class="line">    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));</span><br><span class="line">    if (proc != NULL) &#123;</span><br><span class="line">    //LAB4:EXERCISE1 YOUR CODE</span><br><span class="line">    	proc-&gt;state = PROC_UNINIT;  // 正在创建和初始化状态中</span><br><span class="line">    	proc-&gt;pid = -1;  // 参考了答案：未初始化的进程id为-1</span><br><span class="line">    	proc-&gt;runs = 0;  // 还没有运行过</span><br><span class="line">    	proc-&gt;kstack = 0;  // 参考了答案：初始化内核堆栈似乎是在do_fork()中进行的？</span><br><span class="line">    	proc-&gt;need_resched = 0;  // 初始化为不需要调度</span><br><span class="line">    	proc-&gt;parent = NULL;</span><br><span class="line">    	proc-&gt;mm = NULL;  // 之后也不会分配，因为都是内核态线程，所以直接使用内核的mm</span><br><span class="line">    	memset(&amp;(proc-&gt;context), 0, sizeof(struct context));  // 在LAB5中发现，忘了清零context了</span><br><span class="line">    	// proc-&gt;tf = kmalloc(sizeof(struct trapframe));  // tf似乎不需要在此处设置</span><br><span class="line">    	proc-&gt;cr3 = boot_cr3;  // 参考了答案：内核态线程不需要分配新的页表地址；这对于正确执行是必需的</span><br><span class="line">    	proc-&gt;flags = 0;  // 参考了答案：标志位置为0</span><br><span class="line">    	memset(proc-&gt;name, 0, PROC_NAME_LEN);  // 参考了答案：将进程名清零，不过不是必需的</span><br><span class="line">    &#125;</span><br><span class="line">    return proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-context和trapframe的含义和用途"><a class="markdownIt-Anchor" href="#12-context和trapframe的含义和用途"></a> 1.2 <code>context</code>和<code>trapframe</code>的含义和用途</h4>
<p>实验指导书中指出：</p>
<ul>
<li><code>context</code>：进程的上下文，用于进程切换（参见<code>switch.S</code>）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用<code>context</code>保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用<code>context</code>进行上下文切换的函数是<code>kern/process/switch.S:switch_to</code></li>
<li><code>tf</code>：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时<code>tf</code>总是能够指向当前的<code>trapframe</code>，uCore 在内核栈上维护了<code>tf</code>的链，可以参考<code>trap.c::trap</code>函数做进一步的了解。</li>
</ul>
<p>经过阅读代码，我认为，<code>switch_to</code>的主要工作是把被切换的进程的各个通用寄存器（eip、esp、ebx、ecx、edx、esi、edi、ebp，但不包括段寄存器，因为kernel进程使用的段是相同的）保存到进程的<code>context</code>结构中，然后加载即将开始运行的进程的<code>context</code>结构中保存的通用寄存器。而<code>trapframe</code>就是我们在Lab1中已经了解的中断保存现场。对于内核线程，<code>trapframe</code>的意义似乎并不大，因为不需要进行用户空间到内核空间的切换。</p>
<hr>
<p>今天我的某个叫wenj的同学指出了一个很有趣的问题，这使得我重新翻出了实验报告：<code>context</code>和<code>trapframe</code>中为何都存储了EIP？这两种结构的功能是否重复了？翻了翻实验指导书，发现其实这个问题已经有比较明确的解答了：<code>trapframe</code>一般来说是用户态切换到内核态用的，而<code>context</code>是内核态自己切换上下文用的（因为特权级不变，所以不需要存储页表基地址、段寄存器等内容）；不过用户态跳转到内核态的时候也需要保存<code>context</code>中的通用寄存器，因为<code>trapframe</code>不存通用寄存器。</p>
<p>以及，lab4中构建进程的过程是这样的：</p>
<ul>
<li>“硬”构造出第一个内核线程idleproc</li>
<li>调用<code>do_fork</code>函数，fork idleproc，生成initproc</li>
</ul>
<p>事实上initproc返回时会假装自己是通过系统调用<code>do_fork</code>生成的，所以返回过程会比较复杂：</p>
<blockquote>
<p>uCore会执行进程切换，让initproc执行。在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>，这样，当执行<code>switch_to</code>函数并返回后，initproc将执行其实际上的执行入口地址forkret。而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行，具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line"># restore registers from stack</span><br><span class="line">popal</span><br><span class="line"># restore %ds and %es</span><br><span class="line">popl %es</span><br><span class="line">popl %ds</span><br><span class="line"># get rid of the trap number and error code</span><br><span class="line">addl $0x8, %esp</span><br><span class="line">iret</span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line"># set stack to this new process&apos;s trapframe</span><br><span class="line">movl 4(%esp), %esp //把esp指向当前进程的中断帧</span><br><span class="line">jmp __trapret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，forkrets函数首先把esp指向当前进程的中断帧，从_trapret开始执行到iret前，esp指向了current-&gt;tf.tf_eip，而如果此时执行的是initproc，则current-&gt;tf.tf_eip=kernel_thread_entry，initproc-&gt;tf.tf_cs = KERNEL_CS，所以当执行完iret后，就开始在内核中执行kernel_thread_entry函数了，而initproc-&gt;tf.tf_regs.reg_ebx = init_main，所以在kernl_thread_entry中执行“call %ebx”后，就开始执行initproc的主体了。Initprocde的主体函数很简单就是输出一段字符串，然后就返回到kernel_tread_entry函数，并进一步调用do_exit执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。至此，实验四中的主要工作描述完毕。</p>
</blockquote>
<h3 id="练习2为新创建的内核线程分配资源需要编码"><a class="markdownIt-Anchor" href="#练习2为新创建的内核线程分配资源需要编码"></a> 练习2：为新创建的内核线程分配资源（需要编码）</h3>
<p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号<br>
请在实验报告中简要说明你的设计实现过程。请回答如下问题：</li>
<li>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</li>
</ul>
<hr>
<h4 id="21-具体代码实现"><a class="markdownIt-Anchor" href="#21-具体代码实现"></a> 2.1 具体代码实现</h4>
<p>函数的大致执行步骤与题目中列出的相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) &#123;</span><br><span class="line">    int ret = -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    //    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    if (proc == NULL) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;  // 参考了答案</span><br><span class="line">    //    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">    if (setup_kstack(proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    //    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">    // CLONE_VM表示分享；实际上因为都在内核态所以什么都没做，只是assert NULL了</span><br><span class="line">    if (copy_mm(clone_flags, proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    //    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">    copy_thread(proc, stack, tf);</span><br><span class="line">    //    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">    // 参考了答案：关中断的原因是，进程号要求唯一性，此操作需要为原子操作，防止被打断而重复添加</span><br><span class="line">    // 所以参考答案是很有必要的。但是我认为在实验指导书中也应该说明一下。</span><br><span class="line">    bool intr_flag;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">    	proc-&gt;pid = get_pid();</span><br><span class="line">		hash_proc(proc);</span><br><span class="line">		nr_process++;  // 参考答案添加在此处（我本来以为用了get_pid()就不需要这句了</span><br><span class="line">		list_add_before(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">    //    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    //    7. set ret vaule using child proc&apos;s pid</span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-能否为每个新线程赋值唯一id"><a class="markdownIt-Anchor" href="#22-能否为每个新线程赋值唯一id"></a> 2.2 能否为每个新线程赋值唯一ID</h4>
<p>阅读代码可以得知，<code>idleproc</code>的PID是由<code>proc_init</code>函数设置的，但<code>initproc</code>的PID应该怎么设置呢？我的解决方法是把分配PID的过程移到<code>do_fork</code>函数中，这样至少能通过测试了。参考答案的做法也类似，不过在分配PID和将进程插入队列的过程中进行了关中断处理，保证原子操作。</p>
<p>PID的唯一性是通过关中断和<code>get_pid</code>函数保证的，该函数查看当前的全部进程，在不发生中断的情况下，可以保证新分配的PID与之前的PID是不冲突的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// get_pid - alloc a unique pid for process</span><br><span class="line">static int</span><br><span class="line">get_pid(void) &#123;</span><br><span class="line">    static_assert(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    list_entry_t *list = &amp;proc_list, *le;</span><br><span class="line">    static int next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    if (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = 1;</span><br><span class="line">        goto inside;</span><br><span class="line">    &#125;</span><br><span class="line">    if (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = list;</span><br><span class="line">        while ((le = list_next(le)) != list) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            if (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                if (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    if (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    goto repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"><a class="markdownIt-Anchor" href="#练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"></a> 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）</h3>
<p>请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题：</p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用？请说明理由。</li>
</ul>
<p>完成代码编写后，编译并运行代码：<code>make qemu</code></p>
<p>如果可以得到如附录A所示的显示内容（仅供参考，不是标准答案输出），则基本正确。</p>
<hr>
<h4 id="31-内核线程"><a class="markdownIt-Anchor" href="#31-内核线程"></a> 3.1 内核线程</h4>
<p>分析一下<code>proc_init</code>函数的调用过程：</p>
<ul>
<li>初始化<code>proc_list</code>和<code>hash_list</code></li>
<li>调用<code>alloc_proc</code>函数分配<code>idleproc</code>所需的TCB块，检验是否分配成功</li>
<li>对<code>idleproc</code>进行基本设置（所以<code>alloc_proc</code>函数其实不需要干啥？）：
<ul>
<li>PID=0</li>
<li>state=PROC_RUNNABLE</li>
<li>kstack=bootstack</li>
<li>need_resched=1</li>
<li>name=“idle”</li>
</ul>
</li>
<li>将<code>current</code>变量置为<code>idleproc</code></li>
<li>调用<code>kernel_thread</code>函数，用<code>init_main</code>函数创建一个内核线程
<ul>
<li>创建所需的<code>trapframe</code></li>
<li>调用<code>do_fork</code>函数，创建新进程
<ul>
<li>调用<code>alloc_proc</code>，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
</li>
</ul>
</li>
<li>验证创建<code>initproc</code>线程成功（PID不为0）</li>
</ul>
<p><code>proc_init</code>函数是由<code>kern_init</code>函数调用的。在<code>kern_init</code>完成其余初始化之后，它调用<code>cpu_idle</code>函数，使得当前的<code>idle_proc</code>进程让出控制权，交给<code>initproc</code>线程，进行上下文的切换；执行完之后，回到<code>kernel_thread_entry</code>，退出。</p>
<p>由以上分析可知，在本实验的执行过程中，一共只创建了两个内核线程（<code>idleproc</code>和<code>initproc</code>）。</p>
<h4 id="32-关中断的必要性"><a class="markdownIt-Anchor" href="#32-关中断的必要性"></a> 3.2 关中断的必要性</h4>
<p>以下回答来自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=309" target="_blank" rel="noopener">Piazza</a>：</p>
<blockquote>
<p>由于进程号要求唯一性，进程号分配时可能需要查看进程列表中全部进程以避免发生冲突。若进程号已分配而进程尚未添加进进程列表时被中断，则该进程号可能会被重复分配，故进程号分配与进程添加应为原子操作。因而在进行上述操作时需关闭中断。</p>
</blockquote>
<h3 id="33-proc_run函数如何完成进程切换"><a class="markdownIt-Anchor" href="#33-proc_run函数如何完成进程切换"></a> 3.3 <code>proc_run</code>函数如何完成进程切换</h3>
<p>对进程切换的控制是通过<code>sched.c:schedule</code>函数完成的。一旦当前进程的<code>need_resched</code>变量被置为1，就调用<code>schedule</code>函数选择下一个要运行的进程，调用<code>proc_run</code>函数开始运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">schedule(void) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    list_entry_t *le, *last;</span><br><span class="line">    struct proc_struct *next = NULL;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = 0;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line">        do &#123;</span><br><span class="line">            if ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                if (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (le != last);</span><br><span class="line">        if (next == NULL || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        if (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就进入了<code>proc_run</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc != current) &#123;</span><br><span class="line">        bool intr_flag;</span><br><span class="line">        struct proc_struct *prev = current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的执行过程如下：</p>
<ol>
<li>关闭中断，保证原子操作</li>
<li>调用<code>load_esp0</code>函数，设置任务状态段<code>ts</code>中特权态0下的栈顶指针<code>esp0</code>为要切换到的内核线程的内核栈的栈顶，即<code>next-&gt;kstack + KSTACKSIZE</code>（建立指针的目的是，进行特权态切换时能够正确定位处于特权态0时进程的内核栈的栈顶）</li>
<li>设置CR3寄存器的值为要切换到的内核线程的页目录表起始地址，这实际上是完成进程间的页表切换，不过在内核中的内存切换下其实用不到</li>
<li>由 <code>switch_to</code>函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当<code>switch_to</code>函数执行完<code>ret</code>指令后，就切换到 <code>initproc</code>执行了</li>
</ol>
<p>在切换现场时，倒数第二条汇编指令<code>pushl 0(%eax)</code>其实把<code>context</code>中保存的下一个进程要执行的指令地址<code>context.eip</code>放到了堆栈顶，这样接下来执行最后一条指令<code>ret</code>时，会把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了。</p>
<p>事实上，在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>（见<code>copy_thread</code>函数），这样，当执行<code>switch_to</code>函数并返回后，将进入实际的执行入口地址<code>forkret</code>。而<code>forkret</code>会调用位于<code>kern/trap/trapentry.</code>S中的<code>forkrets</code>（参数是切换之后的进程的中断帧地址，该地址位于内核中线程对应的栈中，如果我没理解错的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&apos;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>forkrets</code>函数首先把<code>esp</code>指向当前进程的中断帧，然后跳转到<code>__trapret</code>，从中恢复中断帧的各个寄存器。这些寄存器是在<code>kernel_thread</code>函数中设置的，包括：</p>
<ul>
<li><code>tf.tf_cs = KERNEL_CS</code>：和内核使用同一代码段（这是合理的，因为<code>initproc</code>对应的代码也是内核的一部分）</li>
<li><code>tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS</code>：和内核使用同一数据（堆栈）段</li>
<li><code>tf.tf_regs.reg_ebx = (uint32_t)fn</code>：寄存器中的<code>ebx</code>为函数起始地址</li>
<li><code>tf.tf_regs.reg_edx = (uint32_t)arg</code>：寄存器中的<code>edx</code>指向函数参数地址</li>
<li><code>tf.tf_eip = (uint32_t)kernel_thread_entry</code>：中断后的实际起始地址是<code>kernel_thread_entry</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>对于<code>initproc</code>，<code>current-&gt;tf.tf_eip=kernel_thread_entry</code>，<code>initproc-&gt;tf.tf_cs = KERNEL_CS</code>，所以执行完<code>iret</code>后，就开始在内核中执行<code>kernel_thread_entry</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread</span><br></pre></td></tr></table></figure>
<p>首先把进程的参数入栈，然后调用起始地址（现在是实际的起始地址了，对于<code>initproc</code>，这个起始地址就是<code>init_main</code>函数的开头）。所以执行<code>call %ebx</code>后，就开始执行<code>initproc</code>的主体了。</p>
<p>执行结束后，返回到<code>kernel_tread_entry</code>函数，它会进一步调用<code>proc.c:do_exit</code>函数，执行退出操作。目前这个函数除了打印一点字符串没有做别的工作。</p>
<h3 id="扩展练习challenge实现支持任意大小的内存分配算法"><a class="markdownIt-Anchor" href="#扩展练习challenge实现支持任意大小的内存分配算法"></a> 扩展练习Challenge：实现支持任意大小的内存分配算法</h3>
<p>这不是本实验的内容，其实是上一次实验内存的扩展，但考虑到现在的slab算法比较复杂，有必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的slab如何调用基于页的内存分配算法（注意，不是要你关注slab的具体实现）来实现first-fit/best-fit/worst-fit/buddy等支持任意大小的内存分配算法。</p>
<p>【注意】下面是相关的Linux实现文档，供参考<br>
SLOB<br>
<a href="http://en.wikipedia.org/wiki/SLOB" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SLOB</a> <a href="http://lwn.net/Articles/157944/" target="_blank" rel="noopener">http://lwn.net/Articles/157944/</a><br>
SLAB<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></p>
<hr>
<p>没写。</p>
<h2 id="分析参考答案"><a class="markdownIt-Anchor" href="#分析参考答案"></a> 分析参考答案</h2>
<ul>
<li><code>alloc_proc</code>：和参考答案的实现类似，参考了答案中的一些我忘了写的部分，如初始化内核堆栈和将context清零</li>
<li><code>do_fork</code>：参考了答案，添加了一些错误处理，以及分配pid时关中断</li>
</ul>
<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点</h2>
<ul>
<li>进程状态</li>
<li>进程控制块</li>
<li>内核栈和用户栈</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/ucore/"><i class="fas fa-hashtag fa-fw"></i>ucore</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2015-final-exam-analysis/">
              
                  《操作系统》2015年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href></a>。这个卷子实在过于长了，不仅莫名有一个完整的缓冲区问题的实现，还有一堆ucore代码需要阅读和填空。</p>
<h2 id="一10分"><a class="markdownIt-Anchor" href="#一10分"></a> 一（10分）</h2>
<p>在用<code>do_execve</code>启动一个用户态进程时，ucore需要完成很多准备工作，这些工作有的在内核态完成，有的在用户态完成。请判断下列事项是否是ucore在正常完成<code>do_execve</code>中所需要的，如果是，指出它完成于内核态还是用户态（通过修改<code>trapframe</code>，在<code>iret</code>时改变寄存器的过程被认为是在内核态完成）。</p>
<ol>
<li>初始化进程所使用的栈</li>
<li>在栈上准备argc和argv的内容</li>
<li>将argc和argv作为用户main函数的参数放到栈上</li>
<li>设置EIP为用户main函数的地址</li>
<li>设置系统调用的返回值</li>
</ol>
<hr>
<ol>
<li>需要；内核态</li>
<li>需要；内核态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li>不需要</li>
</ol>
<p>这个题出的很没有意义啊，系统调用返回之后几乎就要立即跳转到用户进程指令的第一条了。</p>
<p>以下内容摘自ucore docs Lab5：</p>
<blockquote>
<p>最终通过<code>do_execve</code>函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
</blockquote>
<ul>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。<br>
……<br>
load_icode函数的工作：</li>
</ul>
<ol>
<li>初始化mm</li>
<li>分配和设置页目录表</li>
<li>解析ELF文件，建立vma，初始化进程的用户态虚拟地址空间</li>
<li>分配物理内存空间，建立页表映射关系，拷贝程序内容</li>
<li>设置用户栈</li>
<li>将页目录表基地址加载到CR3寄存器中</li>
<li>重设进程中断帧，准备切换到用户态<br>
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句） 后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。</li>
</ol>
<p>2018.5.25 UPD：<br>
tsz同学指出，事实上这道题和第六大题的代码内容直接相关。从中可以看出，<code>user/libs/initcode.S</code>做的就是在用户态为<code>main</code>函数设置参数的工作。所以3和4的答案应该修改一下。事实证明，想当然是不好的。</p>
<h2 id="二-vsfs18分"><a class="markdownIt-Anchor" href="#二-vsfs18分"></a> 二 VSFS（18分）</h2>
<p>这道题和<a href="/post/os-mooc-final-exam-analysis">MOOC期末考试题</a>中的第20题一模一样，所以略。</p>
<h2 id="三-进程状态变化16分"><a class="markdownIt-Anchor" href="#三-进程状态变化16分"></a> 三 进程状态变化（16分）</h2>
<p>在ucore中<code>enum proc_state</code>的定义包含以下四个值：</p>
<ul>
<li><code>PROC_UNINIT</code></li>
<li><code>PROC_SLEEPING</code></li>
<li><code>PROC_RUNNABLE</code></li>
<li><code>PROC_ZOMBIE</code><br>
请解释每一种状态的含义，以及各状态之间可能的迁移。</li>
</ul>
<hr>
<ul>
<li><code>PROC_UNINIT</code>：刚申请完进程控制块，进程还未被初始化</li>
<li><code>PROC_SLEEPING</code>：进程处于等待状态</li>
<li><code>PROC_RUNNABLE</code>：进程处于就绪或运行状态</li>
<li><code>PROC_ZOMBIE</code>：僵尸状态，进程已经退出，等待父进程进一步回收资源</li>
</ul>
<p>以下内容（进程的正常生命周期）摘自ucore docs Lab6：</p>
<blockquote>
<p>进程的正常生命周期如下：</p>
</blockquote>
<ul>
<li>进程首先在cpu初始化或者<code>sys_fork</code>的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入<code>uninit</code>态(在<code>proc.c</code>中<code>alloc_proc</code>)。</li>
<li>当进程完全完成初始化之后，该进程转为<code>runnable</code>态。</li>
<li>当到达调度点时，由调度器<code>sched_class</code>根据运行队列<code>rq</code>的内容来判断一个进程是否应该被运行，即把处于<code>runnable</code>态的进程转换成<code>running</code>状态，从而占用CPU执行。</li>
<li><code>running</code>态的进程通过<code>wait</code>等系统调用被阻塞，进入<code>sleeping</code>态。</li>
<li><code>sleeping</code>态的进程被<code>wakeup</code>变成<code>runnable</code>态的进程。</li>
<li><code>running</code>态的进程主动<code>exit</code>变成<code>zombie</code>态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为<code>unused</code>。</li>
<li>所有从<code>runnable</code>态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ul>
<p>以下内容摘自<a href="https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-4/process_status_change.html" target="_blank" rel="noopener">进程运行状态转变过程</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process state changing:</span><br><span class="line"></span><br><span class="line">  alloc_proc                                 RUNNING</span><br><span class="line">      +                                   +--&lt;----&lt;--+</span><br><span class="line">      +                                   + proc_run +</span><br><span class="line">      V                                   +--&gt;----&gt;--+</span><br><span class="line">PROC_UNINIT -- proc_init/wakeup_proc --&gt; PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --&gt; PROC_SLEEPING --</span><br><span class="line">                                           A      +                                                           +</span><br><span class="line">                                           |      +--- do_exit --&gt; PROC_ZOMBIE                                +</span><br><span class="line">                                           +                                                                  +</span><br><span class="line">                                           -----------------------wakeup_proc----------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="四-stride调度算法15分"><a class="markdownIt-Anchor" href="#四-stride调度算法15分"></a> 四 Stride调度算法（15分）</h2>
<p>假设在lab6测试stride scheduling的过程中，采用如下默认配置：BigStride为0x7FFFFFFF，CPU时间片为50ms，测试过程包含五个进程，其初始<del>stride</del>pass均为1，优先级分别为1、2、3、4、5，测试时间为10s。下面给出了五种修改上述配置的方式，试讨论：对于每一种改动，测试结果相比改动之前是否会发生明显的变化？如果是，结果会变得更接近于理想情况，还是远离理想情况？</p>
<ol>
<li>BigStride改为120</li>
<li>CPU时间片改为5ms</li>
<li>五个进程的初始pass改为100</li>
<li>五个进程的优先级设为2、4、6、8、10</li>
<li>测试时间延长到20s</li>
</ol>
<hr>
<p>在测试时间10s的情况下，时间片总个数为200。</p>
<ol>
<li>如果将BigStride改为120，则stride最大为120，不会溢出，而且120能够整除1、2、3、4、5，更能够保证进程的pass按优先级推进，因此会更接近于理想情况</li>
<li>时间片总个数变成2000，因为进程stride有偏差，因此会远离理想情况</li>
<li>因为100这个值相比各个进程的stride太小了，所以应该不会有明显变化</li>
<li>不会有明显变化</li>
<li>同2，更远离理想情况</li>
</ol>
<p>这个题目中不同学长的答案大相径庭，所以我选了一种我觉得合理的。事实上，Stride调度算法的论文中讨论了一下误差问题：在stride和优先级精确地成反比的情况下，各个线程之间按比例分配到的时间片数量的误差不超过1，也就是说，总误差是O(nc)（nc是线程数量）。所以大概stride计算不准确造成的影响是比较大的。</p>
<h2 id="五-生产者-消费者问题10分"><a class="markdownIt-Anchor" href="#五-生产者-消费者问题10分"></a> 五 生产者-消费者问题（10分）</h2>
<p>生产者-消费者问题是指，一组生产者进程和一组消费者进程共享一个初始为空、大小为3（不如说是BUFFER_SIZE）的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个生产者放入消息，或者一个消费者从中取出消息。</p>
<p>下面是生产者-消费者问题的一个实现和测试结果。请回答下面问题：</p>
<ol>
<li>请用伪码给出信号量的PV操作实现。</li>
<li>这个实现正确吗？如果不正确，给出你的正确实现。</li>
<li>这两个测试用例能发现该实现中的可能错误吗？如果不能，请给出你的尽可能完整的测试用例。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">==== producer-consumer.cpp ====</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;new&gt; // ::operator new[]</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define BUFFER_SIZE 3</span><br><span class="line">#define SLEEP_SPAN 5</span><br><span class="line">#define WORK_SPAN 4</span><br><span class="line"></span><br><span class="line">#define PRODUCER 0</span><br><span class="line">#define CONSUMER 1</span><br><span class="line"></span><br><span class="line">int iflag = 0;</span><br><span class="line">int oflag = 0;</span><br><span class="line">sem_t empty, full, mutex;</span><br><span class="line">int empty_count, full_count;</span><br><span class="line">int data_num = 0;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">int buffer[BUFFER_SIZE] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int p_task_done = -1;</span><br><span class="line">int c_task_done = -1;</span><br><span class="line"></span><br><span class="line">struct arg_struct &#123;</span><br><span class="line">    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent) &#123;&#125;</span><br><span class="line">    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&quot;&quot;)) &#123;&#125;</span><br><span class="line">    int id;</span><br><span class="line">    int start;</span><br><span class="line">    int work;</span><br><span class="line">    string indent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void* producer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;empty);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    int time = rand() % SLEEP_SPAN;</span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    p_task_done++;</span><br><span class="line">    printf(&quot;%sProd %d\n&quot;, indent, p_task_done);</span><br><span class="line"></span><br><span class="line">    buffer[iflag] = p_task_done;</span><br><span class="line"></span><br><span class="line">    if (empty_count == 0) printf(&quot;Error: Produce while no empty\n&quot;);</span><br><span class="line">    iflag = (iflag + 1) % BUFFER_SIZE;</span><br><span class="line">    empty_count--;</span><br><span class="line">    full_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;full);</span><br><span class="line">    printf(&quot;%srFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* consumer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line">    sem_wait(&amp;full);</span><br><span class="line">    printf(&quot;%saFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    ++c_task_done;</span><br><span class="line">    if (full_count == 0) printf(&quot;Error: Consume while no full\n&quot;);</span><br><span class="line"></span><br><span class="line">    int tmp = buffer[oflag];</span><br><span class="line">    printf(&quot;%sCons %d\n&quot;, indent, tmp);</span><br><span class="line"></span><br><span class="line">    oflag = (oflag + 1) % BUFFER_SIZE;</span><br><span class="line">    if (c_task_done != tmp) printf(&quot;Error: Consume data wrong\n&quot;);</span><br><span class="line">    if (c_task_done &gt; p_task_done) printf(&quot;Error: Over-consume!\n&quot;);</span><br><span class="line"></span><br><span class="line">    full_count--;</span><br><span class="line">    empty_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;empty);</span><br><span class="line">    printf(&quot;%srEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define N 3</span><br><span class="line">void testcase_producer_consumer(int ThreadNumber, int inst[2 * N][3]) &#123;</span><br><span class="line">    pthread_t * p_consumer = new pthread_t[ThreadNumber];</span><br><span class="line">    pthread_t * p_producer = new pthread_t[ThreadNumber];</span><br><span class="line"></span><br><span class="line">    int c_count = 0, p_count = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;testcase_producer_consumer:\n&quot;);</span><br><span class="line">    /* For managed creation of &apos;ThreadNumber&apos; threads */</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    /* Print the first line */</span><br><span class="line">    int tmp_c = 0, tmp_p = 0;</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER) &#123;</span><br><span class="line">            printf(&quot;P%d\t&quot;, tmp_p++);</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER) &#123;</span><br><span class="line">            printf(&quot;C%d\t&quot;, tmp_c++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* Create Producers and Consumers according to $inst*/</span><br><span class="line">    int rc;</span><br><span class="line">    string indent(&quot;&quot;);</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER)  &#123;</span><br><span class="line">            rc = pthread_create(p_producer + p_count, NULL, producer, new arg_struct(p_count, inst[i][1],</span><br><span class="line">            inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            p_count++;</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER)&#123;</span><br><span class="line">            rc = pthread_create(p_consumer + c_count, NULL, consumer, new arg_struct(c_count, inst[i][1],             inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            c_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        indent += &apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* wait until every thread finishes*/</span><br><span class="line">    for (int i = 0; i &lt; p_count; i++) &#123;</span><br><span class="line">        pthread_join(p_producer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; c_count; i++) &#123;</span><br><span class="line">        pthread_join(p_consumer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] p_producer;</span><br><span class="line">    delete[] p_consumer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line"></span><br><span class="line">    memset(buffer, 0, sizeof(int) * BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex, 0, 1);</span><br><span class="line">    sem_init(&amp;empty, 0, BUFFER_SIZE);</span><br><span class="line">    sem_init(&amp;full, 0, 0);</span><br><span class="line"></span><br><span class="line">    empty_count = BUFFER_SIZE;</span><br><span class="line">    full_count = 0;</span><br><span class="line"></span><br><span class="line">    /* For managed creation of 2 * N threads */</span><br><span class="line">    int ThreadNumber = 2 * N ;</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    int inst[2 * N][3] = &#123;</span><br><span class="line">        /* &#123; Consumer or Producer to be create?,</span><br><span class="line">        When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">        How long does it work after it enters critical zone? &#125; */</span><br><span class="line">        &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst);</span><br><span class="line">    st_time = 0;</span><br><span class="line"></span><br><span class="line">    int inst2[2 * N][3] = &#123;</span><br><span class="line">        &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例的执行输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">xyong@ubuntu-xyong:~/work$ gcc producer-consumer.cpp -lpthread -lstdc++</span><br><span class="line">xyong@ubuntu-xyong:~/work$ ./a.out</span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">C0    C1    C2    P0    P1    P2</span><br><span class="line">START</span><br><span class="line">      START</span><br><span class="line">            START</span><br><span class="line">                  START</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  aEMPTY</span><br><span class="line">                  ENTER</span><br><span class="line">                  Prod 0</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rFULL</span><br><span class="line">aFULL</span><br><span class="line">aMUTEX</span><br><span class="line">ENTER</span><br><span class="line">                        START</span><br><span class="line">Cons 0</span><br><span class="line">EXIT</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">rMUTEX</span><br><span class="line">rEMPTY</span><br><span class="line">                        Prod 1</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">      aFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      ENTER</span><br><span class="line">      Cons 1</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 2</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">            aFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">            Cons 2</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line"></span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">P0    P1    C0    C1    P2    C2</span><br><span class="line">START</span><br><span class="line">aMUTEX</span><br><span class="line">aEMPTY</span><br><span class="line">ENTER</span><br><span class="line">      START</span><br><span class="line">Prod 3</span><br><span class="line">EXIT</span><br><span class="line">rMUTEX</span><br><span class="line">rFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      aEMPTY</span><br><span class="line">      ENTER</span><br><span class="line">            START</span><br><span class="line">            aFULL</span><br><span class="line">      Prod 4</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">                  START</span><br><span class="line">                  aFULL</span><br><span class="line">            Cons 3</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  ENTER</span><br><span class="line">                  Cons 4</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 5</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">                              START</span><br><span class="line">                              aFULL</span><br><span class="line">                              aMUTEX</span><br><span class="line">                              ENTER</span><br><span class="line">                              Cons 5</span><br><span class="line">                              EXIT</span><br><span class="line">                              rMUTEX</span><br><span class="line">                              rEMPTY</span><br><span class="line">xyong@ubuntu-xyong:~/work$</span><br></pre></td></tr></table></figure>
<hr>
<p>这道题真是又臭又长……</p>
<p>信号量PV操作的伪代码：这个是十分简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P() &#123;</span><br><span class="line">    sem--;</span><br><span class="line">    if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    if (sem &lt;= 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是否正确？答案是不正确。producer线程的实现中获取<code>mutex</code>和<code>empty</code>信号量的顺序反了。总的来说，把这两个换一下就好了。</p>
<p>题目中给出的两个测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int inst[2 * N][3] = &#123;</span><br><span class="line">    /* &#123; Consumer or Producer to be create?,</span><br><span class="line">    When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">    How long does it work after it enters critical zone? &#125; */</span><br><span class="line">    &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我给出的测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目中并没有要求Producer和Consumer的数量必须为3个。从理论上来说，只要Producer比Consumer大的个数在3个（也就是缓冲区的大小）以内，都能正常结束。但是在错误实现中会发生这样的问题：P1-P3生产完之后，P4获得<code>mutex</code>后开始在<code>empty</code>信号量上等待。但是，由于它占据了<code>mutex</code>，因此C1和C2无法进入临界区进行消费，于是也不会对<code>empty</code>信号量执行V操作，发生死锁。</p>
<h2 id="六-ucore用户进程16分"><a class="markdownIt-Anchor" href="#六-ucore用户进程16分"></a> 六 ucore用户进程（16分）</h2>
<p>下面是关于ucore中用户程序的生命历程的代码。请完成下面填空和代码补全。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>在<code>sh</code>的命令行上输入<code>args 1</code>启动用户程序<code>args</code>，则<code>sh</code>会调用（<strong>1</strong>）创建新进程并调用（<strong>2</strong>）将<code>args</code>加载到该进程的地址空间中。（回答系统调用名称即可）</p>
<ol>
<li><code>SYS_fork</code></li>
<li><code>SYS_exec</code></li>
</ol>
<hr>
<p>这一题使我觉得我应该复习一下ucore里的各种系统调用、实现方法及其作用。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>将<code>args</code>从硬盘加载主要由<code>load_icode</code>完成，请补全以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">// load_icode - called by sys_exec--&gt;do_execve</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">load_icode(int fd, int argc, char **kargv) &#123;</span><br><span class="line">    /* LAB8:EXERCISE2 YOUR CODE HINT:how to load the file with handler fd in to process&apos;s memory? how to setup argc/argv?</span><br><span class="line">    * MACROs or Functions:</span><br><span class="line">    * mm_create - create a mm</span><br><span class="line">    * setup_pgdir - setup pgdir in mm</span><br><span class="line">    * load_icode_read - read raw data content of program file</span><br><span class="line">    * mm_map - build new vma</span><br><span class="line">    * pgdir_alloc_page - allocate new memory for TEXT/DATA/BSS/stack parts</span><br><span class="line">    * lcr3 - update Page Directory Addr Register -- CR3</span><br><span class="line">    */</span><br><span class="line">    /* (1) create a new mm for current process</span><br><span class="line">    * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="line">    * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="line">    * (3.1) read raw data content in file and resolve elfhdr</span><br><span class="line">    * (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="line">    * (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="line">    * (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="line">    * and copy them into the new allocated pages</span><br><span class="line">    * (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="line">    * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="line">    * (5) setup current process&apos;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="line">    * (6) setup uargc and uargv in user stacks</span><br><span class="line">    * (7) setup trapframe for user environment</span><br><span class="line">    * (8) if up steps failed, you should cleanup the env.</span><br><span class="line">    */</span><br><span class="line">    assert(argc &gt;= 0 &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    if (current-&gt;mm != NULL) &#123;</span><br><span class="line">        panic(&quot;load_icode: current-&gt;mm must be empty.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = -E_NO_MEM;</span><br><span class="line">    struct mm_struct *mm;</span><br><span class="line">    if ((mm = mm_create()) == NULL) &#123;</span><br><span class="line">        goto bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    if (setup_pgdir(mm) != 0) &#123;</span><br><span class="line">        goto bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Page *page;</span><br><span class="line"></span><br><span class="line">    struct elfhdr __elf, *elf = &amp;__elf;</span><br><span class="line">    /* 2a */</span><br><span class="line">    if ((ret = load_icode_read(fd, elf, _(2a)_, 0)) != 0) &#123;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr __ph, *ph = &amp;__ph;</span><br><span class="line">    uint32_t vm_flags, perm, phnum;</span><br><span class="line">    for (phnum = 0; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;</span><br><span class="line">        off_t phoff = elf-&gt;e_phoff + sizeof(struct proghdr) * phnum;</span><br><span class="line">        if ((ret = load_icode_read(fd, ph, sizeof(struct proghdr), phoff)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            /* 2b */</span><br><span class="line">            _(2b)_</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz == 0) &#123;</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = 0, perm = PTE_U;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        if (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        if ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        off_t offset = ph-&gt;p_offset;</span><br><span class="line">        size_t off, size;</span><br><span class="line">        uintptr_t start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != 0) &#123;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">        if (start &lt; la) &#123;</span><br><span class="line">            /* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br><span class="line">            if (start == end) &#123;</span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    /* 2c */</span><br><span class="line">    if ((ret = mm_map(mm, _(2c)_, USTACKSIZE, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">        goto bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    //setup argc, argv</span><br><span class="line">    uint32_t argv_size=0, i;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">    char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">    argv_size = 0;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        /* 2d */</span><br><span class="line">        _(2d)_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">    /* 2e */</span><br><span class="line">    *(int *)stacktop = _(2e)_;</span><br><span class="line"></span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    memset(tf, 0, sizeof(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = 0;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sizeof(struct elfhdr)</code>（读一个<code>elfhdr</code>大小的文件数据）</li>
<li><code>goto bad_cleanup_mmap;</code>（这个很简单：已经设置了<code>pgdir</code>和<code>mm</code>了，因此如果失败需要清理；而且周围都是跳转到这里）</li>
<li><code>USTACKTOP - USTACKSIZE</code>（这段大概是映射用户栈空间，不过我并不是很明白）</li>
<li><code>argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</code>（得到当前的参数的长度）</li>
<li><code>argc</code>（把argc放到栈顶；之所以是栈顶，是因为gcc是从右向左压栈的）</li>
</ol>
<hr>
<p>这种默写代码的题目实在是无聊死了。</p>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p>完成加载后会从内核态回到用户态，请补全此时的用户栈图示。（假定为写入部分全部初始化为0，注意使用小尾端）</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>(3a)</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>(3b)</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>(3c)</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>(3d)</td>
</tr>
</tbody>
</table>
<p>此时并不会直接进入main函数，而是执行以下代码，请简述其作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//////// user/libs/initcode.S //////////</span><br><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line"></span><br><span class="line">    movl (%esp), %ebx</span><br><span class="line">    lea 0x4(%esp), %ecx</span><br><span class="line"></span><br><span class="line">    subl $0x20, %esp</span><br><span class="line"></span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line"></span><br><span class="line">    call umain</span><br><span class="line">1: jmp 1b</span><br><span class="line"></span><br><span class="line">////////// user/libs/umain.c ////////////</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;file.h&gt;</span><br><span class="line">#include &lt;stat.h&gt;</span><br><span class="line">int main(int argc, char *argv[]);</span><br><span class="line">static int</span><br><span class="line">initfd(int fd2, const char *path, uint32_t open_flags) &#123;</span><br><span class="line">    int fd1, ret;</span><br><span class="line">    if ((fd1 = open(path, open_flags)) &lt; 0) &#123;</span><br><span class="line">        return fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fd1 != fd2) &#123;</span><br><span class="line">        close(fd2);</span><br><span class="line">        ret = dup2(fd1, fd2);</span><br><span class="line">        close(fd1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char *argv[]) &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if ((fd = initfd(0, &quot;stdin:&quot;, O_RDONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdin&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd = initfd(1, &quot;stdout:&quot;, O_WRONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdout&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = main(argc, argv);</span><br><span class="line">    exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<!--
恕我直言，我一开始不知道这道题在说什么。大概调用用户程序`args`的时候会有两个参数：`int argc`和`char** argv`，其中`argc = 2`，`argv = ['args', '1']`。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述内容执行完之后，得到<code>argv_size = 6</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">	uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">	argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argc;</span><br></pre></td></tr></table></figure>
<p>然后学长答案是这样：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>fd ff ff ff</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>f8 ff ff ff</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>02 00 00 00</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>00 00 00 00</td>
</tr>
</tbody>
</table>
<p>恕我直言，我也看不懂。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢tsz和xzh同学关于此题的讨论）</p>
<p>不妨把填充栈帧的代码段拿出来细看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在栈中预留函数参数的位置</span><br><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">// 在栈中预留函数参数指针的位置</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    // 从低地址到高地址填各参数指针，顺便把参数内容拷进去</span><br><span class="line">    uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">    // argv_size += 长度</span><br><span class="line">    argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把argc放入栈中</span><br><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argv;</span><br></pre></td></tr></table></figure>
<p>事实上，这段代码的目的，就是从栈底到栈顶，依次存参数内容（所有参数拼起来）、各参数的指针（<code>char **argv</code>）和argc存进去。实际上，被调用的进程<code>args</code>有两个实际参数：进程名<code>&quot;argc&quot;</code>和参数<code>&quot;1&quot;</code>（注意这两者都是字符串）。于是结果变成了这样：</p>
<ul>
<li>参数<code>&quot;1\0&quot;</code>存在<code>0xaffffffd</code>开始的2个字节中</li>
<li>参数<code>&quot;args\0&quot;</code>存在<code>0xaffffff8</code>开始的5个字节中</li>
<li>参数<code>&quot;1\0&quot;</code>所在的地址<code>0xaffffffd</code>存在<code>0xaffffff4</code>开始的4个字节中（注意大小端）</li>
<li>参数<code>&quot;args\0&quot;</code>所在的地址<code>0xaffffff8</code>存在<code>0xaffffff0</code>开始的4个字节中（注意大小端）</li>
<li><code>argc</code>存放在<code>0xafffffec</code>开始的4个字节中（注意大小端）</li>
</ul>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0xb0000000</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>0xaffffffc</code></td>
<td><code>00 31 00 00</code></td>
<td>字符串&quot;1&quot;（和&quot;args&quot;的<code>\0</code>）</td>
</tr>
<tr>
<td><code>0xaffffff8</code></td>
<td><code>61 72 67 73</code></td>
<td>字符串&quot;args&quot;</td>
</tr>
<tr>
<td><code>0xaffffff4</code></td>
<td><code>fd ff ff af</code></td>
<td>&quot;1&quot;的地址</td>
</tr>
<tr>
<td><code>0xaffffff0</code></td>
<td><code>f8 ff ff af</code></td>
<td>&quot;args&quot;的地址</td>
</tr>
<tr>
<td><code>0xafffffec</code></td>
<td><code>02 00 00 00</code></td>
<td><code>argv = 2</code></td>
</tr>
<tr>
<td><code>0xafffffe8</code></td>
<td><code>00 00 00 00</code></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>后面代码的作用据说是为umain函数压入argc和argv，调整esp，打开stdin/stdout，然后调用main。总之，打开stdin/stdout这个部分我好像看懂了；压入argc和argv的本质就是利用gcc调用了函数。</p>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> （4）</h3>
<p>虽然main函数以<code>return 0;</code>结束，但此后程序仍在用户态，经过（<strong>4a</strong>）进入内核态，参考<code>do_exit</code>代码，其主要完成了页表和文件描述符的释放、设置进程状态和返回值、唤醒等待中的父进程、（<strong>4b</strong>）。（<code>while</code>循环部分）</p>
<p><code>do_exit</code>中该进程占用的内存并未完全释放，例如（<strong>4c</strong>），它们将在（<strong>4d</strong>）中被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_exit(int error_code) &#123;</span><br><span class="line">	if (current == idleproc) &#123;</span><br><span class="line">    	panic(&quot;idleproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (current == initproc) &#123;</span><br><span class="line">		panic(&quot;initproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">	if (mm != NULL) &#123;</span><br><span class="line">		lcr3(boot_cr3);</span><br><span class="line">		if (mm_count_dec(mm) == 0) &#123;</span><br><span class="line">			exit_mmap(mm);</span><br><span class="line">			put_pgdir(mm);</span><br><span class="line">			mm_destroy(mm);</span><br><span class="line">		&#125;</span><br><span class="line">		current-&gt;mm = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	put_fs(current); //for LAB8</span><br><span class="line">	current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">	current-&gt;exit_code = error_code;</span><br><span class="line"></span><br><span class="line">	bool intr_flag;</span><br><span class="line">	struct proc_struct *proc;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">		proc = current-&gt;parent;</span><br><span class="line">		if (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">			wakeup_proc(proc);</span><br><span class="line">		&#125;</span><br><span class="line">		while (current-&gt;cptr != NULL) &#123;</span><br><span class="line">			proc = current-&gt;cptr;</span><br><span class="line">			current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">			proc-&gt;yptr = NULL;</span><br><span class="line">			if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) &#123;</span><br><span class="line">				initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proc-&gt;parent = initproc;</span><br><span class="line">			initproc-&gt;cptr = proc;</span><br><span class="line">				if (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">					if (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">						wakeup_proc(initproc);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">	panic(&quot;do_exit will not return!! %d.\n&quot;, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ol>
<li><code>exit</code>系统调用</li>
<li>把子进程逐个放入initproc的子进程中，如果发现子进程已经为僵尸状态且initproc进入WT_CHILD状态，则唤醒initproc回收子进程</li>
<li>进程控制块</li>
<li>父进程的<code>do_wait</code>（或者说被唤醒的执行了wait或wait_pid的父进程）</li>
</ol>
<p>这道题反而比较简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent:           proc-&gt;parent  (proc is children)</span><br><span class="line">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="line">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="line">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br></pre></td></tr></table></figure>
<h2 id="七-磁盘调度15分"><a class="markdownIt-Anchor" href="#七-磁盘调度15分"></a> 七 磁盘调度（15分）</h2>
<p>一磁盘逆时针旋转，磁盘有3个磁道和一个磁头，每个磁道有12个扇区。最外侧磁道0包含扇区0<sub>11，中间侧磁道1包含扇区12</sub>23，最内侧磁道包含扇区24~35。如下图所示，可以看到磁头初始位置在外侧磁道的扇区6的中间位置，扇区10与扇区6在一个磁道上。</p>
<p><img src="simple-disk.png" alt="磁盘示意图" /></p>
<p>完成一次磁盘扇区的访问请求时间包括：</p>
<ul>
<li>寻道时间（seek time）</li>
<li>旋转时间（rotational time）</li>
<li>传输时间（transfer time）</li>
</ul>
<p>如，ucore发出访问请求序列为[‘10’]，即只有一次对扇区10的访问请求，则磁盘花费的访问请求时间如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">TOTALS  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br></pre></td></tr></table></figure>
<p>表示寻道时间是0个时间单位，旋转时间是105个时间单位，总共的磁盘访问请求的时间是135。注意，相邻磁头移动一个磁道的时间是40个时间单位；从扇区6到扇区9，旋转了90度；而为了进行传输，需要从扇区9<sub>10的中间位置开始，从扇区10</sub>11的中间位置结束。所以需要再旋转15度，即旋转了105度，而每旋转1度花费1个时间单位，所以旋转花费了105个实践单位。</p>
<ol>
<li>若采用FIFO磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
<li>若采用SSFT磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
</ol>
<hr />
<!--
FIFO策略：
* 10
  * 磁道不变
  * 旋转：105
  * 传输：30
* 12
  * 寻道：40
  * 旋转：60
  * 传输：30
* 24
  * 寻道：40
  * 旋转：360
  * 传输：30
* 1
  * 寻道：80
  * 旋转：30
  * 传输：30

以及恕我无法理解学长答案。他给出的计算结果是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>SSFT策略：</p>
<ul>
<li>10
<ul>
<li>磁道不变</li>
<li>旋转：105</li>
<li>传输：30</li>
</ul>
</li>
<li>1
<ul>
<li>磁道不变</li>
<li>旋转：90</li>
<li>传输：30</li>
</ul>
</li>
<li>12
<ul>
<li>寻道：40</li>
<li>旋转：330</li>
<li>传输：30</li>
</ul>
</li>
<li>24
<ul>
<li>寻道：40</li>
<li>旋转：360</li>
<li>传输：30</li>
</ul>
</li>
</ul>
<p>经过查证，我发现这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。但是我认为程序说明自相矛盾，无法理解。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢zp、wj等人关于这道题的讨论）</p>
<p>这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。事实上，需要注意的一点是：磁盘在旋转过程中可以进行寻道。</p>
<p>FIFO策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td><img src="disk-fifo-1.png" alt="" /></td>
</tr>
<tr>
<td>12</td>
<td>30</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>320</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>30</td>
<td>80</td>
<td>30</td>
<td>110</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>SSFT策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>0</td>
<td>30</td>
<td>90</td>
<td>-</td>
</tr>
<tr>
<td>12</td>
<td>300</td>
<td>40</td>
<td>30</td>
<td>330</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>360</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>这个答案仍然和学长给出的不尽相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>可能之后有时间的时候还需要进行分析吧。</p>
-->
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2017-final-exam-analysis/">
              
                  《操作系统》2017年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-22
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring/FinalExam" target="_blank" rel="noopener">2017年春季学期操作系统课期末考试</a>。</p>
<h2 id="填空题30分"><a class="markdownIt-Anchor" href="#填空题30分"></a> 填空题（30分）</h2>
<p>同学们认真完成了从lab0～lab8的所有实验，在实验实践过程中了解和学到了很多知识。下面是他们从最开始到近期的实验心得，请补充完整。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3>
<p>lab0: 小强发现完成实验需要在Linux下操作很多命令行工具，于是他认真学习了 lab0中的知识，了解到Linux中在命令行模式下可以通过执行命令(<strong>1.1</strong>)来显示当前目录的文件，如果编写的程序有语法错误，编译器(<strong>1.2</strong>)会报错，根据错误信息，可以修改程序，并可以通过硬件模拟器工具(<strong>1.3</strong>)来执行 ucore 操作系统。</p>
<ol>
<li>ls</li>
<li>gcc</li>
<li>qemu</li>
</ol>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3>
<p>lab1: 小晔在bootloader的代码中添加了一条打印语句，但发现编译生成lab项目出错，原来在ucore中只要bootloader的执行代码段+数据段的长度超过了(<strong>2.1</strong>)字节，就无法形成合法有效的bootloader。开始写实验报告时，本来准备提交MS Word文档格式的实验报告，但仔细看过实验报告的提交要求，原来实验指导书中明确要求同学用(<strong>2.2</strong>)文档格式来提交实验报告，小晔之前没学过这个文档格式，不过上网一查，花很短时间就掌握了编写方法，迅速完成了lab1。</p>
<ol>
<li><del>446</del>510</li>
<li>Markdown</li>
</ol>
<hr>
<p>根据<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95</a>，主引导扇区中代码区的大小最多为446字节。</p>
<p>2018.5.24 UPD：经过tsz同学的提醒，我查证了一下<code>lab1/tools/sign.c</code>（用于生成磁盘主引导扇区的代码），发现里面是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line"><span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(ifp);</span><br><span class="line">buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br></pre></td></tr></table></figure>
<p>所以虽然维基说的没问题，但是ucore没有管什么“标准MBR分区表规划”，直接把<code>0x55AA</code>之外的510字节全用上了。</p>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3>
<p>lab2: 小晖需要了解x86的内存大小与布局，页机制，页表结构等。硬件模拟器提供了 128MB的内存，并设定一个页目录项（PDE）占用(<strong>3.1</strong>)个Byte，一个页表项（PTE）占用(<strong>3.2</strong>)个 Byte。在lab2中可通过(<strong>3.3</strong>)和(<strong>3.4</strong>)两种方式获取系统内存大小，并且由于空闲的RAM空间不连续，所以bootloader简化处理，从物理内存地址(<strong>3.5</strong>)起始填充ucore os kernel的代码段和数据段。在ucore建立完页表并进入页模式后，ucore代码段的起始物理地址对应的虚拟地址为(<strong>3.6</strong>)。</p>
<ol>
<li>4</li>
<li>4</li>
<li>BIOS中断调用</li>
<li>直接探测</li>
<li>0x00100000</li>
<li>0xC0100000</li>
</ol>
<hr>
<p>这块不愧是令人比较困惑。我可能需要复习一下ucore的内存映射方式了。</p>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3>
<p>lab3: 小彤发现ucore在完成页机制建立后，内核某内存单元的虚拟地址va为 0xC2345678，且此时硬件模拟器模拟的的cr3寄存器的值为0x221000，则此va对应的页目录表的起始物理地址是(<strong>4.1</strong>)，此va对应的PDE的物理地址是(<strong>4.2</strong>)。如果一个页（4KB/页）被置换到了硬盘某8个连续扇区（0.5KB/扇区），该页对应的页表项（PTE）的最低位–present 位应该为(<strong>4.3</strong>) ，表示虚实地址映射关系不存在，而原来用来表示页帧号的高(<strong>4.4</strong>)位，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。</p>
<ol>
<li>0x00221000</li>
<li>0x00221C20</li>
<li>0</li>
<li>20</li>
</ol>
<hr>
<p>该va对应的页号和偏移量：</p>
<ul>
<li>0xC2345678 = b11000010001101000101011001111000</li>
<li>页目录号 = b1100001000 = 0x308</li>
<li>页表号 = b1101000101 = 0x345</li>
<li>偏移量 = b011001111000 = 0x678</li>
</ul>
<p>PDE地址 = CR3 + 4*页目录号 = 0x00221000 + 0xC20 = 0x00221C20</p>
<h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3>
<p>lab4: 小颖在理解进程管理中，仔细分析了ucore源码中的进程控制块数据结构(<strong>5.1</strong>)，且其中的关键域（也称field，字段）数据结构(<strong>5.2</strong>)用于保存被中断打断的运行现场，关键域数据结构(<strong>5.3</strong>)用于进行进程/线程上下文切换的保存与回复。</p>
<ol>
<li><code>proc_struct</code></li>
<li><code>trap_frame</code></li>
<li><code>context</code></li>
</ol>
<h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h3>
<p>lab5: 小辰对用户进程的创建有了更深入的了解：用户进程在用户态下执行时，CS 段寄存器最低第两位的值为(<strong>6.1</strong>)。当ucore os kernel建立完毕第一个用户进程的执行环境后，通过执行x86机器指令(<strong>6.2</strong>)后，将从内核态切换到用户态，且将从用户进程的第一条指令处继续执行。当用户进程执行sys_exit系统调用后，ucore会回收当前进程所占的大部分资源，并把当前进程的状态设置为(<strong>6.3</strong>)。</p>
<ol>
<li>3</li>
<li>IRET</li>
<li>ZOMBIE</li>
</ol>
<hr>
<p>用户态下，CS段的RPL的值应该为3.</p>
<h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h3>
<p>lab6: 小磊通过阅读代码，了解了ucore的调度框架和RR调度算法等，体会到调度本质上体现了对(<strong>7.1</strong>)资源的抢占，操作系统通过(<strong>7.2</strong>)来避免用户态进程长期运行，并获得控制权。</p>
<ol>
<li>处理机执行能力（时间片？）</li>
<li>时钟中断</li>
</ol>
<hr>
<p>之所以1的回答是“处理机执行能力”，主要是因为第15讲里说，“处理机调度是管理处理机执行能力的资源”。我觉得答CPU之类的也可以。</p>
<h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h3>
<p>lab7: 小航发现课本中阐述的同步互斥原理对实现细节简化了很多。在ucore中，通过利用x86机器指令(<strong>8.1</strong>)简洁地实现了入临界区代码，通过利用x86指令(<strong>8.2</strong>)简洁地实现了出临界区代码。通过分析ucore中管程的数据结构，可知道ucore中的管程机制是基于(<strong>8.3</strong>)机制和(<strong>8.4</strong>)机制来实现的。</p>
<ol>
<li>CLI</li>
<li>STI</li>
<li>信号量</li>
<li>等待队列</li>
</ol>
<hr>
<p>有时候分不清楚CLI和STI。事实上，CLI的意思是“Clean IF”，即将IF置零，屏蔽中断；STI的意思是“Set IF”，即将IF置1，不屏蔽中断。姑且这样记一下吧。</p>
<h3 id="9"><a class="markdownIt-Anchor" href="#9"></a> 9</h3>
<p>lab8: 小行了解到ucore中的文件系统架构包含四类主要的数据结构， (<strong>9.1</strong>)：它主要从文件系统的全局角度描述特定文件系统的全局信息。 (<strong>9.2</strong>)：它主要从文件系统中单个文件的角度描述了文件的各种属性和数据所在位置。 (<strong>9.3</strong>)：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。 (<strong>9.4</strong>)： 它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。</p>
<ol>
<li>超级块（SuperBlock）</li>
<li>索引节点（inode）</li>
<li>目录项（dentry）</li>
<li>文件（file）</li>
</ol>
<hr>
<p>Lab8中的各种结构好多，完全不知道该回答什么啊。</p>
<p>2018.5.24 UPD：今天tsz同学提醒我，这个问题是实验指导书中的原话<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<blockquote>
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构，它们分别是：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从文件系统的单个文件的角度描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。它的作用范围是整个OS空间。</li>
<li>文件（file）：它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
</blockquote>
<h2 id="问答题70分"><a class="markdownIt-Anchor" href="#问答题70分"></a> 问答题（70分）</h2>
<h3 id="10-同步互斥10分"><a class="markdownIt-Anchor" href="#10-同步互斥10分"></a> 10. 同步互斥（10分）</h3>
<p>下面列出的n个线程互斥机制的伪代码实现有误，请指出错误处，给出错误原因分析，描述错误会带来的后果（即给出反例：无法正确执行n线程有效互斥运行行为的执行序列）。最后请修正错误，使得伪代码正确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = <span class="number">0</span>;</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<hr>
<p>这道题和<a href="/post/os-mooc-2016-final-exam-analysis">2016年期末</a>的26.2题几乎一模一样，唯一的区别是此处初始化时将<code>num[j]</code>初始化为<code>j</code>，而不是<code>0</code>。这一点显然违背了“空闲则入”的原则：假如线程<code>n-1</code>想要进入临界区，它必须等待编号比它小的线程全部进入过临界区，这可能会导致饥饿，所以还是应该初始化为<code>0</code>。因此，在线程i执行ENTRY PROTOCOL之前，<code>num[i]</code>必然为0。</p>
<p>在我的理解中，共享数组<code>num[n]</code>有两个含义：</p>
<ul>
<li><code>num[i] &gt; 0</code>表示线程i正在等待或已经进入临界区；<code>num[i] = 0</code>表示线程i离开了临界区且并没有等待进入临界区</li>
<li><code>num[i] &gt; 0</code>时，表示线程i等待的优先级，数字越大，优先级越低</li>
</ul>
<p>基于以上的讨论，我认为，<code>num</code>数组中非0的值必须是互不相同的。从ENTRY PROTOCOL的实现可以看出，如果<code>num[i] = MAX(num[0], ..., num[n-1]) + 1</code>这一操作是原子的，则上述结论显然；如果这一操作不是原子的，则可能会出现两个线程i和j的优先级相同的情况。不妨设i&lt;j，且其他线程的<code>num</code>均为0。假如线程i在<code>num[i]</code>没有完成赋值之前被打断，切换到线程j，则j会发现其他线程的<code>num</code>均为0，于是进入临界区。之后切换回线程i，i检查时虽然发现<code>num[i] == num[j]</code>，但由于<code>i &lt; j</code>，于是也进入临界区，破坏了“忙则等待”要求。</p>
<p>假如能够保证<code>num[i] = MAX(num[0], ..., num[n-1]) + 1</code>这一操作是原子的，则上述实现是正确的，且可以删去<code>(num[j] == num[i]) &amp;&amp; (j &lt; i)</code>这一判断条件。在检查条件过程中被打断并不会影响算法的正确性，因为，即使已经被检查过的线程的优先级发生了变化，它也只可能变成0（它不再进入临界区，没有影响）或者优先级比当前线程变得更大（它退出临界区之后又想重新进入，需要取max），不需要重新进行等待。</p>
<p>但是现在的问题是怎么实现取max操作的原子性。如果直接加个互斥锁，不免太过智熄。（那我们还实现软件方法的N线程互斥干啥……）那就直接加个共享变量作为自旋锁好了，而且需要保证赋值过程是原子的。……虽然这样也完全没有意义，难道要直接改成Eisenberg &amp; McGuire算法么……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared <span class="keyword">int</span> num[n];</span><br><span class="line">    shared <span class="keyword">bool</span> choose[n];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;  <span class="comment">// do this atomically</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = <span class="number">0</span>;</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<p>2018.5.24 UPD：tsz同学给出了一种想法，我还没有仔细思考过它的正确性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;  <span class="comment">// do this atomically</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i)) || flag[j] &amp;&amp; (j &lt; i)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-管程10分"><a class="markdownIt-Anchor" href="#11-管程10分"></a> 11. 管程（10分）</h3>
<p>下面是一类管程机制的实现伪代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENTATION:</span><br><span class="line">monitor mt &#123;</span><br><span class="line">    -----variable in monitor-----------</span><br><span class="line">    semaphore mutex;</span><br><span class="line">    semaphore next;</span><br><span class="line">    <span class="keyword">int</span> next_count;</span><br><span class="line">    condvar &#123;<span class="keyword">int</span> count, sempahore sem&#125; cv[N];</span><br><span class="line">    other shared variables in mt;</span><br><span class="line">    ----condvar wait implementation----</span><br><span class="line">    cond_wait (cv) &#123;</span><br><span class="line">        cv.count ++;</span><br><span class="line">        <span class="keyword">if</span>(mt.next_count&gt;<span class="number">0</span>)</span><br><span class="line">            V(mt.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(mt.mutex);</span><br><span class="line">        P(cv.sem);</span><br><span class="line">        cv.count --;</span><br><span class="line">    &#125;</span><br><span class="line">    ----condvar signal implementation----</span><br><span class="line">    cond_signal(cv) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            mt.next_count ++;</span><br><span class="line">            V(cv.sem);</span><br><span class="line">            P(mt.next);</span><br><span class="line">            mt.next_count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ----routine examples in monitor----</span><br><span class="line">    Routines_in_mt () &#123;</span><br><span class="line">        P(mt.mutex);</span><br><span class="line">        real bodies of routines, may access shared variables, call cond_wait OR cond_signal</span><br><span class="line">        <span class="keyword">if</span>(next_count&gt;<span class="number">0</span>)</span><br><span class="line">        V(mt.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        V(mt.mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述伪码中，如果有3个线程a,b,c需要访问管程，并会使用管程中的2个条件变量 cv[0],cv[1]。请问cv[i]-&gt;count含义是什么？cv[i]-&gt;count是否可能&lt;0, 是否可能&gt;1？请说明原因，并给出相应的3个线程同步互斥执行实例和简要解释。请问 mt-&gt;next_count含义是什么？mt-&gt;next_count是否可能&lt;0, 是否可能&gt;1？请说明原因，并给出相应的3个线程同步互斥执行过程实例和简要解释。</p>
<hr>
<p>这道题和<a href="/post/os-mooc-2016-final-exam-analysis">2016年期末</a>的27题一模一样，连笔误都一样，不解释了。</p>
<h3 id="12-理发师问题20分"><a class="markdownIt-Anchor" href="#12-理发师问题20分"></a> 12. 理发师问题（20分）</h3>
<p>理发店里有m位理发师、m把理发椅和n把供等候理发的顾客坐的椅子。理发师为一位顾客理完发后，查看是否有顾客等待，如有则唤醒一位为其理发；如果没有顾客，理发师便在理发椅上睡觉。一个新顾客到来时，首先查看理发师在干什么，如果理发师在理发椅上睡觉，他必须叫醒理发师，然后理发师理发，顾客被理发；如果理发师正在理发，则新顾客会在有空椅子可坐时坐下来等待，否则就会离开。请用信号量机制实现理发师问题的正确且高效的同步与互斥活动：请说明所定义的信号量的含义和初始值，描述需要进行互斥处理的各种行为，描述需要进行同步处理的各种行为；要求用类C语言的伪代码实现，并给出必要的简明代码注释。</p>
<hr>
<p>感觉这个的初步实现到处都是，比如<a href="http://whatbeg.com/2017/03/06/semaphore.html#%E9%97%AE%E9%A2%988%EF%BC%9A%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">http://whatbeg.com/2017/03/06/semaphore.html#问题8：理发师问题</a>。但是我现在都要困死了，实在思考不了这种高思维含量的东西。</p>
<p>2018.5.24 UPD：今天tsz同学给出了一种做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waitCnt &gt; n)</span><br><span class="line">        <span class="keyword">return</span> FAIL;</span><br><span class="line">    waitLock.P();</span><br><span class="line">    waitCnt++;</span><br><span class="line">    waitLock.V();</span><br><span class="line">    waitList.P();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// haircut</span></span><br><span class="line"></span><br><span class="line">    waitLock.P();</span><br><span class="line">    waitCnt--;</span><br><span class="line">    waitLock.V();</span><br><span class="line">    <span class="keyword">return</span> SUCCEED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Barber</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Barber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (waitCnt == <span class="number">0</span>);</span><br><span class="line">        waitList.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我还没有仔细想过这个做法的正确性。</p>
<h3 id="13-spn算法8分"><a class="markdownIt-Anchor" href="#13-spn算法8分"></a> 13. SPN算法（8分）</h3>
<p>请给出平均周转时间的定义，请给出短进程优先算法的描述，请证明：短进程优先算法具有最小平均周转时间。</p>
<hr>
<ul>
<li>周转时间：进程从初始化到结束（包括等待）的总时间</li>
<li>平均周转时间：所有进程周转时间的平均数</li>
<li>短进程优先（SPN）算法：总是选择就绪队列中执行时间最短的进程占用CPU进入运行状态</li>
</ul>
<p>证明：<br>
假设就绪队列中共有N个进程，它们的执行时间分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">t_1, t_2, ..., t_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><msub><mi>t</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">t_1 \leq t_2 \leq ... \leq t_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则SPN算法的总周转时间为</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>T</mi><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><msub><mi>t</mi><mn>3</mn></msub><mo>)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub><mo>)</mo><mo>=</mo><mi>N</mi><mo>∗</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T = t_1 + (t_1 + t_2) + (t_1 + t_2 + t_3) + ... + (t_1 + t_2 + ... + t_N) = N * t_1 + (N-1) * t_2 + ... + t_N
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<p>假设我们交换了第i和j（i&lt;j）个进程的执行顺序，则此时，总周转时间会变为</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>=</mo><mi>N</mi><mo>∗</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T&#x27; = N * t_1 + (N-1) * t_2 + ... + (N-i+1) * t_j + ... + (N-j+1) * t_i + t_N
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>−</mo><mi>T</mi><mo>=</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>=</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>)</mo><mo>∗</mo><mo>(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mi>j</mi></msub><mo>)</mo><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T&#x27; - T = (N-i+1) * t_j + (N-j+1) * t_i - (N-i+1) * t_i - (N-j+1) * t_j = (i-j) * (t_i - t_j) &gt;= 0
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">&gt;</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<p>由于任何进程执行顺序都可以通过对顺序排列的进程进行若干次交换而得到，上述证明表明，任何其他执行顺序得到的平均周转时间都不可能比SPN算法更优。因此，SPN算法具有最小平均周转时间。</p>
<h3 id="14-lfu算法14分"><a class="markdownIt-Anchor" href="#14-lfu算法14分"></a> 14. LFU算法（14分）</h3>
<p>LFU是最近最不常用页面置换算法(Least Frequently Used)，小白听到两个LFU定义的说法，有些糊涂：</p>
<ol>
<li>采用LFU算法的OS在碰到进程访问的物理内存不够时，换出进程执行期内被访问次数最少的内存页，当此页被换出后，其访问次数n会被记录下来，当此页被再次访问并被换入时，此页的访问次数为n+1。</li>
<li>采用LFU算法的OS在碰到进程访问的物理内存不够时，换出进程执行期内被访问次数最少的内存页，当此页被换出后，其访问次数清零，当此页被再次访问并被换入时，此页的访问次数为1。</li>
</ol>
<p>请问你认为那种LFU的定义是正确的？请分别回答第一种/第二种LFU定义是否有Belady 异常现象。如没有，请给出证明，如有，请给出会引起Belady异常现象的的页数/页帧数设置以及访问序列。</p>
<hr>
<p>呃，我不会啊……但我认为做法1显然不太可取。LFU算法比较严重的一个问题是计数器的劣化（这个名字是我随便起的）：之前被大量访问，但以后不再被使用的页不容易被换出。为了解决这个问题，计数器可以定期右移之类的。现在页计数器根本不会减小，怕不是要出事……不过被换出的页大概被访问次数是很少的，所以我也不知道1有什么用。</p>
<p>2大概有Belady现象。1不知道。看来需要仔细研究一下Piazza上给出的例子了。</p>
<p>2018.5.24 UPD：<br>
今天zp同学提醒我，<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1031" target="_blank" rel="noopener">Piazza</a>上有一个帖子讨论了这一内容。我们一般说的LFU的定义是第2种，而非第1种；该帖子指出，第1种定义下LFU不会出现Belady问题（虽然没有给出证明），而第2种定义下LFU会出现Belady问题，并举出了例子。</p>
<p>令访问序列为[0 0 1 1 1 2 2 0 0 2 2 3 1 3 1 3 1 3 1 3 1 3 1 … （之后无限循环3 1 3 1）]。在有2个物理页帧的情况下，访问过程是这样的（括号里是访问计数）：</p>
<table>
<thead>
<tr>
<th>访存</th>
<th>物理页a</th>
<th>物理页b</th>
<th>缺页</th>
<th>换出</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0(1)</td>
<td>-</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(1)</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2(1)</td>
<td>1(3)</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(1)</td>
<td>1(3)</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2(1)</td>
<td>1(3)</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(1)</td>
<td>1(3)</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3(1)</td>
<td>1(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(2)</td>
<td>1(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>3(2)</td>
<td>1(5)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(3)</td>
<td>1(5)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>3(3)</td>
<td>1(6)</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>可以看出，一共只会缺页6次，在之后的循环过程中不会缺页。</p>
<p>但是，如果物理页帧数量增加到3，访问过程会变成这样：</p>
<table>
<thead>
<tr>
<th>访存</th>
<th>物理页a</th>
<th>物理页b</th>
<th>物理页c</th>
<th>缺页</th>
<th>换出</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0(1)</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(1)</td>
<td>-</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(2)</td>
<td>1(3)</td>
<td>2(1)</td>
<td>2</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(2)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(3)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>可以看出，现在已经缺页9次了，而且之后每访问一次都会发生缺页。</p>
<p>上述讨论可以说明一般的LFU算法有Belady问题。那么为什么修改过的（有记忆的）LFU算法可以没有Belady问题呢？<a href="https://stackoverflow.com/questions/21289990/does-the-lfu-page-reclamation-algorithm-suffer-from-beladys-anomaly" target="_blank" rel="noopener">stackoverflow</a>上是这么说的：</p>
<blockquote>
<p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-358.pdf" target="_blank" rel="noopener">http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-358.pdf</a> section 1.3 defines the stack algorithm and finishes by working through an example of this for LFU. Basically you can maintain a stack as you follow through a trace of memory fetches such that the top i entries of the stack are the entries that will be held in memory if you have capacity for i entries in your memory. Since you can maintain such a stack a larger memory must always hold all of the entries kept in core for any smaller memory and so Belady’s anomaly is not possible.<br>
Of course this assumes an exact implementation of LFU with counters of infinite capacity.</p>
</blockquote>
<p>上面的内容大概是说，修改过的LFU算法实际上相当于维护了一个很大的访问次数栈，栈中的页按访问次数排序，顶端的N个页驻留在内存中。因此，它本质上是一种栈算法，所以不存在Belady问题。具体证明我现在没时间去看了，欢迎大家自己去看论文。</p>
<h3 id="15-小明文件系统8分"><a class="markdownIt-Anchor" href="#15-小明文件系统8分"></a> 15. 小明文件系统（8分）</h3>
<p>小明为更好理解lab8，设计了一个简化文件系统Xiao Miang File System, 简称 xmfs。</p>
<p><strong>xmfs的系统调用接口包括：</strong></p>
<ul>
<li>mkdir() - 创建一个新目录</li>
<li>creat() - 创建一个空文件</li>
<li>open(), write(), close() - 打开文件，写文件，关闭文件</li>
<li>link() - 对文件创建一个硬链接（ hard link）</li>
<li>unlink() - 对文件取消一个硬链接 (如果文件的链接数为0，则删除文件）</li>
<li><strong>注意</strong>：通过 write()对文件写一个数据buffer时，常规文件的最大size是一个 data block，所以第二次写（写文件的语义是在上次写的位置后再写一个data block）会报错（文件大小满了）。如果data block 也满了，也会报错。</li>
</ul>
<p><strong>xmfs在硬盘上的总体组织结构如下：</strong></p>
<ul>
<li>superblock：记录可用inode数量，可用data block数量</li>
<li>inode bitmap：已用/空闲inode的分配图（基于bitmap）</li>
<li>inodes：inode的存储区域</li>
<li>data bitmap：data block的分配图（基于bitmap）</li>
<li>data：data block的存储区域</li>
</ul>
<p><strong>xmfs的关键数据结构–inode数据结构如下：</strong></p>
<ul>
<li>inode：包含3个fields（file type，data block addr of file content，reference count）,用list表示：</li>
<li>file type: f -&gt; 常规文件： regular file, d -&gt; 目录文件： directory</li>
<li>data block addr of file content: -1 -&gt; file is empty</li>
<li>reference count: file/directory 的引用计数，注意directory的引用计数是指在此目录中的inode的个数</li>
<li><strong>注意</strong>：比如，刚创建的一个空文件inode：[f a:-1 r:1]，一个有1个硬链接的文件inode：[f a:10 r:2]</li>
</ul>
<p><strong>xmfs的关键数据结构–数据块（data block）结构如下：</strong></p>
<ul>
<li>一般文件的内容表示：只是包含单个字符的 list，即占一个 data block，比如[‘a’], [‘b’] …</li>
<li>目录的内容表示：多个两元组（name, inode_number）形成的list，比如，根目录 [(.,0) (…,0)]，或者包含了一个’f’文件的根目录[(.,0) (…,0) (f,1)]。</li>
<li><strong>注意</strong>：一个目录的目录项的个数是有限的。block.maxUsed = 32</li>
<li><strong>注意</strong>：data block 的个数是有限的,为fs.numData</li>
<li><strong>注意</strong>：inode 的个数是有限的,为fs.numInodes</li>
</ul>
<p><strong>完整xmfs文件系统的参考实例：</strong></p>
<p>fs.ibitmap: inode bitmap 11110000<br>
fs.inodes: [d a:0 r:5] [f a:1 r:1] [f a:-1 r:1] [d a:2 r:2] [] …<br>
fs.dbitmap: data bitmap 11100000<br>
fs.data: [(.,0) (…,0) (y,1) (z,2) (x,3)] [u] [(.,3) (…,0)] [] …</p>
<p><strong>对上述xmfs参考实例的解释</strong>：有8个inode空间,8个data blocks.其中，根目录包含5个目录项，“.”，“…”，“y”，“z”，“x”。而“y”是常规文件,并有文件内容，包含一个data block，文件内容为“u”。“z”是一个空的常规文件。“x”是一个目录文件，是空目录。</p>
<p><strong>如果xmfs初始状态为：</strong><br>
<em>inode bitmap 10000000</em><br>
inodes [d a:0 r:2] [] [] [] [] [] [] []<br>
data bitmap 10000000<br>
data [(.,0) (…,0)] [] [] [] [] [] [] []</p>
<p>在执行了系统调用mkdir(&quot;/t&quot;)后，<strong>xmfs的当前状态为：</strong><br>
<em>inode bitmap 11000000</em><br>
inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1)] [(.,1) (…,0)] [] [] [] [] [] []</p>
<p>请问接下来的4个状态变化所对应系统调用是什么？ 要求回答格式象上面“mkdir(&quot;/t&quot;)”一样。</p>
<p>（1）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:2] [f a:-1 r:1] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0)] [] [] [] [] [] []</p>
<p>（2）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:3] [f a:-1 r:2] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0) (c,2)] [] [] [] [] [] []</p>
<p>（3）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:3] [f a:2 r:2] [] [] [] [] []<br>
data bitmap 11100000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0) (c,2)] [o] [] [] [] [] []</p>
<p>（4）<br>
<em>inode bitmap 11110000</em><br>
inodes [d a:0 r:5] [d a:1 r:3] [f a:2 r:2] [d a:3 r:2] [] [] [] []<br>
data bitmap 11110000<br>
data [(.,0) (…,0) (t,1) (y,2) (v,3)] [(.,1) (…,0) (c,2)] [o] [(.,3) (…,0)] [] [] [] []</p>
<hr>
<ol>
<li>create(&quot;/y&quot;)</li>
<li>link(&quot;/y&quot;, “/t/c”)</li>
<li>fd=open(&quot;/y&quot;), write(fd), close(fd)</li>
<li>mkdir(&quot;/v&quot;)</li>
</ol>
<p>这道题的形式非常类似于<a href="/post/os-mooc-final-exam-analysis">MOOC上的期末试题</a>中的第20题。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://objectkuan.gitbooks.io/ucore-docs/lab8/lab8_3_1_ucore_fs_introduction.html" target="_blank" rel="noopener">uCore Lab Documents - ucore 文件系统总体介绍 - ucore文件系统总体结构</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-final-exam-analysis/">
              
                  《操作系统》MOOC期末考试题分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-20
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>以下内容来自学堂在线《操作系统》在线课程的期末考试。因为只有单选题，所以没有什么难的。</p>
<hr>
<ol>
<li>某基于动态分区存储管理的计算机系统，其主存容量为55MB（初始为空），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB，分配30MB，释放15MB，分配8MB，分配7MB，则此时主存中最大空闲分区的大小是（ ）</li>
</ol>
<ul>
<li>7MB</li>
<li><strong>8MB</strong></li>
<li>9MB</li>
<li>10MB</li>
</ul>
<p>分配过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|----------------55MB--------------------|</span><br><span class="line">|===15MB====|---------40MB---------------|</span><br><span class="line">|===15MB====|======30MB======|---10MB----|</span><br><span class="line">|---15MB----|======30MB======|---10MB----|</span><br><span class="line">|---15MB----|======30MB======|=8MB=|-2MB-|</span><br><span class="line">|=7MB=|-8MB-|======30MB======|=8MB=|-2MB-|</span><br></pre></td></tr></table></figure>
<p><strong>EXPLANATION</strong></p>
<p>下面是分配过程的表示。<br>
0： 55<br>
15： (15), 40<br>
30： (15), (30), 10<br>
~15: 15, (30), 10<br>
8: 15, (30), (8), 2<br>
7: (7), 8, (30), (8), 2</p>
<hr>
<ol start="2">
<li>在一个采用单地址方案（逻辑地址与物理地址是一一对应的）的分段存储系统中，内存地址长度为32位，其中段号占10位，则最大段长为（ ）</li>
</ol>
<ul>
<li>2^8字节</li>
<li>2^14字节</li>
<li><strong>2^22字节</strong></li>
<li>2^24字节</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>在段访问机制中，如果采用的是单地址方案，则段号的位数+段内偏移的位数=地址长度，所以段内偏移占了32 - 10 = 22 比特。</p>
<hr>
<ol start="3">
<li>某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2<sup>10字节，页表项大小为4字节，逻辑地址结构为“|一级页号|二级页号|页内偏移量|”，逻辑地址空间大小为2</sup>16页，则表示整个逻辑地址空间的一级页表中包含表项的个数至少为（ ）</li>
</ol>
<ul>
<li>64</li>
<li>128</li>
<li><strong>256</strong></li>
<li>512</li>
</ul>
<p>由于逻辑地址空间大小为2<sup>16页，页大小为2</sup>10字节，因此逻辑地址总长度为26，其中页内偏移量长度为10。我猜测一张页表最多占满一页，所以最多能够包含2<sup>10/4=2</sup>8=256个页表项。事实上，2<sup>8*2</sup>8恰好等于2^16（页），因此其实只有一种分配方法，就是一级页号长度=二级页号长度=8，每张页表都有256个页表项。</p>
<p><strong>EXPLANATION</strong></p>
<p>页大小为2<sup>10B，页表项大小为4B，一页可以存放2</sup>8个页表项，逻辑地址空间大小为2<sup>16页，需要2</sup>16个页表项，需要2<sup>16/2</sup>8 = 2^8 = 256个表项保存页表项。所以页目录表中包含的表项至少为256</p>
<hr>
<ol start="4">
<li>在CPU中具有TLB和高速缓存(CACHE)的分页式存储管理系统中时，每次CPU取指令或取操作数，至少要访问（）次主存</li>
</ol>
<ul>
<li><strong>0</strong></li>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<p>一般取指令或取操作数需要经过以下过程：</p>
<ul>
<li>查TLB
<ul>
<li>TLB miss
<ul>
<li>从CR3寄存器中读出一级页表基地址，在一级页表中查出二级页表基地址</li>
<li>在二级页表中查出页帧物理地址
<ul>
<li>如果该页在内存中则直接查到</li>
<li>否则发生Page Fault，将对应页换入，重新执行上述过程</li>
</ul>
</li>
</ul>
</li>
<li>TLB hit
<ul>
<li>直接得到虚拟地址对应的物理地址</li>
</ul>
</li>
</ul>
</li>
<li>从物理地址中读数据</li>
</ul>
<p>如果运气好的话，TLB hit，且对应的物理内存块缓存在cache中，则一次主存都不用访问。如果运气坏的话……我也想不起在ucore中最多会访问多少次主存了。</p>
<p><strong>EXPLANATION</strong></p>
<p>0次。因为CPU访问的页表项和要访问的内存单元可能会有缓存在TLB和cache中。</p>
<hr>
<ol start="5">
<li>对于下列3种操作：<br>
（1）整数除以0；<br>
（2）cos数学函数调用；<br>
（3）read系统调用；</li>
</ol>
<p>会导致用户进程从用户态切换到内核态的操作是</p>
<ul>
<li>1、2</li>
<li><strong>1、3</strong></li>
<li>2、3</li>
<li>1、2、3</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>函数调用并不会切换到内核态，而除零操作引发中断，中断和系统调用都会切换到内核态进行相应处理</p>
<hr>
<ol start="6">
<li>在缺页处理过程中，操作系统执行的操作可能是下列操作：<br>
（1）修改页表(page table)<br>
（2）磁盘I/O<br>
（3）分配页框（page frame）<br>
中的（ ）</li>
</ol>
<ul>
<li>仅1、2</li>
<li>仅2、3</li>
<li>仅1、3</li>
<li><strong>1、2、3</strong></li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>如果还有可分配给程序的内存，那么会分配新的页框，修改页表，从磁盘读取内容放入到分配的页框中。</p>
<hr>
<ol start="7">
<li>一个虚拟存储器系统中，主存容量16MB，辅存容量2GB，地址寄存器位数32位。那么虚存最大容量为（ ）</li>
</ol>
<ul>
<li>2GB</li>
<li>16MB</li>
<li>2GB + 16MB</li>
<li><strong>4GB</strong></li>
</ul>
<p>这是常见的障眼法了。群里有人曾经提问过，虚存4GB连主存+辅存都放不下，那怎么能说虚存最大为4GB呢？老师的回答是这样的：虚存大小不会受到硬盘的大小限制，因为这是虚存。因为是虚存，所以实际用到多少鬼知道。而且，甚至可以没有硬盘——比如无盘工作站、分布式系统、透明计算……虚存最后不一定需要对应到实际的物理存储的。所以虚存大小只和地址位数有关。（如果以上内容逻辑混乱，那是因为老师在微信里的回答比较零散。）</p>
<p><strong>EXPLANATION</strong></p>
<p>虚拟存储器的最大容量跟虚拟地址空间有关，是2^32。</p>
<hr>
<ol start="8">
<li>某进程的页面访问顺序为1、3、2、4、2、3、1、2，系统最多分配3个物理页面，那么采用LRU算法时，进程运行过程中会发生（ ）缺页</li>
</ol>
<ul>
<li>三次</li>
<li>四次</li>
<li><strong>五次</strong></li>
<li>六次</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>访问页面</th>
<th>是否缺页</th>
<th>换出</th>
<th>栈顶（MRU）</th>
<th></th>
<th>栈底（LRU）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>是</td>
<td>-</td>
<td>1</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>是</td>
<td>-</td>
<td>3</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>是</td>
<td>-</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>是</td>
<td>1</td>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>否</td>
<td>-</td>
<td>2</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>否</td>
<td>-</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>是</td>
<td>4</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>否</td>
<td>-</td>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>EXPLANATION</strong></p>
<p>解释：1（缺页） - 3（缺页） - 2（缺页） - 4（缺页，换出1） - 2 - 3 - 1（缺页，换出4） - 2</p>
<hr>
<ol start="9">
<li>设两个进程共用一个临界区资源对应的互斥信号量mutex。当一个进程进入了临界区，另一个进程等待时，mutex应该等于多少（）</li>
</ol>
<ul>
<li><strong>-1</strong></li>
<li>0</li>
<li>1</li>
<li>2</li>
</ul>
<p>在一般的实现下，如果信号量的值为负数，则它的相反数=等待进程个数。</p>
<p><strong>EXPLANATION</strong></p>
<p>两个进程共用一个临界区的互斥信号量mutex，那么mutex的取值范围应该是1到-1，1表示没有进程进入临界区并且也没有进程等待，0表示有一个进程进入临界区，-1表示有一个进程进入临界区并且另一个进程等待。</p>
<hr>
<ol start="10">
<li>(1)多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（ ）</li>
</ol>
<ul>
<li>1</li>
<li>2</li>
<li><strong>3</strong></li>
<li>4</li>
</ul>
<ol start="10">
<li>(2)如10.(1)所描述的情况,信号量S的初值是（）</li>
</ol>
<ul>
<li><strong>1</strong></li>
<li>2</li>
<li>3</li>
<li>4</li>
</ul>
<p>等待进程数量为3。初值-6+2=-3，因此初值=1。</p>
<p><strong>EXPLANATION</strong></p>
<p>-3+6-2=1</p>
<hr>
<ol start="11">
<li>用于互斥的二值信号量可以初始化为（）</li>
</ol>
<ul>
<li><strong>0或1</strong></li>
<li>0或-1</li>
<li>只能为1</li>
<li>任意值</li>
</ul>
<p>事实上，用于互斥作用的信号量初值应该置1，用于条件等待作用的信号量初值应该置0。</p>
<p><strong>EXPLANATION</strong></p>
<p>通常操作系统区分计数信号量与二值信号量，二进制信号量的值只能为0或1</p>
<hr>
<ol start="12">
<li>设与某资源关联的信号量Sem初值为4，当前值为2。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（）</li>
</ol>
<ul>
<li>0、1</li>
<li>1、0</li>
<li>1、2</li>
<li><strong>2、0</strong></li>
</ul>
<p>显然可用个数为2，没有进程在等待。</p>
<p><strong>EXPLANATION</strong></p>
<p>信号量表示当前可用的相关资源数。当信号量Sem&gt;0时，表示还有Sem个相关资源可用；而当信号量Sem&lt;=0时，表示有|Sem|个进程在等待该资源。所以该资源可用数是2，等待该资源的进程数是0。</p>
<hr>
<ol start="13">
<li>有两个并发执行的进程P1和P2，共享初值为1的变量x。加1和减1操作的指令序列分别如下所示。</li>
</ol>
<p>P1：对x执行加一操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load R1,x</span><br><span class="line">inc R1</span><br><span class="line">store R1,x</span><br></pre></td></tr></table></figure>
<p>P2：对x执行减一操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load R2,x</span><br><span class="line">dec R2</span><br><span class="line">store R2,x</span><br></pre></td></tr></table></figure>
<p>两个操作完成后，x的值（ ）</p>
<ul>
<li>可能为-1或3</li>
<li>只能为1</li>
<li><strong>可能为0、1或2</strong></li>
<li>可能为-1、0、1、1或2</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>依次执行P1-1，P1-2，P1-3，P2-1，P2-2，P2-3，得到的结果是1；依次执行P1-1，P1-2，P2-1，P2-2，P2-3，P1-3，得到的结果是2；依次执行P2-1，P2-2，P1-1，P1-2，P1-3，P2-3得到的结果是0</p>
<hr>
<ol start="14">
<li>资源的有序分配策略可以破坏死锁的（）条件</li>
</ol>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li><strong>循环等待</strong></li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>资源的有序分配策略属于死锁预防的一种，死锁预防是通过破坏4个必要条件中的1个或者多个以确保系统不会发生死锁。采用资源有序分配法是破坏了“环路”条件，即破坏了循环等待。</p>
<hr>
<ol start="15">
<li>若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此进程的叙述中，正确的是（）</li>
</ol>
<p>I. 若文件的数据不在内存中，则该进程进入睡眠等待状态<br>
II. 请求read系统调用会导致CPU从用户态切到核心态<br>
III. read系统调用的参数应包含文件的名称</p>
<ul>
<li><strong>仅I、II</strong></li>
<li>仅I、III</li>
<li>仅II、III</li>
<li>I、II和III</li>
</ul>
<p>中间做错了，不是D。问题就在于，这个是read调用，不是open调用。</p>
<p><strong>EXPLANATION</strong></p>
<p>对于I，当所读文件的数据不在内存时，产生I/O请求，原进程进入阻塞状态，知道所需数据从外存调入内存后，才将该进程唤醒。对于II，read系统调用通过陷入将CPU从用户态进入核心态，从而获取操作系统提供的服务。对于III，读一个文件首先要用open系统调用打开该文件。open参数包含文件的路径名与文件名，read只需要open返回的文件描述符，不用文件名作为参数。read要求三个输入参数：1文件描述符fd；2buf缓冲区首地址；3传送的字节数n。read的功能试图从fd所指示的文件中读入n个字节的数据，并将它们送到buf所指示的缓冲区中。</p>
<hr>
<ol start="16">
<li>用户删除某文件的过程中，操作系统不可能执行的操作是（）</li>
</ol>
<ul>
<li><strong>删除文件所在的目录</strong></li>
<li>删除与此文件关联的目录项</li>
<li>删除与此文件对应的文件控制块</li>
<li>释放与此文件关联的内存缓冲区</li>
</ul>
<p>这个好像是常识。</p>
<p><strong>EXPLANATION</strong></p>
<p>删除文件不能删除文件所在的目录，而与此文件关联的目录项和文件控制块需要随着文件一同删除，同时释放文件关联的内存缓冲区。</p>
<hr>
<ol start="17">
<li>设文件A的当前引用计数值为1，先建立文件A的符号链接（软链接）文件B，再建立文件A的硬链接C，然后删除文件A。此时，文件B和文件C的引用计数分别是（）</li>
</ol>
<ul>
<li>0,1</li>
<li><strong>1,1</strong></li>
<li>1,2</li>
<li>2,1</li>
</ul>
<p>B是我随便选的，实际上我并不会算引用计数。</p>
<p><strong>EXPLANATION</strong></p>
<p>建立符号链接时，引用计数为1；建立硬链接时，引用计数加1。删除文件时，删除操作对于符号链接是不可见的，这并不影响符号链接文件；当以后通过符号链接访问文件时，发现文件不存在；但对于硬链接删除操作，引用计数值减1，若值大于0，则不会真正删除文件数据，因为还有其他的硬链接或文件索引指向此文件。当建立B时，A和B的引用计数值都为1.当建立C时，A和B的引用计数值分别为2和1。删除A时，C的引用计数值为2-1=1，B的引用计数值不变。</p>
<hr>
<ol start="18">
<li>在多用户操作系统中，某文件占用10个磁盘块，现在要把该文件磁盘块逐个读入主缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓冲区的时间为100μs，将缓冲区的数据传送到用户区的时间是50μs，CPU对一块数据进行分析的时间为50μs。在单缓冲区和双缓冲区结构下，读入并分析完该文件的时间分别是（ ）</li>
</ol>
<ul>
<li>1500μs，1000μs</li>
<li>1550μs，1100μs</li>
<li>1550μs，1550μs</li>
<li>2000μs，2000μs</li>
</ul>
<p>单缓冲区：(100+50) * 10 + 50 = 1550μs</p>
<p>双缓冲区：100 + 100*9 + 50 + 50 = 1100μs</p>
<p><strong>EXPLANATION</strong></p>
<p>单缓冲区下，当上一个磁盘块从缓冲区读入用户区完成时下一磁盘块才能开始读入，所以当最后一块磁盘块读入用户区完毕时，所用时间为150×10＝1500，加上处理最后一个磁盘块的cpu处理时间50，最后结果为1550。</p>
<p>双缓冲区下，读入第一个缓冲区之后可以立刻开始读入第二个缓冲区，读完第二个缓冲区之后，第一个缓冲区的数据已经传送到用户区，因此不存在等待磁盘块从缓冲区读入用户区的问题，也就是100×10＝1000，再加上最后一个缓冲区的数据传输到用户区并有CPU处理的时间50+50=100，总的时间是1000+100=1100。</p>
<hr>
<ol start="19">
<li>假设磁头当前位于第105道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为35，45，12，68，110，180，170，195。采用SCAN调度（电梯调度）算法得到的磁道访问序列是()</li>
</ol>
<ul>
<li><strong>110，170，180，195，68，45，35，12</strong></li>
<li>110，68，45，35，12，170，180，195</li>
<li>110，170，180，195，12，35，45，68</li>
<li>12，35，45，68，110，170，180，195</li>
</ul>
<p>A对应的是SCAN算法（磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道；然后调换方向）</p>
<p>我猜测B对应的是SSTF算法（选择从磁臂当前位置需要移动最少的I/O请求）；C对应的是CLOOK算法（限制仅在一个方向上扫描；当最后一个请求也被访问过了后，磁臂返回到磁盘的另外一端再次进行扫描）；D不知道是啥。</p>
<p><strong>EXPLANATION</strong></p>
<p>SCAN调度算法就是电梯调度算法，顾名思义就是如果开始时磁头往外就一直要到最外面，然后再返回向里（磁头编号一般是最外面为0号往里增加），就像电梯若往下则一直要下到最底层才会再上升一样。</p>
<hr>
<ol start="20">
<li>某操作系统中建立了一个基于索引节点(index node)结构的文件系统very simple file system, 简称vsfs。</li>
</ol>
<p>vsfs的用户操作包括(以函数形式表示):</p>
<ul>
<li>mkdir(“str”) - 创建一个新目录,目录名称为”str”</li>
<li>creat(“str”) - 创建一个空文件,空文件名称为“str”</li>
<li>fd=open(“str”), write(fd), close(fd) – 打开文件”str”,会返回一个整型数fd, 然后对文件写一个buffer,注意常规文件的最大size是一个data block,所以第二次写(写文件的语义是在上次写的位置后再写一个data block)会报错(文件大小满了)。或者如果data block也满了,也会报错。</li>
<li>link(“a1”,”b1”) - 对文件”a1”创建一个硬链接(hard link)文件”b1”</li>
<li>unlink(“b1”) - 对文件“b1”取消一个硬链接,如果文件的链接数为0,则删除此文件</li>
</ul>
<p>vsfs在硬盘上的布局:</p>
<ul>
<li>superblock : 可用inode数量,可用data block数量</li>
<li>inode bitmap : inode的分配图(基于bitmap)</li>
<li>inodes : inode的存储区域</li>
<li>data bitmap : data block的分配图(基于bitmap)</li>
<li>data : data block的存储区域</li>
</ul>
<p>vsfs的关键数据结构:</p>
<ul>
<li>inode数据结构:
<ul>
<li>inode : 包含3个fields, 用 list 表示
<ul>
<li>file type: f -&gt; 常规文件:regular file, d -&gt; 目录文件:directory</li>
<li>data block addr of file content: -1 -&gt; file is empty</li>
<li>reference count: file/directory的引用计数,注意directory的引用计数是指在此目录中的inode的个数</li>
</ul>
</li>
<li>注意:比如,刚创建的一个空文件inode: [f a:-1 r:1], 一个有1个硬链接的文件inode: [f a:10 r:2]</li>
</ul>
</li>
<li>数据块内容结构:
<ul>
<li>一般文件的内容的表示:只是包含单个字符的list,即占一个data block,比如[‘a’], [‘b’] …</li>
<li>目录内容的表示: 多个两元组(name, inode_number)形成的list,比如, 根目录[(.,0) (…,0)], 或者包含了一个’f’文件的根目录[(.,0) (…,0) (f,1)] 。</li>
<li>注意:
<ul>
<li>一个目录的目录项的个数是有限的。 block.maxUsed = 32</li>
<li>data block的个数是有限的,为 fs.numData</li>
<li>inode的个数是有限的,为 fs.numInodes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完整文件系统的例子:</p>
<ul>
<li>fs.ibitmap:      inode bitmap 11110000</li>
<li>fs.inodes:       [d a:0 r:5] [f a:1 r:1] [f a:-1 r:1] [d a:2 r:2] [] …</li>
<li>fs.dbitmap:    data bitmap 11100000</li>
<li>fs.data:           [(.,0) (…,0) (y,1) (z,2) (x,3)] [u] [(.,3) (…,0)] [] …</li>
</ul>
<p>表明: 此文件系统有8个inode空间, 8个data blocks. 其中,根目录包含5个目录项，“.”,“…”,“y”,“z”,“x”。 而“y”是常规文件,并有文件内容,包含一个data block,文件内容为“u”。“z”是一个空的常规文件。“x”是一个目录文件，是空目录。</p>
<p>如果vsfs初始状态为:</p>
<ul>
<li>inode bitmap     10000000</li>
<li>inodes                 [d a:0 r:2] [] [] [] [] [] [] []</li>
<li>data bitmap       10000000</li>
<li>data                     [(.,0) (…,0)] [] [] [] [] [] [] []</li>
</ul>
<p>请问接下来的连续6个状态变化的对应用户操作是什么?据此回答以下6个问题</p>
<hr>
<ol start="20">
<li>(1)</li>
</ol>
<ul>
<li>inode bitmap 11000000</li>
<li>inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li><strong>mkdir(&quot;/c&quot;);</strong></li>
<li>unlink(&quot;/c&quot;);</li>
<li>creat(&quot;/c&quot;);</li>
<li>fd=open(“/c”), write(fd), close(fd)</li>
</ul>
<p>显然多了一个目录。</p>
<p><strong>EXPLANATION</strong></p>
<p>mkdir(&quot;/c&quot;);</p>
<hr>
<ol start="20">
<li>(2)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (h,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/h&quot;);</li>
<li>unlink(&quot;/c/h&quot;);</li>
<li><strong>creat(&quot;/c/h&quot;);</strong></li>
<li>fd=open(“/c/h”), write(fd), close(fd)</li>
</ul>
<p>在c目录下多了一个空文件h。</p>
<p><strong>EXPLANATION</strong></p>
<p>creat(&quot;/c/h&quot;);</p>
<hr>
<ol start="20">
<li>(3)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:4] [f a:-1 r:2] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (h,2) (p,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/p&quot;);</li>
<li>creat(&quot;/c/p&quot;);</li>
<li><strong>link(&quot;/c/h&quot;, “/c/p”);</strong></li>
<li>unlink(&quot;/c/h&quot;);</li>
</ul>
<p>文件<code>/c/h</code>和目录<code>/c</code>的引用记录增加了，<code>/c</code>目录下多了一个<code>p</code>文件。</p>
<p><strong>EXPLANATION</strong></p>
<p>link(&quot;/c/h&quot;, “/c/p”);</p>
<hr>
<ol start="20">
<li>(4)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (p,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/h&quot;);</li>
<li>unlink(&quot;/c/p&quot;);</li>
<li>link(&quot;/c/h&quot;, “/c/p”);</li>
<li><strong>unlink(&quot;/c/h&quot;);</strong></li>
</ul>
<p>文件<code>/c/h</code>和目录<code>/c</code>的引用记录减少了，文件<code>/c/h</code>被删除了。</p>
<p><strong>EXPLANATION</strong></p>
<p>unlink(&quot;/c/h&quot;);</p>
<hr>
<ol start="20">
<li>(5)</li>
</ol>
<ul>
<li>inode bitmap 11000000</li>
<li>inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c&quot;);</li>
<li>unlink(&quot;/c&quot;);</li>
<li>creat(&quot;/c/p&quot;);</li>
<li><strong>unlink(&quot;/c/p&quot;);</strong></li>
</ul>
<p>文件<code>/c/p</code>也被删除了。</p>
<p><strong>EXPLANATION</strong></p>
<p>unlink(&quot;/c/p&quot;);</p>
<hr>
<ol start="20">
<li>(6)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (f,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/f&quot;);</li>
<li><strong>creat(&quot;/c/f&quot;);</strong></li>
<li>link(&quot;/c&quot;,&quot;/c/f“);</li>
<li>fd=open(“/c/f”), write(fd), close(fd)</li>
</ul>
<p>新建了一个文件f。</p>
<p><strong>EXPLANATION</strong></p>
<p>creat(&quot;/c/f&quot;);</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2016-final-exam-analysis/">
              
                  《操作系统》2016年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-19
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2016spring/FinalExam?action=AttachFile&amp;do=view&amp;target=20160524-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE-v1a.pdf" target="_blank" rel="noopener">20160524-期末考试题目-v1a.pdf</a>。</p>
<h2 id="判断题20分"><a class="markdownIt-Anchor" href="#判断题20分"></a> 判断题（20分）</h2>
<ol>
<li>在进程控制块数据结构中，必须为进程建立内核栈结构，确保进程可以得到操作系统的可靠服务和管理等支持。（√）</li>
</ol>
<p>以下解释摘自ucore docs Lab4：</p>
<blockquote>
<p>每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。uCore在创建进程时分配了2个连续的物理页（参见memlayout.h中KSTACKSIZE的定义） 作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好tss（可以回顾一下在实验一中讲述的 tss在中断处理过程中的作用），以便在进程切换以后再发生中断时能够使用正确的栈。其次，内核<br>
栈位于内核地址空间，并且是不共享的（ 每个线程都拥有自己的内核栈） ，因此不受到mm的管理，当进程退出的时候，内核能够根据kstack的值快速定位栈的位置并进行回收。</p>
</blockquote>
<hr>
<ol start="2">
<li>在进程切换过程中，进程上下文信息的保存与恢复过程必须在内核态完成。（√）</li>
</ol>
<p>以下内容摘自ucore docs Lab4：</p>
<blockquote>
<p>context：进程的上下文，用于进程切换（参见switch.S）。在uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等） 。使用context保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在<code>kern/process/switch.S</code>中定义的<code>switch_to</code>。</p>
</blockquote>
<p>进程的上下文信息除了context以外，还包括页表信息（CR3寄存器），访问和修改这些内容需要特权指令，因此必须在内核态完成。</p>
<hr>
<ol start="3">
<li>对于父进程而言，<code>fork()</code>的返回值只能是子进程的pid号。（×）</li>
</ol>
<p>如果<code>fork()</code>不成功，则会返回-1。</p>
<hr>
<ol start="4">
<li>对于分属不同进程的线程A和线程B之间进行切换，必须要切换页表。（√）</li>
</ol>
<p>同一进程的不同线程共享同一页表，但不同进程对应的页表一般是不同的。</p>
<hr>
<ol start="5">
<li>在用户空间中实现的线程模型可以有效的避开操作系统调度带来的时间开销。（?）</li>
</ol>
<p>我猜这是<a href="/post/os-mooc-lecture-11-summary">第11讲“进程和线程”</a>中的内容。用户线程的优点是同一进程内的用户线程切换快，但是内核并不了解用户线程，因此只能按进程分配CPU时间；而内核线程的创建、终止和切换的代价相对较大（因为需要在内核态实现），但可以以线程为单位进行CPU时间分配。总的来说，避免操作系统的调度是不太可能的，所以我认为此题的描述是错误的。</p>
<p>2018.5.25 UPD：tsz同学认为此题题意不清。我同意这一观点。用户态实现的线程切换的时候的确可以不通过OS的进程调度，但是当然，完全避开OS的调度是不太可能的。</p>
<p>2018.12.19 UPD：评论区<a href="https://disqus.com/by/disqus_PF6zRZnxXv/" target="_blank" rel="noopener">酒和弦</a>的回复提醒了我，“避开操作系统调度带来的时间开销”的意思不一定是真的要避开操作系统的调度，而是用用户线程调度替代OS线程调度。这的确可以节省时间开销。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>不过我仍然认为这道题的含义不明确，所以现在我把答案改成了？</p>
<hr>
<ol start="6">
<li>对于应用程序而言，编译器生成的程序地址是虚拟地址，由操作系统建立段/页表完成虚实地址转换。（√）</li>
</ol>
<p>好像确实是这么回事。</p>
<hr>
<ol start="7">
<li>对于采用段页式的x86而言，CPU访问一个虚拟地址时，如TLB访问缺失，则需先通过页表，再通过段表才能找到对应的物理地址。（×）</li>
</ol>
<p>反了，是先通过段表，再通过页表。</p>
<hr>
<ol start="8">
<li>通过动态链接库和操作系统的页表设置，可以让多个不同的应用程序运行时共用一个库函数（如<code>printf</code>等）的代码实现。（√）</li>
</ol>
<p>反正就是可以通过页表设置映射到同一块物理内存。OS本身的代码也是这么操作的。</p>
<hr>
<ol start="9">
<li>当设置好GDT（全局描述符表）的内容：然后CPU执行<code>lgdt</code>指令加载GDT；接着立刻执行<code>incl 0x80</code>指令时，CPU将查找GDT并完成虚拟地址<code>0x80</code>到线性地址的转换。（×）</li>
</ol>
<p>这道题的表述比较模糊不清。不过据说这个描述是错误的，因为里面没有提到对GDT项指向的段寄存器的更新。</p>
<hr>
<ol start="10">
<li>在32位计算机系统中，由于4GB内存普遍存在，导致虚拟内存管理已经不再有存在的必要。（×）</li>
</ol>
<p>这种说法显然有很多问题，比如：</p>
<ul>
<li>4GB仍然很不够用</li>
<li>虚拟内存管理的功能不止有增加“虚拟”内存，还有细粒度的对内存访问权限和内存共享的管理</li>
</ul>
<hr>
<ol start="11">
<li>对于实时系统中的优先级反转（反置）问题，可通过优先级继承算法或优先级天花板算法来解决。（√）</li>
</ol>
<p>这是<a href="/post/os-mooc-lecture-15-summary">第15讲“处理机调度”</a>中的内容。优先级继承算法的思路是，占有资源的低优先级进程继承申请资源的高优先级进程的优先级；而优先级天花板算法的思路是，占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同。</p>
<hr>
<ol start="12">
<li>信号量机制可实现基于条件变量的管程机制，反之亦然。（√）</li>
</ol>
<p>信号量和条件变量是等价的（也就是它们可以互相实现）。</p>
<hr>
<ol start="13">
<li>在多CPU系统中，仅通过CPU中断使能和屏蔽指令，就可实现对临界区代码的互斥保护。（×）</li>
</ol>
<p>因为有多个CPU，因此使能单个CPU的中断完全不能保证互斥保护。</p>
<hr>
<ol start="14">
<li>在银行家算法中，不安全状态不一定会造成死锁。（√）</li>
</ol>
<p><img src="safe-state-and-deadlock.png" alt="安全状态和死锁的关系"></p>
<hr>
<ol start="15">
<li>操作系统中的虚拟文件系统屏蔽了底层具体文件系统的差异性，给上层应用提供了统一的访问接口。（√）</li>
</ol>
<p>这是很原理性的话了。显然是对的。</p>
<hr>
<ol start="16">
<li>在Linux中，存在不需要把数据保存到磁盘上的文件系统，比如<code>/proc</code>文件系统，其作用是给应用程序提供一种内核信息的访问通道。（√）</li>
</ol>
<p>是的。以下内容摘自<a href="https://www.cnblogs.com/cute/archive/2011/04/20/2022280.html" target="_blank" rel="noopener">深入理解linux系统下proc文件系统内容</a>：</p>
<blockquote>
<p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。<br>
基于/proc文件系统如上所述的特殊性，其内的文件也常被称作虚拟文件，并具有一些独特的特点。例如，其中有些文件虽然使用查看命令查看时会返回大量信息，但文件本身的大小却会显示为0字节。此外，这些特殊文件中大多数文件的时间及日期属性通常为当前系统时间和日期，这跟它们随时会被刷新（存储于RAM中）有关。<br>
为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如/proc/scsi目录中存储的就是当前系统上所有SCSI设备的相关信息，/proc/N中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程（可以想象得到，在某进程结束后其相关目录则会消失）。<br>
大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如apm、free、lspci或top查看时却可以有着不错的表现。</p>
</blockquote>
<hr>
<ol start="17">
<li>在当前的计算机系统中，存在计算能力比CPU还快的外设。（√）</li>
</ol>
<p>我也不知道到底是什么外设……不过我大胆猜测这里指的是GPU。不过，即使是CPU和GPU的比较，这个说法仍然不见得是很严谨的。</p>
<blockquote>
<p>造成GPU和CPU根本差别的原因在于不同的目标需求：GPU假设运行其上的工作都是高度可并行的，而CPU需要同时很好的支持并行和顺序操作。于是，CPU需要大的片上缓存和复杂的控制逻辑，GPU则利用多线程并行运行节省了片上的大缓存，同时针对一簇线程执行同一套控制逻辑。因此，在高度并行化且数据规模巨大的应用下，GPU可以获得很高的浮点运算性能，然而如果问题无法良好映射到某个合适的并行模型或当数据规模较小时，SIMT就无法发挥并行的优势，CPU与GPU之间的数据交换也会大大降低运算效率。不过，后一个问题在刚刚发布的CUDA4.0中已经通过GPUDirect2.0得到了改进)。<br>
作者：王洋子豪<br>
链接：<a href="https://www.zhihu.com/question/19584781/answer/12292363" target="_blank" rel="noopener">https://www.zhihu.com/question/19584781/answer/12292363</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<hr>
<ol start="18">
<li>DMA机制允许外设不经过CPU进行数据传输。（√）</li>
</ol>
<p>以下内容摘自<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96" target="_blank" rel="noopener">直接内存访问</a>：</p>
<blockquote>
<p>直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。</p>
</blockquote>
<hr>
<ol start="19">
<li>循环扫描算法（C-SCAN）对硬盘访问带来的好处在U盘上不存在。（√）</li>
</ol>
<blockquote>
<p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。（<a href="http://gengning938.blog.163.com/blog/static/128225381201161884614990/" target="_blank" rel="noopener">磁盘调度算法</a>）</p>
</blockquote>
<blockquote>
<p>对于U盘和SSD等随机访问的Flash半导体存储器，采用FCFS（先来先服务）调度策略更高效。 因为Flash的半导体存储器的物理结构不需要考虑寻道时间和旋转延迟，可直接按I/O请求的先后顺序服务。（<a href="https://www.nowcoder.com/questionTerminal/64fe6441b3fe47708803354979645a36" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/64fe6441b3fe47708803354979645a36</a>）</p>
</blockquote>
<hr>
<ol start="20">
<li>访问频率置换算法（Frequency-based Replacement）的基本思路是，在短周期中使用LFU算法，而在长周期中使用LRU算法。（×）</li>
</ol>
<p>其实我现在还没有学到这里，但似乎这个描述反了，应该是短周期使用LRU，长周期使用LFU。</p>
<h2 id="填空题20分"><a class="markdownIt-Anchor" href="#填空题20分"></a> 填空题（20分）</h2>
<h3 id="21"><a class="markdownIt-Anchor" href="#21"></a> 21</h3>
<p>在基于x86-32的ucore操作系统中，一般函数调用的参数通过（<strong>1.1</strong>）传递，系统调用的参数通过（<strong>1.2</strong>）传递，将系统调用号存放在（<strong>1.3</strong>），通过（<strong>1.4</strong>）指令进入内核态。此时还应该保存执行现场，需要在<code>trapframe</code>里保存（<strong>1.5</strong>）、（<strong>1.6</strong>）、（<strong>1.7</strong>）等信息（填三项即可）。</p>
<ol>
<li>栈</li>
<li>寄存器和栈</li>
<li>eax寄存器</li>
<li><code>int 0x80</code></li>
<li>通用寄存器</li>
<li>EFLAGS寄存器</li>
<li>EIP</li>
</ol>
<hr>
<p>以下内容摘自<a href="https://blog.csdn.net/xinghun_4/article/details/8288321" target="_blank" rel="noopener">系统调用和函数参数传递</a>：</p>
<blockquote>
<p>系统调用参数传递：</p>
</blockquote>
<ul>
<li>x86_32
<ul>
<li>通过中断（int 0x80）来实现</li>
<li>寄存器 eax 中存放系统调用号，同时系统调用返回值也存放在 eax 中</li>
<li>当系统调用参数小于等于6个时，参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi ，ebp中</li>
<li>当系统调用参数大于6个时，全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
</li>
<li>x86_64
<ul>
<li>通过中断（syscall）指令来实现</li>
<li>寄存器 eax 中存放系统调用号，同时系统调用返回值也存放在 eax 中</li>
<li>当系统调用参数小于等于6个时，参数则必须按顺序放到寄存器 rdi，rsi，rdx，r10，r8，r9中</li>
<li>当系统调用参数大于6个时，全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数参数传递：</p>
</blockquote>
<ul>
<li>x86_32
<ul>
<li>C调用约定（即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。</li>
</ul>
</li>
<li>x86_64
<ul>
<li>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前6个与前面一样， 但后面的依次从&quot;右向左&quot;放入栈中。</li>
</ul>
</li>
</ul>
<p><code>struct trapframe</code>的定义如下（摘自<code>kern/trap/trap.h</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">    struct pushregs tf_regs;</span><br><span class="line">    uint16_t tf_gs;</span><br><span class="line">    uint16_t tf_padding0;</span><br><span class="line">    uint16_t tf_fs;</span><br><span class="line">    uint16_t tf_padding1;</span><br><span class="line">    uint16_t tf_es;</span><br><span class="line">    uint16_t tf_padding2;</span><br><span class="line">    uint16_t tf_ds;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_trapno;</span><br><span class="line">    /* below here defined by x86 hardware */</span><br><span class="line">    uint32_t tf_err;</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding4;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">    /* below here only when crossing rings, such as from user to kernel */</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>trapframe</code>中保存的信息包括：</p>
<ul>
<li>通用寄存器（<code>tf_regs</code>，其中保存了edi、esi、ebp、ebx、edx、ecx和eax）</li>
<li>中断错误码（<code>err</code>）</li>
<li>eip（指令指针）</li>
<li>cs（代码段寄存器）</li>
<li>EFLAGS寄存器</li>
<li>esp（栈寄存器，可选）</li>
<li>ss（堆栈段寄存器，可选）</li>
</ul>
<h3 id="22"><a class="markdownIt-Anchor" href="#22"></a> 22</h3>
<p>（<strong>2.1</strong>）是一种将不同文件名链接至同一个文件的机制，它可以使同一文件具有多个不同的名字，而文件系统只存在一个文件内容的副本。（<strong>2.2</strong>）和原文件共享一个相同的inode号（文件在文件系统上的唯一标识）。若原文件删除了，则（<strong>2.3</strong>）不能访问它指向的原文件，而（<strong>2.4</strong>）则是可以的。（<strong>2.5</strong>）可以跨越磁盘分区，但（<strong>2.6</strong>）不具备这个特性。</p>
<ol>
<li>链接</li>
<li><del>软链接</del>硬链接</li>
<li>软链接</li>
<li>硬链接</li>
<li>软链接</li>
<li>硬链接</li>
</ol>
<hr>
<p>以下内容摘自<a href="http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noopener">Linux软连接和硬链接</a>：</p>
<blockquote>
<p>Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。<br>
【硬连接】<br>
硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。<br>
【软连接】<br>
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
</blockquote>
<p>更详细的解释可以参见<a href="https://blog.csdn.net/hairetz/article/details/4168296" target="_blank" rel="noopener">关于硬链接和软连接（符号链接）的区别</a>。</p>
<p>2018.5.25 UPD：经过wj同学的提示，我发现不知为何2抽风写错了。共享inode号的应该是硬链接。</p>
<h3 id="23"><a class="markdownIt-Anchor" href="#23"></a> 23</h3>
<p>RAID是一种机制，即把多块独立的硬盘按某种方式组合，形成硬盘阵列，从而提供比单块硬盘更快的访问性能或更可靠的数据存储能力。组成磁盘阵列的不同方式称为RAID级别，其中，（<strong>3.1</strong>）级别没有数据冗余存储功能，而（<strong>3.2</strong>）的数据可靠性在所有的RAID级别中是最高的。RAID 5是一种存储性能、数据安全和存储成本兼顾的磁盘阵列组成方式。它至少需要（<strong>3.3</strong>）块硬盘。当RAID5的一个磁盘数据发生损坏后，可利用剩下的数据和相应的（<strong>3.4</strong>）信息去恢复被损坏的数据。</p>
<ol>
<li>RAID 0</li>
<li>RAID 6</li>
<li>3</li>
<li>校验</li>
</ol>
<hr>
<ul>
<li>RAID-0：磁盘条带化
<ul>
<li>把数据块分成多个子块，存储在独立的磁盘中</li>
<li>通过独立磁盘上并行数据块访问来提供更大的磁盘带宽</li>
</ul>
</li>
<li>RAID-1：磁盘镜像
<ul>
<li>向两个磁盘写入相同的数据，从任何一个磁盘读取</li>
</ul>
</li>
<li>RAID-4：带校验的磁盘条带化
<ul>
<li>数据块级的磁盘条带化+专用奇偶校验磁盘</li>
</ul>
</li>
<li>RAID-5：带分布式校验的磁盘条带化
<ul>
<li>分摊校验磁盘的带宽限制</li>
<li>把校验和分布在各个磁盘上</li>
</ul>
</li>
<li>RAID-6：每组条带块有两个冗余块，允许两个磁盘错误</li>
</ul>
<h3 id="24"><a class="markdownIt-Anchor" href="#24"></a> 24</h3>
<p>信号提供了异步处理事件的一种方式。例如，用户在终端按下“Ctrl-C”键，会产生可使当前进程终止的SIGINT信号。每一个信号对应一个（<strong>4.1</strong>）数，定义在头文件<code>&lt;signal.h&gt;</code>中。信号处理行为可由三种方式可供选择：（<strong>4.2</strong>）、（<strong>4.3</strong>）、（<strong>4.4</strong>）。</p>
<ol>
<li>整</li>
<li>捕获</li>
<li>忽略</li>
<li>屏蔽</li>
</ol>
<hr>
<p>这部分是第20讲“死锁和进程通信”里的，但是我几乎都忘掉了……总之，信号和“信号号”的对应关系很类似于中断和中断号的关系，但是并没有一个明确的名称，所以我觉得回答“整数”是可以的。（参考<a href="https://blog.csdn.net/jnu_simba/article/details/11746217" target="_blank" rel="noopener">https://blog.csdn.net/jnu_simba/article/details/11746217</a>）</p>
<h2 id="问答题60分"><a class="markdownIt-Anchor" href="#问答题60分"></a> 问答题（60分）</h2>
<h3 id="25-银行家算法10分"><a class="markdownIt-Anchor" href="#25-银行家算法10分"></a> 25. 银行家算法（10分）</h3>
<p>下面是采用银行家算法的操作系统在某一时刻的资源分配状态。</p>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Max矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>7</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Available矩阵：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>5</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>请回答下列问题：</p>
<ol>
<li>请写出当前时刻的Need矩阵的内容是什么？</li>
<li>当前时刻，系统是否处于安全状态？</li>
<li>接下来，如果进程P1发出一个请求(0, 4, 2, 0)。这个请求能否立刻被满足？</li>
</ol>
<hr>
<p>要获得Need矩阵，只需将Allocation矩阵从Max矩阵中减去。于是得到：</p>
<p>Need矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>7</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>下面判断系统是否处于安全状态：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 1, 2] = [1, 5, 3, 2]，Finish[P0] = true</li>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5, 4] = [2, 8, 8, 6]，Finish[P2] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 0, 0, 0] = [3, 8, 8, 6]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 6, 3, 2] = [3, 14, 11, 8]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1, 4] = [3, 14, 12, 12]，Finish[P4] = true</li>
<li>算法结束，系统处于安全状态</li>
</ol>
<p>如果P1发出请求为Request = [0, 4, 2, 0]：</p>
<ol>
<li>Request &lt;= Need[P1]，资源申请未超过限度</li>
<li>Request &lt;= Available，不需等待</li>
<li>假设资源已分配，更新各矩阵内容：</li>
</ol>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>4</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Available矩阵：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Need矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>然后判断当前状态是否为安全状态：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 1, 2] = [1, 1, 1, 2]，Finish[P0] = true</li>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5, 4] = [2, 4, 6, 6]，Finish[P2] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 4, 2, 0] = [3, 8, 8, 6]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 6, 3, 2] = [3, 14, 11, 8]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1, 4] = [3, 14, 12, 12]，Finish[P4] = true</li>
<li>算法结束，系统处于安全状态</li>
</ol>
<p>由于分配后系统仍然处于安全状态，这个请求可以立刻被满足。</p>
<h3 id="26-同步互斥10分"><a class="markdownIt-Anchor" href="#26-同步互斥10分"></a> 26. 同步互斥（10分）</h3>
<p>通过软件机制可正确实现互斥机制。</p>
<h4 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h4>
<p>下列二线程互斥机制的伪码实现是否有错？请给出原因分析，如果有错请给出反例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared int turn;</span><br><span class="line">    ...</span><br><span class="line">    turn = i ;</span><br><span class="line"></span><br><span class="line">ENTRY PROTOCOL (for Thread i ):</span><br><span class="line">    /* wait until it&apos;s our turn */</span><br><span class="line">    while (turn != i ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">EXIT PROTOCOL (for Thread i ):</span><br><span class="line">    /* pass the turn on */</span><br><span class="line">    turn = j ;</span><br></pre></td></tr></table></figure>
<hr>
<p>事实上这就是第17讲“同步互斥”中“基于软件的同步方法”中介绍的第一种错误做法。这种做法满足“忙则等待”，但不满足“空闲则入”。线程i和j必须轮流访问临界区；如果i始终不进入临界区，则j无法进入，会发生饥饿。</p>
<p>我有时会忽略“空闲则入”这条规则，事实上这也是临界区实现中非常重要的一条规则。</p>
<h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h4>
<p>下列N线程互斥机制的伪码实现是否有误？请给出原因分析，如果有错请给出反例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    typedef char boolean;</span><br><span class="line">    ...</span><br><span class="line">    shared int num[n];</span><br><span class="line">    ...</span><br><span class="line">    for (j=0; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    /* choose a number */</span><br><span class="line">    num[i] = max(num[0], ..., num[n-1]) + 1;</span><br><span class="line"></span><br><span class="line">    /* for all other Threads */</span><br><span class="line">    for (j=0; j &lt; n; j++) &#123;</span><br><span class="line">        /* wait if the Thread has a number and comes ahead of us */</span><br><span class="line">        if ((num[j] &gt; 0) &amp;&amp;</span><br><span class="line">            ((num[j] &lt; num[i]) ||</span><br><span class="line">            (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            while (num[j] &gt; 0) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    /* clear our number */</span><br><span class="line">    num[i] = 0;</span><br></pre></td></tr></table></figure>
<hr>
<p>这种做法是错误的。假设有两个进程，i&lt;j，Ti正在执行<code>num[i] = max(num[0], ..., num[n-1]) + 1;</code>时，已计算得<code>max(num[0], ..., num[n-1])==0</code>；此时切换到Tj，也计算得<code>max(num[0], ..., num[n-1])==0</code>，随后<code>num[j]=1</code>，Tj先进入临界区。随后切换到Ti，计算得到<code>num[i]=1</code>，检查后Ti也进入临界区，违反互斥。</p>
<p>据说修改num[i]前后应用bool变量choose[i]保护起来，在后面枚举其他进程时先要等待choose[i]完成。这样就可以解决问题了。</p>
<p>（上述解释来自学长答案；这种做法和Eisenberg &amp; Mcquire还是挺不像的）</p>
<h3 id="27-信号量与管程15分"><a class="markdownIt-Anchor" href="#27-信号量与管程15分"></a> 27. 信号量与管程（15分）</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENTATION:</span><br><span class="line">monitor mt &#123;</span><br><span class="line">    -----variable in monitor-----------</span><br><span class="line">    semaphore mutex; // the mutex lock for going into the routines in monitor, should be initialized to 1</span><br><span class="line">    semaphore next; // the next is used to down the signaling proc, some proc should wake up the sleeped cv.signaling proc. should be initialized to 0</span><br><span class="line">    int next_count; // the number of of sleeped signaling proc, should be initialized to 0</span><br><span class="line">    condvar &#123;int count, sempahore sem&#125; cv[N]; // the condvars in monitor, count initial value 0, sem initial value 0</span><br><span class="line">    other shared variables in mt; // shared variables should protected by mutex lock</span><br><span class="line"></span><br><span class="line">    --------condvar wait---------------</span><br><span class="line">    cond_wait (cv) &#123;</span><br><span class="line">        cv.count ++;</span><br><span class="line">        if(mt.next_count&gt;0)</span><br><span class="line">            V(mt.next); // first perform the EXIT PROTOCOL</span><br><span class="line">        else</span><br><span class="line">            V(mt.mutex);</span><br><span class="line">        P(cv.sem); // now wait on the condition waiting queue (cv.sem)</span><br><span class="line">        cv.count --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --------condvar signal--------------</span><br><span class="line">    cond_signal(cv) &#123;</span><br><span class="line">        if(cv.count&gt;0) &#123; // do nothing unless a process is waiting on condition waiting queue (cv.sem)</span><br><span class="line">            mt.next_count ++;</span><br><span class="line">            V(cv.sem);  // release the waiting process which on condition waiting queue (cv.sem)</span><br><span class="line">            P(mt.next); // wait on the &quot;next&quot; waiting queue for cv.signaling proc</span><br><span class="line">            mt.next_count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --------routines in monitor-------------</span><br><span class="line">    routineA_in_mt () &#123;</span><br><span class="line">        P(mt.mutex); // ENTRY PROTOCOL (at the beginning of each monitor routines), wait for exclusive access to the monitor</span><br><span class="line">        ...</span><br><span class="line">        real body of routineA // in here, may access shared variables, call cond_wait OR cond_signal</span><br><span class="line">        ...</span><br><span class="line">        if(next_count&gt;0) // EXIT PROTOCOL (at the end of each monitor function)</span><br><span class="line">            V(mt.next); // if there are processes(sleeped cv.signaling proc) in the &quot;next&quot; queue, release one</span><br><span class="line">        else</span><br><span class="line">            V(mt.mutex); // otherwise, release the monitor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> （1）</h4>
<p>请说明管程的特征。上述管程实现是哪种类型的管程？</p>
<hr>
<p>管程的特征：</p>
<ul>
<li>管程是一种用于多线程互斥访问共享资源的程序结构</li>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<p>很显然，这就是ucore Lab7中实现的管程，属于Hoare语义。在这种语义下，如果条件变量上有进程正在等待，发出signal的进程会立刻进入等待状态，将控制权交给被唤醒的进程。</p>
<h4 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> （2）</h4>
<p>在上述伪码中，如果有3个线程a，b，c需要访问管程，并会使用管程中的2个条件变量<code>cv[0]</code>，<code>cv[1]</code>。</p>
<ol>
<li>请问<code>cv[i]-&gt;count</code>的含义是什么？<code>cv[i]-&gt;count</code>是否可能<code>&lt;0</code>，是否可能<code>&gt;1</code>？请举例或说明原因。</li>
<li>请问<code>mt-&gt;next_count</code>的含义是什么？<code>mt-&gt;next_count</code>是否可能<code>&lt;0</code>，是否可能<code>&gt;1</code>？请举例或说明原因。</li>
</ol>
<hr>
<p><code>cv[i]-&gt;count</code>的含义是在该条件变量上等待的线程数。显然这个数不可能<code>&lt;0</code>。如果有多于1个线程执行了<code>cond_wait(cv[i])</code>操作且还未被唤醒，这个数是可能<code>&gt;1</code>的。</p>
<p><code>mt-&gt;next_count</code>的含义是发出signal后暂时进入等待状态的线程的个数。显然，这个数不可能<code>&lt;0</code>。假设b执行<code>cond_wait(cv[0])</code>开始等待，c也执行<code>cond_wait(cv[0])</code>开始等待。a进入管程，执行<code>cond_signal(cv[0])</code>，唤醒b，a进入signal队列；b被唤醒后，立即执行<code>cond_signal(cv[0])</code>，唤醒c，b也进入signal队列。此时<code>mt-&gt;next_count=2</code>。</p>
<h3 id="28-stride调度算法10分"><a class="markdownIt-Anchor" href="#28-stride调度算法10分"></a> 28. stride调度算法（10分）</h3>
<p>请描述stride调度算法的思路？stride算法的特征是什么？stride调度算法是如何避免stride溢出问题的？</p>
<hr>
<p>思路：</p>
<ul>
<li>每个进程有两个属性：
<ul>
<li>pass：当前位置</li>
<li>stride：一次要前进的步数</li>
<li>stride ∝ 1 / priority</li>
</ul>
</li>
<li>选择进程的方法：
<ul>
<li>执行当前pass最小的进程</li>
<li>该进程的pass += stride</li>
<li>重复该过程</li>
</ul>
</li>
</ul>
<p>特征：</p>
<ul>
<li>stride越小（优先级越高），被调度的次数会越多</li>
<li>基于优先级（priority-based）</li>
<li>调度选择是确定的（deterministic）</li>
</ul>
<p>避免stride溢出的方法：</p>
<ul>
<li>uint32存储、int32相减比较</li>
<li>最大步进值-最小步进值&lt;无符号整数/2</li>
<li>具体可参见Piazza帖子<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=357" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=357</a></li>
</ul>
<h3 id="29-文件系统15分"><a class="markdownIt-Anchor" href="#29-文件系统15分"></a> 29. 文件系统（15分）</h3>
<h4 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> （1）</h4>
<p>试以图示描述ucore操作系统中的SFS文件系统的文件组织方式。</p>
<hr>
<p><img src="sfs-inode.jpg" alt="SFS文件系统的索引分配"></p>
<p>呃，这个怎么描述，不会啊。。。</p>
<p><del>总之据说是链式分配……</del></p>
<p>2018.5.25 UPD：<br>
在ssh同学的提醒下，我想起来SFS使用的是索引分配这回事了……</p>
<h4 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> （2）</h4>
<p>下面是SFS的磁盘索引节点数据结构定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_disk_inode &#123;</span><br><span class="line">    uint32_t size;</span><br><span class="line">    uint16_t type;</span><br><span class="line">    uint16_t nlinks;</span><br><span class="line">    uint32_t blocks;</span><br><span class="line">    uint32_t direct[SFS_NDIRECT];</span><br><span class="line">    uint32_t indirect;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假定ucore里SFS_NDIRECT的取值是16，而磁盘上数据块大小为1KB。请计算这时ucore支持的最大文件大小。请给出计算过程。（这样可给步骤分）</p>
<hr>
<p>以下内容摘自ucore docs Lab8：</p>
<p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。首先我们看看在硬盘上的索引节点的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_disk_inode &#123;</span><br><span class="line">    uint32_t size; // 如果inode表示常规文件，则size是文件大小</span><br><span class="line">    uint16_t type; // inode的文件类型</span><br><span class="line">    uint16_t nlinks; // 此inode的硬链接数</span><br><span class="line">    uint32_t blocks; // 此inode的数据块数的个数</span><br><span class="line">    uint32_t direct[SFS_NDIRECT]; // 此inode的直接数据块索引值（ 有SFS_NDIRECT个）</span><br><span class="line">    uint32_t indirect; // 此inode的一级间接数据块索引值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<p>默认的，ucore里SFS_NDIRECT是12，即直接索引的数据页大小为12 * 4k = 48k；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 12 * 4k + 1024 * 4k = 48k + 4m。数据索引表内，0表示一个无效的索引，inode里blocks表示该文件或者目录占用的磁盘的block的个数。indiret为0时，表示不使用一级索引块。（因为 block 0用来保存super block，它不可能被其他任何文件或目录使用，所以这么设计也是合理的）</p>
<p>显然，在题设中，最大可能的文件大小为使用一级间接数据块索引时，为(16 + 1KB/4B) * 1KB = 272KB。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://github.com/chyyuu/simple_os_book/blob/master/zh/chapter-4/what_is_thread.md" target="_blank" rel="noopener">【原理】线程的属性与特征分析</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/prothalamion-by-e-spenser/">
              
                  《英诗金库》I-53：Prothalamion, by E. Spenser
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-09
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Prothalamion<br>
作者：Edmund Spenser（爱德蒙·斯宾塞）<br>
出版年代：1599<br>
编注：此诗选自《皆大欢喜》第二幕第七场，诗中将大自然的善与人类的恶进行了对照。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Calm was the day, and through the trembling air<br>
Sweet-breathing Zephyrus<a href="#note1" id="note1ref"><sup>1</sup></a> did softly play—<br>
A gentle spirit, that lightly did delay<br>
Hot Titan’s beams, which then did glister fair;<br>
When I (whom sullen care,<br>
Through discontent of my long fruitless stay<br>
In princes’ court, and expectation vain<br>
Of idle hopes, which still do fly away<br>
Like empty shadows, did afflict my brain)<br>
Walk’d forth to ease my pain<br>
Along the shore of sliver-streaming Thames;<br>
Whose rutty<a href="#note2" id="note2ref"><sup>2</sup></a> bank, the which his river hems,<br>
Was painted all with variable flowers,<br>
And all the meads adorn’d with dainty gems<br>
Fit to deck maidens’ bowers,<br>
And crown their paramours<a href="#note3" id="note3ref"><sup>3</sup></a><br>
Against the bridal day, which is not long<a href="#note4" id="note4ref"><sup>4</sup></a>;<br>
Sweet Thames! run softly, till I end my song.</p>
<p>There in a meadow by the river’s side<br>
A flock of nymphs I chanced to espy,<br>
All lovely daughters of the flood thereby<a href="#note5" id="note5ref"><sup>5</sup></a>,<br>
With goodly greenish locks all loose untied<br>
As each had been a bride;<br>
And each one had a little wicker basket<br>
Made of fine twigs, entrailed<a href="#note6" id="note6ref"><sup>6</sup></a> curiously,<br>
In which they gather’d flowers to fill their flasket<a href="#note7" id="note7ref"><sup>7</sup></a>,<br>
And with fine fingers cropt full feateously<a href="#note8" id="note8ref"><sup>8</sup></a><br>
The tender stalks on high.<br>
Of every sort which in that meadow grew<br>
They gather’d some; the violet, pallid blue,<br>
The little daisy that at evening closes,<br>
The virgin lily and the primrose true,<br>
With store of vermeil<a href="#note9" id="note9ref"><sup>9</sup></a> roses,<br>
To deck their bridegrooms’ posies<br>
Against the bridal day, which was not long:<br>
Sweet Thames! run softly, till I end my song.</p>
<p>With that I saw two swans of goodly hue<br>
Come softly swimming down along the lee<a href="#note10" id="note10ref"><sup>10</sup></a>;<br>
Two fairer birds I yet did never see;<br>
The snow which doth the top of Pindus strow<br>
Did never whiter show,<br>
Nor Jove himself, when he a swan would be<br>
For love of Leda, whiter did appear;<br>
Yet Leda was (they say) as white as he,<br>
Yet not so white as these, nor nothing near;<br>
So purely white they were,<br>
That even the gentle stream, the which them bare,<br>
Seem’d foul to them, and bade his billows spare<br>
To wet their silken feathers, lest they might<br>
Soil their fair plumes with water not so fair,<br>
And mar their beauties bright,<br>
That shone as Heaven’s light<br>
Against their bridal day, which was not long;<br>
Sweet Thames! run softly, till I end my song.</p>
<p>Eftsoons<a href="#note11" id="note11ref"><sup>11</sup></a> the nymphs, which now had flowers their fill<a href="#note12" id="note12ref"><sup>12</sup></a>,<br>
Ran all in haste to see that silver brood<br>
As they came floating on the crystal flood;<br>
Whom when they saw, they stood amazed still<br>
Their wondering eyes to fill;<br>
Them seem’d<a href="#note13" id="note13ref"><sup>13</sup></a> they never saw a sight so fair<br>
Of fowls, so lovely, that they sure did deem<br>
Them heavenly born, or to be that same pair<br>
Which through the sky draw Venus’ silver team;<br>
For sure they did not seem<br>
To be begot of any earthly seed,<br>
But rather angels, or of angels’ breed;<br>
Yet were they bred of summer’s heat, they say,<br>
In sweetest season, when each flower and weed<br>
The earth did fresh array;<br>
So fresh they seem’d as day,<br>
Even as their bridal day, which was not long:<br>
Sweet Thames! run softly, till I end my song.</p>
<p>Then forth they all out of their baskets drew<br>
Great store of flowers, the honour of the field,<br>
That to the sense did fragrant odours yield,<br>
All which upon those goodly birds they threw<br>
And all the waves did strew,<br>
That like old Peneus’ waters they did seem<br>
When down along by pleasant Tempe’s shore<br>
Scatter’d with flowers, through Thessaly they stream,<br>
That they appear, through lilies’ plenteous store,<br>
Like a bride’s chamber-floor.<br>
Two of those nymphs meanwhile, two garlands bound,<br>
Of freshest flowers which in that mead they found,<br>
The which presenting all in trim array,<br>
Their snowy foreheads therewithal they crown’d;<br>
Whilst one did sing this lay<br>
Prepared against that day,<br>
Against their bridal day, which was not long:<br>
Sweet Thames! run softly, till I end my song.</p>
<p>‘Ye gentle birds! the world’s fair ornament,<br>
And Heaven’s glory, whom this happy hour<br>
Doth lead unto your lovers’ blissful bower,<br>
Joy may you have, and gentle heart’s content<br>
Of your love’s couplement;<br>
And let fair Venus, that is queen of love,<br>
With her heart-quelling son upon you smile,<br>
Whose smile, they say, hath virtue to remove<br>
All love’s dislike, and friendship’s faulty guile<br>
For ever to assoil.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="戴镏龄-译"><a class="markdownIt-Anchor" href="#戴镏龄-译"></a> 戴镏龄 译</h3>
<p>宁静的日子呀，阵阵清风<br>
轻微地吹拂，在空中飘荡，<br>
大气柔和，使晴空的骄阳&lt;&gt;<br>
明媚温煦，不致烧灼碧空；<br>
我正感不受用，<br>
由于淹留王廷常是失意，<br>
期望终成梦想，无从实现，&lt;&gt;<br>
冀求的东西都徒然飞逝，<br>
无影无踪，心情苦不堪言，<br>
于是散步排遣，<br>
沿着清凌凌的泰晤士河，<br>
两岸上发出稠密的枝柯，<br>
各种奇卉，无不鲜花怒放，<br>
青草地上珠光宝气繁多，<br>
宜于装饰闺房，<br>
插在情人头上，<br>
迎接佳期，屈指就在目下，<br>
可爱的河，轻轻流到歌罢。</p>
<p>河边上呈现出一块草坪，<br>
那儿我瞥见仙女一大群，<br>
好姑娘，在邻近川泽成长，<br>
头上飘散着美丽的青鬓，<br>
好象新人出聘。<br>
她们都携着一只小柳筐，<br>
细条做料子，精工编织成，<br>
用来采集花枝，满满盛装，<br>
纤纤手指，摘取巧妙认真，<br>
顶部嫩的花梗。<br>
草原上这样那样花灿烂，<br>
每样采一些，紫罗兰淡蓝，<br>
黄昏时合上眼睛的雏菊，<br>
以及百合纯洁，樱草烂漫，<br>
嫣红玫瑰成束，<br>
献作新郎礼物，<br>
迎接佳期，屈指就在目下，<br>
可爱的河，轻轻流到歌罢。</p>
<p>接着有漂亮的天鹅一双，&lt;&gt;<br>
飘飘然在水上顺流下游，<br>
平生初见，最美的鸟两头，<br>
雪洒在坪达山的高峰上，&lt;&gt;<br>
输掉白的光芒；<br>
宙父变做天鹅追求妮黛，<br>
也比不上这对赛粉欺银；&lt;&gt;<br>
论白，宙父、妮黛难分好坏，<br>
但是都难和这一双接近，<br>
她们异常白净。<br>
轻柔的流水，负载着她们，<br>
似嫌形秽，戒浪花莫溅喷<br>
她们的洁羽，那样就必然<br>
使浑水给她们带来污痕，<br>
让太阳般美颜<br>
因此添上缺陷，<br>
迎接佳期，屈指就在目下，<br>
可爱的河，轻轻流到歌罢。</p>
<p>仙女采花不久，收获丰满，<br>
奔去看这对洁白的俦&lt;&gt;侣，<br>
正泛泛而来，清水上漂浮，<br>
姑娘见了，无不感到茫然，<br>
惊得直瞪两眼；<br>
这样的美禽，似从未见过，<br>
多可爱呀，一定生在天堂，<br>
或是给爱神挽车的双鹅，&lt;&gt;<br>
挽她的车穿过云霄之上；<br>
她们绝对不象<br>
我们这个尘世间的产物，<br>
而是天使，或是同一种族。<br>
据说她们是在夏季出生，<br>
和煦时节，花草枝叶扶疏，<br>
大地新装披身，<br>
好似旭日东升，<br>
恰似佳日，屈指就在目下，<br>
可爱的河，轻轻流到歌罢。</p>
<p>仙女从筐里取出许多花，<br>
这些都是田野上的光辉，<br>
发散出扑鼻的阵阵香味；<br>
她们把花撒向好鸟身上，<br>
水波吐秀流芳，<br>
象泌罗斯江水流声活活，&lt;&gt;<br>
沿着丹丕的可喜山谷间，<br>
满载花枝，从帖撒利流过；<br>
有数不尽的百合花，乍看，<br>
象香闺的铺板。<br>
这时其中两位仙女挑选</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p><a href="#bib1" id="bib1ref"><sup>[1]</sup></a></p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> As You Like It. <a href="https://en.wikipedia.org/wiki/As_You_Like_It" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/As_You_Like_It</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>Zephyrus</em>: ‘the west wind.’（西风。）<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>rutty</em>: ‘abounding in ruts.’（查词典，“rutty”一词为“遍地车辙的”之义，但看译文，此处似乎译作“有很多枝干”的意思了？）<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>paramours</em>: ‘lovers’.（情人们。）<br>
<a id="note4" href="#note4ref"><sup>4</sup></a><em>is not long</em>: ‘is close at hand.’（近在眼前了。）<br>
<a id="note5" href="#note5ref"><sup>5</sup></a><em>the flood thereby</em>: ‘the stream which ran beside them.’（他们身边流过的小溪。）<br>
<a id="note6" href="#note6ref"><sup>6</sup></a><em>entrailed</em>: ‘entwined.’（相互缠绕的。）<br>
<a id="note7" href="#note7ref"><sup>7</sup></a><em>flasket</em>: ‘a long shallow basket’ (Johnson); the word is a diminutive of ‘flask.’（长而浅的篮子；对“flask”的爱称。）<br>
<a id="note8" href="#note8ref"><sup>8</sup></a><em>full feateously</em>: ‘very skillfully or elegantly.’（非常灵巧而优雅地。）<br>
<a id="note9" href="#note9ref"><sup>9</sup></a><em>vermeil</em>: a poetic form of ‘vermilion.’（“朱红色”的另一种写法。）<br>
<a id="note10" href="#note10ref"><sup>10</sup></a><em>the lee</em>: here and in L 115 below, Spenser uses this word for ‘stream’ or ‘current.’（在此处和下面的第115行，斯宾塞用这个词来表示“溪流”或“水流”之义。）<br>
<a id="note11" href="#note11ref"><sup>11</sup></a><em>Eftsoon</em>: ‘soon after.’（很快。）<br>
<a id="note12" href="#note12ref"><sup>12</sup></a><em>had flowers their fill</em>: ‘flowers, as many as they wanted.’（已经拿了尽可能多的花朵。）<br>
<a id="note13" href="#note13ref"><sup>13</sup></a><em>Them seem’d</em>: ‘it seemed to them.’（在她们看来。）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/戴镏龄/"><i class="fas fa-hashtag fa-fw"></i>戴镏龄</a>
                
                    <a href="/tags/E-Spencer/"><i class="fas fa-hashtag fa-fw"></i>E.Spencer</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/pack-clouds-away-and-welcome-day-by-t-heyWood/">
              
                  《英诗金库》I-52：Pack, clouds, away, and welcome day, by T. HeyWood
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-06
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Pack, clouds, away, and welcome day<br>
作者：Thomas Heywood（托马斯·海伍德）<br>
出版年代：1608<br>
编注：海伍德（Thomas Heywood，1570?-1641），英国剧作家。本诗选自他以罗马神话为题材写成的戏剧《鲁克丽丝受辱记》第四幕第六场。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Pack, clouds, away, and welcome day,<br>
With night we banish sorrow;<br>
Sweet air blow soft, mount lark aloft<br>
To give my Love good-morrow<a href="#note1" id="note1ref"><sup>1</sup></a>!<br>
Wings from the wind to please her mind<br>
Notes from the lark I’ll borrow;<br>
Bird prune thy wing, nightingale sing,<br>
To give my Love good-morrow;<br>
To give my Love good-morrow<br>
Notes from them all I’ll borrow.</p>
<p>Wake from thy nest, Robin-red-breast,<br>
Sing birds in every furrow;<br>
And from each bill, let music shrill<br>
Give my fair Love good-morrow!<br>
Blackbird and thrush in every bush,<br>
Stare<a href="#note2" id="note2ref"><sup>2</sup></a>, linnet, and, cock-sparrow,<br>
You pretty elves, amongst yourselves<br>
Sing my fair Love good-morrow!<br>
To give my Love good-morrow<br>
Sing birds in every furrow!</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="戴镏龄-译"><a class="markdownIt-Anchor" href="#戴镏龄-译"></a> 戴镏龄 译</h3>
<p>云，散开吧，迎接白天，<br>
夜尽了，驱走忧伤；<br>
朝气轻吹，云雀升起，<br>
给我爱早安送上！<br>
我要借云雀的歌声，<br>
趁风娱她的心肠；<br>
鸟儿整翅，流莺请啭，<br>
给我爱早安送上！<br>
要借大家的歌声，<br>
给我爱早安送上。</p>
<p>知更鸟从巢里醒起，<br>
田沟上鸟语响亮；<br>
每张鸟喙鸣声清新，<br>
给我爱早安送上！<br>
枝头的乌鸦和画眉，<br>
八哥、红鸟、麻雀郎，<br>
可爱的小精灵们，大家<br>
给我爱早安送上！<br>
田沟上鸟语响亮，<br>
给我爱早安送上。</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>这次又可以说很多东西了。这首诗倒是很欢快，但是看到《鲁克丽丝受辱记》这个来源，就觉得哪里不太对劲。</p>
<h3 id="托马斯海伍德"><a class="markdownIt-Anchor" href="#托马斯海伍德"></a> 托马斯·海伍德</h3>
<p>海伍德是一位著名的英国剧作家、演员和文学家。他的主要贡献是在伊丽莎白一世晚期和詹姆斯一世时期的剧院里上演的剧本。他最知名的作品是一部家庭悲剧，《被善意所杀的女人》（A Woman Killed with Kindness），这部悲剧最初上演于1603年。他是一位多产的作家，据说创作了220部戏剧，不过现在只有一小部分留下来了。很可惜，<em>The Rape of Lucrece</em> 在维基百科上并没有词条。<a href="#bib1" id="bib1ref"><sup>[1]</sup></a></p>
<h3 id="鲁克丽丝受辱记"><a class="markdownIt-Anchor" href="#鲁克丽丝受辱记"></a> 《鲁克丽丝受辱记》</h3>
<p>总之据说是根据莎士比亚的作品改编的。我找到了一个似乎是古代拼写的版本<a href="#bib2" id="bib2ref"><sup>[2]</sup></a>，不过没有分场和幕，非常难看。随后我又在Internet Archive上找到了现代拼写的版本<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>，还有一部分介绍。至于这个剧本的全部内容，我觉得可以开一篇<a href="/post/the-rape-of-lucrece-by-t-heywood">新文章</a>了。（现在还没写完，如果写完了会补上）简单来说，它的剧情和莎士比亚的《鲁克丽丝受辱记》基本类似，但是扩展了很多额外的情节；剧本以塞克斯图斯（即塔昆，不过此剧本中称他为Sextus，所以姑且换个称呼）和布鲁图斯在决斗中双双被杀结束。</p>
<p>这首诗选自第四幕第六场，此时塞克斯图斯刚刚从柯拉廷城堡中仓皇逃出，次日清早，众人在阿狄亚城前时，柯拉廷唱起了这首歌。听起来实在是太过讽刺了。大概是强调了一种悲剧的氛围吧。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> Thomas Heywood. <a href="https://en.wikipedia.org/wiki/Thomas_Heywood" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Thomas_Heywood</a><br>
<a id="bib2" href="#bib2ref"><sup>[2]</sup></a> The rape of Lucrece a true Roman tragedie. <a href="https://quod.lib.umich.edu/e/eebo/A03244.0001.001/1:3?rgn=div1;view=fulltext" target="_blank" rel="noopener">https://quod.lib.umich.edu/e/eebo/A03244.0001.001/1:3?rgn=div1;view=fulltext</a><br>
<a id="bib3" href="#bib2ref"><sup>[3]</sup></a> Thomas Heywood. <a href="https://archive.org/details/heywood00heywiala" target="_blank" rel="noopener">https://archive.org/details/heywood00heywiala</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>good-morrow</em>: ‘good morning.’（早上好。）<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>Stare</em>: ‘starling,’ which is a diminutive of the former.（“stare”是对椋鸟的爱称。）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/戴镏龄/"><i class="fas fa-hashtag fa-fw"></i>戴镏龄</a>
                
                    <a href="/tags/T-Heywood/"><i class="fas fa-hashtag fa-fw"></i>T.Heywood</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/cupid-and-campaspe-by-j-lyly/">
              
                  《英诗金库》I-51：Cupid and Campaspe, by J. Lyly
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-05
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Cupid and Campaspe（爱神和康帕丝）<br>
作者：John Lyly（约翰·黎里）<br>
出版年代：1584<br>
编注：黎里（John Lyly，1554?-1806），英国文艺复兴时代的剧作家，他第一个用散文体代替诗体创作喜剧。本诗选自喜剧《康帕丝》第三幕第五场，诗中形象而活泼地描绘了美和爱的魅力，这种魅力甚至支配了爱神。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Cupid and my Campaspe play’d<br>
At cards for kisses; Cupid paid:<br>
He stakes his quiver, bow, and arrows,<br>
His mother’s doves, and team of sparrows;<br>
Loses them too; then down he throws<br>
The coral of his lip, the rose<br>
Growing on’s<a href="#note1" id="note1ref"><sup>1</sup></a> cheek (but none knows how);<br>
With these, the crystal<a href="#note2" id="note2ref"><sup>2</sup></a> of his brow,<br>
And then the dimple of his chin;<br>
All these did my Campaspe win:<br>
At last he set<a href="#note3" id="note3ref"><sup>3</sup></a> her both his eyes—<br>
She won, and Cupid blind did rise.<br>
O Love! has she done this to thee?<br>
What shall, alas! become of me?</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="戴镏龄-译"><a class="markdownIt-Anchor" href="#戴镏龄-译"></a> 戴镏龄 译</h3>
<p>爱神和康帕丝斗牌<a href="#note4" id="note4ref"><sup>4</sup></a><br>
赌接吻，爱神被击败；<br>
他又赌箭筒，弓和矢，<br>
母亲的麻雀和鸽子；<a href="#note5" id="note5ref"><sup>5</sup></a><br>
输了，摔下嘴唇珊瑚，<br>
两颊上的玫瑰花株，<br>
泛起的那无名面红；<br>
加上眉宇晶亮玲珑，<br>
还有下巴上的酒涡，<br>
通通被康帕丝赢走。<br>
最后，他拿两眼去赌，<br>
又输了，他变成矇瞽<a href="#note6" id="note6ref"><sup>6</sup></a>，<br>
爱神，她待你是这样？<br>
哎，什么是我的下场？</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>这首诗可聊的东西又非常的多而庞杂，只能慢慢说了，看来要花去今晚的不少时间。（虽然明天还有重要的事情，但是先娱乐一下再说……）</p>
<h3 id="约翰黎里其人"><a class="markdownIt-Anchor" href="#约翰黎里其人"></a> 约翰·黎里其人</h3>
<p>约翰·黎里<a href="#bib1" id="bib1ref"><sup>[1]</sup></a>现在似乎不是很有名了（而且这首诗在网上也没有什么人讨论），不过可以从维基百科看出，他是个当时很重要的剧作家和作家，而且风格还被命名了，叫做“绮丽体”（euphuism）。这听起来就很浮夸了，是人们通常会轻视的风格类型。不过，看了维基之后，我发现，他这么写是意有所指的。（不过这部分来自剧本的维基，之后再说）</p>
<p>生平实在是懒得（或者说没时间）翻译了。粗粗看了几眼，发现了一点有趣的东西。</p>
<blockquote>
<p>After he left Oxford, where he had the reputation of “a noted wit”, Lyly seems to have attached himself to Lord Burghley. “This noble man”, he writes in the Glasse for Europe, in the second part of Euphues (1580), “I found so ready being but a straunger to do me good, that neyther I ought to forget him, neyther cease to pray for him, that as he hath the wisdom of Nestor, so he may have the age, that having the policies of Ulysses he may have his honor, worthy to lyve long, by whom so many lyve in quiet, and not unworthy to be advaunced by whose care so many have been preferred.”</p>
</blockquote>
<p>黎里在此处狂热地赞美了伯利勋爵（Lord Burghley）。实际上，他就是威廉·塞西尔，之前提到过的<a href="/post/if-women-could-be-fair-and-yet-not-fond-by-e-vere">维尔</a>的抚养者兼岳父。之后黎里似乎还和维尔闹了一点别扭。这可真是非常有趣了。</p>
<p>后来，总之，黎里的剧本对莎士比亚的剧作，特别是浪漫喜剧，起到了很大的影响。</p>
<h3 id="康帕丝"><a class="markdownIt-Anchor" href="#康帕丝"></a> 康帕丝</h3>
<p>传说中，康帕丝是亚历山大大帝的情妇。古代被认为最杰出的画家阿培里兹（Apelles）为她画像。老普林尼在《自然史》中声称，接下来发生了这样的事情：亚历山大看到了肖像惊人的美丽，意识到画家比他更能欣赏康帕丝的美丽，也更爱她；于是便留下肖像，却将康帕丝让给阿培里兹。当然，这整件事基本都是传说。后来康帕丝成为了文学作品中情妇的代名词。<a href="#bib2" id="bib2ref"><sup>[2]</sup></a></p>
<p>我对这个故事的看法是：嗯，除了又一次感慨老普林尼的不靠谱之外，我觉得亚历山大和阿培里兹都没怎么尊重康帕丝，不过这样就又转到女权话题了。当然，这个故事提出了一个哲学问题：创作者的地位是否一定高于欣赏者？或者不如先问，这个故事中的画家到底能不能算是一位创作者？他能够画出康帕丝惊人的美，是因为他的技艺高超，因为他深爱绘画的对象，还是因为康帕丝本人太美了，而他的画只是反映出了这一特质？这种描摹者和被描摹对象的关系是否是正常的？唉，在这些问题中，康帕丝都是完全的客体，与一株漂亮的植物无异，真是令人感到不适。</p>
<h3 id="康帕丝的剧情"><a class="markdownIt-Anchor" href="#康帕丝的剧情"></a> 《康帕丝》的剧情</h3>
<p>这部剧本没有太多逻辑和剧情可言（据说是这样的），它的可取之处主要在于华丽的语言。总之，发生了这样的事：除了上面的传说之外，亚历山大还和第欧根尼、柏拉图、亚里士多德等哲学家探讨了许多问题。不过，至少康帕丝不再是完全的植物了：她也爱上了阿培里兹。亚历山大成全了他们，然后继续征战去了。</p>
<blockquote>
<p>黎里在《康帕丝》中没有进行任何道德或伦理说教——因而突破了早期戏剧的“道德剧”（morality play）传统。和他之后的大部分剧作也不同的是，《康帕丝》也避开了讽喻。事实上，《康帕丝》是一个纯粹地为娱乐而讲述的浪漫历史故事。黎里对中世纪思维模式的这种背离为之后的（且更好的）作家提供了一种新的模板。这部剧本被称为当时的“第一部浪漫戏剧”。<a href="#bib3" id="bib3ref"><sup>[3]</sup></a></p>
</blockquote>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我只在雅虎问答<a href="#bib4" id="bib4ref"><sup>[4]</sup></a>上找到了一篇普通的分析，大意和这首诗的编注相同：</p>
<ul>
<li>爱神为了赢得康帕丝的吻，甚至愿意失去自己身上神性的部分</li>
<li>连爱神都会屈服于爱的魅力，我这种凡人当然对爱更无能为力了</li>
<li>英国贵族女性一直都很喜欢打牌</li>
</ul>
<p>我倒是觉得，说“连爱神都会屈服于爱的魅力”这种话，虽然和神话是符合的，却不太符合逻辑：爱神本身是“爱”的人格化，那堕入爱情的爱神算是什么呢？对此，我的看法是，爱神代表了一种更加理性、更加神圣的爱，而他屈服于的这种“爱”是感性的痴迷和疯狂。（这听起来像是《会饮》里的分析了，什么有两个爱神之类的。）当然也可以说，把爱神作为主角之一只是为了强调爱情的魅力极其的大。</p>
<p>实际上，我从欢快活泼的表象中看到了疯狂、恐怖和残忍。疯狂上面已经说过了。至于恐怖……丢掉眼睛难道还不算恐怖吗？至少在我的想象中，这是令人惧怕的。最糟糕的是，康帕丝要这些东西做什么呢？爱神身上所有美的部分，甚至包括眼睛……如果她是需要小美人鱼声音的邪恶巫婆，那这倒是可以理解；但她已经非常美丽了，拿走这些，似乎只是为了在赌博中证明自己的美，是一种纯粹的残忍。或者说，诗人内心中认为女性都是这样残忍的，她们会玩弄别人的感情而不自知。</p>
<p>这些分析大概太阴暗了。事实上，之所以会有这种想法，是因为这首诗让我想起了王尔德的《快乐王子》。王子失去了他的眼睛、剑柄和身上覆盖的金叶子，但那是为了帮助穷人；康帕丝是为了什么呢？但是，即使快乐王子的行为更合理，这个童话仍然让我感到非常不适。我想了很久，但是仍然不知道该如何表达，不妨先算了吧，已经快凌晨三点了。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> John Lyly. <a href="https://en.wikipedia.org/wiki/John_Lyly" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/John_Lyly</a><br>
<a id="bib2" href="#bib2ref"><sup>[2]</sup></a> Campaspe. <a href="https://en.wikipedia.org/wiki/Campaspe" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Campaspe</a><br>
<a id="bib3" href="#bib3ref"><sup>[3]</sup></a> Campaspe (play). <a href="https://en.wikipedia.org/wiki/Campaspe_(play)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Campaspe_(play)</a><br>
<a id="bib4" href="#bib4ref"><sup>[4]</sup></a> Can anyone tell me some literary critiques of this poem. <a href="https://au.answers.yahoo.com/question/index?qid=20071110080625AARalD8&amp;guccounter=1#" target="_blank" rel="noopener">https://au.answers.yahoo.com/question/index?qid=20071110080625AARalD8&amp;guccounter=1#</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>on’s</em>: ‘on his.’<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>crystal</em>: ‘transparent clearness.’（透明清澈。）<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>set</em>: ‘staked.’（赌上）<br>
<a id="note4" href="#note4ref"><sup>4</sup></a>爱神指维纳斯之子丘比特（Cupid）；康帕丝（Campaspe，又译作坎巴斯帕）传说是古希腊亚历山大皇帝的爱妃，以美貌著称。——译者<br>
<a id="note5" href="#note5ref"><sup>5</sup></a>麻雀和鸽子等是献给维纳斯的鸟，为她拉车，此外，还有燕子和天鹅。——译者<br>
<a id="note6" href="#note6ref"><sup>6</sup></a>矇瞽（méng gǔ），盲人。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/戴镏龄/"><i class="fas fa-hashtag fa-fw"></i>戴镏龄</a>
                
                    <a href="/tags/J-Lyly/"><i class="fas fa-hashtag fa-fw"></i>J.Lyly</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/tell-me-where-is-fancy-bred-by-w-shakespeare/">
              
                  《英诗金库》I-50：Tell me where is fancy bred, by W. Shakespeare
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Madrigal（情歌）<br>
作者：William Shakespeare（威廉·莎士比亚）<br>
出版年代：1596<br>
编注：此诗选自《威尼斯商人》第三幕第二场。标题《情歌》系原编者所加。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Tell me where is Fancy<a href="#note1" id="note1ref"><sup>1</sup></a> bred,<br>
Or in the heart, or in the head?<br>
How begot, how nourishèd?<br>
Reply, reply.<br>
It is engender’d in the eyes,<br>
With gazing fed; and Fancy dies<a href="#note2" id="note2ref"><sup>2</sup></a><br>
In the cradle where it lies:<br>
Let us all ring Fancy’s knell;<br>
I’ll begin it, –Ding, dong, bell.<br>
–Ding, dong, bell.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="朱生豪-译"><a class="markdownIt-Anchor" href="#朱生豪-译"></a> 朱生豪 译</h3>
<p>告诉我爱情生长在何方？<br>
还是在脑海？还是在心房？<br>
它怎样发生？它怎样成长？<br>
回答我，回答我。<br>
爱情的火在眼睛里点亮，<br>
凝视是爱情生活的滋养，<br>
它的摇篮便是它的坟堂。<br>
让我们把爱的丧钟鸣响。<br>
玎珰！玎珰！<br>
玎珰！玎珰！</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>本来看了这首诗之后没有什么感想，只是觉得“Ding, dong, bell”听起来很像<a href="/post/full-fathom-five-by-w-shakespeare">Full Fathom Five</a>里面的丧钟。不过其实这首诗要欢乐得多。</p>
<p>……</p>
<p>因为我发现了一首这首诗的非常棒的改编歌曲！（至少是我觉得很棒啦……）就是Matthew Harris<a href="#bib1" id="bib1ref"><sup>[1]</sup></a>的改编版本。在youtube上有一个国立台湾大学的演唱版本<a href="#bib2" id="bib2ref"><sup>[2]</sup></a>，我认为非常棒。网易云音乐上也有一个版本<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>，虽然没有那么好听，不过胜在方便，所以我现在正在单循着这首歌。</p>
<p>背景简介我就直接摘录别人的说法了。</p>
<blockquote>
<p>本曲出自於《威尼斯商人》(The Merchant of Venice)，第三幕之第二景，是莎劇中涉及音樂較多的一齣戲劇。女主角波西亞(Portia)繼承了父親的龐大的遺產，追求者絡繹不絕；波西亞的父親臨終前規定求婚者必須從三個分別由金、銀、鉛製成的盒子中，挑出一個內藏波西亞畫像的，才能與她成婚。<br>
這日，波西亞的意中人巴薩尼歐(Bassanio)前來求婚，但礙於家規，波西亞不能向巴薩尼歐吐露箱內實情，心中焦躁可想而知，便讓家僕哼起這首《告訴我愛情來自何方》作為答案的暗示。<br>
歌詞中的fancy意指對華美外表的迷戀，暗示巴薩尼歐勿以貌取物，因為美麗的事物總是倏忽而逝。在金、銀、鉛三個盒子中，只有鉛盒最為樸實無華；此外前三行的末字的尾韻分別為bred[εd]、head[εd]、nourished[εd]，和鉛(lead)一字不謀而合！聰明的巴薩尼歐自能領會其弦外之音，毫不猶豫的選擇了鉛盒，抱得美人歸。<a href="#bib4" id="bib4ref"><sup>[4]</sup></a></p>
</blockquote>
<p>先说说我直接的感想吧。我觉得，合唱和轮唱为这首歌添上了一种神圣而欢乐的氛围。听了这首歌，我才想到，鲍西亚让仆人唱起这首歌时，内心应该是充满着急切和爱情的甜蜜的。“Reply, Reply”就像是对巴萨尼奥的急切的提示：我对你的爱情已经在我的眼中点亮了，请你切勿以貌取物，选中错误的盒子，辜负我的一片苦心。这听起来固然很美，可是却带上了一丝嘲讽：你们两人之间的爱情也就是这么迅速点亮起来的啊（不管是在脑海还是心房，都是通过眼睛，这点没什么问题）。我想鲍西亚自己也明白这一点，“让我们把爱的丧钟鸣响”。然而，这么一想，即使她知道爱情是如此易变的，仍然愿意勇敢地投身其中。</p>
<p>……以上全部都是脑补。稍微翻了翻剧本，鲍西亚和巴萨尼奥两人确实是一见钟情的。不过我想，他们是因为性情投合，三观合拍而迅速相恋的（而不是看脸），至少为他们我就不用担心了。但是我觉得这首歌仍然是带有一点忧郁的。即使看的是个人品质，那仍然是通过眼睛的啊，有可能会看错的。</p>
<p>不妨在此翻译一个更严肃的分析。</p>
<blockquote>
<p>就像很多其他的莎士比亚的诗歌那样，这首歌在表面上是浪漫迷人的，潜台词却是苦涩而反讽的。此处“fancy”一词意为“爱”，却在“take a fancy”（喜欢上，爱上）的意义中暗示着肤浅的爱慕和痴心。这首歌提出了一个哲学问题：爱情（fancy）到底从何而来？爱情到底是感性的（“在脑海”）还是理性的（“在心房”）？这首歌对此的回答是：爱情来源于眼睛——既不是脑海也不是心房。然而，爱情也会在那里消亡。“lie”一词具有双重含义，暗示着，爱情既居住在它的“摇篮”（研究）里，又是具有欺骗性的，因为这样的爱情是基于外在的美貌，而非内心的品质的。这首歌又进一步扩展了问题：当人们相爱，爱情是如何维持下去的呢？歌中对此的回应不多，但它确实对浪漫爱情短暂的性质进行了评价，声称“它的摇篮便是它的坟堂”。“丧钟”一词特指了葬礼时鸣响的钟声，表示有人死去了。在这里，被哀悼的人是人格化的爱情；丧钟为爱情的“死亡”而敲响。<a href="#bib5" id="bib5ref"><sup>[5]</sup></a></p>
</blockquote>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> Matthew Harris. <a href="http://matthewharrismusic.com/news.html" target="_blank" rel="noopener">http://matthewharrismusic.com/news.html</a><br>
<a id="bib2" href="#bib2ref"><sup>[2]</sup></a> Tell Me Where is Fancy Bred (Matthew Harris) - National Taiwan University Chorus. <a href="https://www.youtube.com/watch?v=lQ59JqWP2aU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lQ59JqWP2aU</a><br>
<a id="bib3" href="#bib3ref"><sup>[3]</sup></a> Shakespeare Songs: Tell Me Where Is Fancy Bred. <a href="https://music.163.com/#/song?id=538751916" target="_blank" rel="noopener">https://music.163.com/#/song?id=538751916</a><br>
<a id="bib4" href="#bib4ref"><sup>[4]</sup></a> Tell Me Where is Fancy Bred《告訴我愛情來自何方》. <a href="http://blog.xuite.net/kiki79426/wretch/104895822-Tell+Me+Where+is+Fancy+Bred%E3%80%8A%E5%91%8A%E8%A8%B4%E6%88%91%E6%84%9B%E6%83%85%E4%BE%86%E8%87%AA%E4%BD%95%E6%96%B9%E3%80%8B" target="_blank" rel="noopener">http://blog.xuite.net/kiki79426/wretch/104895822-Tell+Me+Where+is+Fancy+Bred《告訴我愛情來自何方》</a><br>
<a id="bib5" href="#bib5ref"><sup>[5]</sup></a> Tell Me Where is Fancy Bred. <a href="http://shakesongs.com/tell-me-where-is-fancy-bred/" target="_blank" rel="noopener">http://shakesongs.com/tell-me-where-is-fancy-bred/</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>Fancy</em>: ‘love.’<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>Fancy dies</em>, etc.: love, which is born in the eyes, may die there before coming to maturity; which means no more than that the eyes can show the birth and speedy death of love.（爱情生于眼中，也可能会在成熟之前在眼中消亡；意思是说，除了眼睛，没有什么东西能够更深刻地反映出爱情的发生和迅速的消亡。）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/W-Shakespeare/"><i class="fas fa-hashtag fa-fw"></i>W.Shakespeare</a>
                
                    <a href="/tags/朱生豪/"><i class="fas fa-hashtag fa-fw"></i>朱生豪</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/archives/2018/page/24/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  25 / 29
              </p>
              
                  <a class="next" rel="next" href="/archives/2018/page/26/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->



    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
