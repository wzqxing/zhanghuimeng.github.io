<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018'}
    </script>




  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/care-charmer-sleep-by-s-daniel/">
              
                  《英诗金库》I-35：Care-charmer Sleep, by S. Daniel
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-15
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Care-charmer Sleep, son of the sable Night<br>
作者：Samuel Daniel（塞缪尔·丹尼尔）<br>
出版年代：1592<br>
编注：塞缪尔·丹尼尔（Samuel Daniel，1562-1619），英国宫廷诗人。这首诗系他的十四行诗集《迪莉娅》第五一首。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Care-charmer Sleep, son of the sable Night,<br>
Brother to Death, in silent darkness born,<br>
Relieve my languish, and restore the light;<br>
With dark forgetting of my care return.</p>
<p>And let the day be time enough<a href="#note1" id="note1ref"><sup>1</sup></a> to mourn<br>
The shipwreck of my ill-adventured youth:<br>
Let waking eyes suffice to wail their scorn<a href="#note2" id="note2ref"><sup>2</sup></a>,<br>
Without the torment of the night’s untruth.</p>
<p>Cease, dreams, the images of day-desires,<br>
To model forth the passions of the morrow;<a href="#note3" id="note3ref"><sup>3</sup></a><br>
Never let rising Sun approve you liars<a href="#note4" id="note4ref"><sup>4</sup></a><br>
To add more grief to aggravate my sorrow:</p>
<p>Sill let me sleep, embracing clouds<a href="#note5" id="note5ref"><sup>5</sup></a> in vain,<br>
And never wake to feel the day’s disdain.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="付勇林-译"><a class="markdownIt-Anchor" href="#付勇林-译"></a> 付勇林 译</h3>
<p>驱愁的睡神呵，漆黑的夜神之子，<br>
你，死神的胞弟，在幽暗中诞生，<br>
祛除我的愁思吧，让光明复归故里；<a href="#note6" id="note6ref"><sup>6</sup></a><br>
复归故里，与忧愁悄然辞行。</p>
<p>悠悠白日已足以让我哀吟<br>
人生沉浮，青春时荒谬的冒险：<br>
睁着眼已够去泣诉世人的薄情，<br>
就别让夜的虚伪来将我磨难。</p>
<p>梦啊，你这白日欲望的幻像，<br>
请别再把来日的痛苦产生，<br>
别让东升的朝阳赞赏你说谎<br>
使我旧伤未除又添上了新恨：</p>
<p>还让我睡吧，徒劳地拥抱幻云，<br>
别让我醒来去领受白日的欺凌。</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>作为一名诗人，塞缪尔·丹尼尔的生活似乎很无趣。他生于一个受人尊敬的家庭，并成为了伊丽莎白一世和詹姆斯一世统治时期最成功的作家之一。这首诗来自诗集《迪莉娅》，主题倒是很平常：一个人在追求一个姑娘，并因为她的冷漠而悲伤。这是丹尼尔的第一本公开的著作，出版于1592年。整本书读起来不像是反映了诗人生活中的什么大事或痛苦，而仅仅是在跟随一种诗歌传统而已。<a href="#bib1" id="bib1ref"><sup>[1]</sup></a>事实上， 这本书被献给“To the right honourable the Ladie <em>Mary</em>, Countesse of Pembroke”，虽然我也不知道这位女士是谁。<a href="#bib2" id="bib2ref"><sup>[2]</sup></a></p>
<p>我觉得这个评价对这首诗十分适当。<a href="http://www.cieliterature.com/care-charmer-sleep/" target="_blank" rel="noopener">这个链接</a>里有对这首诗的详细解释（详细到烦）。总之，主题就是，诗人很爱一个女人，但是这个人并不爱他，以至于他觉得十分悲惨，希望到梦里寻求安慰（而不是重复白天的痛苦），甚至想长睡不醒算了。睡神被人格化了，作者祈求他的安慰，但这位神的力量显然是很有限的（即使不带来更多的痛苦，快乐也是虚幻的），所以他悲伤得想死了，也许死神更能解决他的问题。</p>
<p>“Samuel Daniel had an eminently contemplative genius which might have anticipated the sonnet as it is in Wordsworth, but which the fashion of the day confined to the not wholly suitable subject of Love. In the splendid Care-charmer Sleep … he continued, as will be seen, to put his subject under the influence of his prevailing faculty.”（塞缪尔·丹尼尔卓越的冥想天才可能使得他像华兹华斯一样对这首十四行诗有了过高的期望，但当时的风气将这种天才限制在了一个不完全合适的关于爱情的主题上。在这首出色的诗（Care-charmer Sleep）中，他继续将这一主题置于他流行的才能的影响下。） (George Saintsbury, History of Elizabethan Literature, 1887.)<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>我觉得这个评价是比较合理的。这首诗的情感无疑是真实的，但主题却未必需要局限在爱情之下。不过如何看出这首诗是讲爱情的呢？其实，脱离背景之后，看不出来。而且诗的普世性变得更强了。这大概就是它是一首好诗的缘故吧。或者这里说的风气也包括把睡神当成一个神去祈祷这种文风。现代人就不会这么写作了。</p>
<p>我挺喜欢“And let the day be time enough to mourn\The shipwreck of my ill-adventured youth”这句的，让我想起了Metallica的《The Unforgiven III》这首歌。整体氛围都很像。</p>
<p>整首诗的氛围也让我想起了很多其他的歌，比如这首。</p>
<blockquote>
<p>I’ve seen the devil in a smile<br>
I found salvation in a vile<br>
My happing ending<br>
Exists only in my dreams<br>
- <em>My Suffering</em>, Dead by Sunrise</p>
</blockquote>
<p>还有这首。</p>
<blockquote>
<p>Is that a light at the end of the tunnel<br>
That I see I see please let it be but don’t<br>
Wake me till the morning after<br>
Wake me till the morning after<br>
Wake me till the morning after<br>
Oh I’m so tired there has got to be an end<br>
to the pain I feel when I’m<br>
awake and alive alive alive<br>
alive and I’m dreaming<br>
- <em>Morning After</em>, Dead By Sunrise</p>
</blockquote>
<p>所以，现代人仍然经常有这样的感情，只是不会再这样写出来了而已。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> Care-charmer Sleep. <a href="http://www.cieliterature.com/care-charmer-sleep/" target="_blank" rel="noopener">http://www.cieliterature.com/care-charmer-sleep/</a><br>
<a id="bib2" href="#bib2ref"><sup>[2]</sup></a> <a href="http://www.potw.org/archive/potw110.html" target="_blank" rel="noopener">http://www.potw.org/archive/potw110.html</a><br>
<a id="bib3" href="#bib3ref"><sup>[3]</sup></a> Care-Charmer Sleep, Son of the Sable Night <a href="http://www.bartleby.com/331/582.html" target="_blank" rel="noopener">http://www.bartleby.com/331/582.html</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>let the day be time enough</em>, etc.: i.e. let not my sleep be but a continuation of my waking sorrows with all the added exaggerations of dreamland.（请不要在我的梦乡中继续清醒时的不幸，又加上幻境的夸大其词。）<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>their scorn</em>: ‘the scorn in which they see I am held.’（它们看到我如何被轻蔑。）<br>
<a id="note3" href="#note3ref"><sup>3</sup></a>’And you dreams, which do but re-echo my waking thoughts, come not to anticipate the suffering that I shall encounter next day.’（你们这些梦啊，虽然你们只能重复我白天的想法，也请不要揣测我明天将遭遇的痛苦。）<br>
<a id="note4" href="#note4ref"><sup>4</sup></a><em>Never let rising Sun approve you liars</em>: ‘do not paint things worse than they will prove to be when the next day comes.’（不要把事情描绘得比明天将要发生的还要糟糕。）<br>
<a id="note5" href="#note5ref"><sup>5</sup></a><em>embracing clouds</em>: ‘dreaming in a world of pure fancy.’（在纯粹的幻想世界中的梦境。）<br>
<a id="note6" href="#note6ref"><sup>6</sup></a>诗人感到清醒的世界太黑暗，故把睡眠称为“光明复归”。——编注者</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/Sonnet/"><i class="fas fa-hashtag fa-fw"></i>Sonnet</a>
                
                    <a href="/tags/付勇林/"><i class="fas fa-hashtag fa-fw"></i>付勇林</a>
                
                    <a href="/tags/S-Daniel/"><i class="fas fa-hashtag fa-fw"></i>S.Daniel</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-6-summary/">
              
                  《操作系统》第6讲：“物理内存管理：非连续内存分配”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-13
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<ul>
<li>背景</li>
<li>段机制</li>
<li>页机制
<ul>
<li>普通页表</li>
<li>快表</li>
<li>多级页表</li>
<li>页寄存器</li>
<li>反置页表</li>
</ul>
</li>
<li>段页式存储管理</li>
</ul>
<h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3>
<p>6.1 非连续内存分配的需求背景<br>
必须分配连续的会带来很多麻烦<br>
不连续？找到的几率更高，但会带来新问题。比如基本块有多大。<br>
段式：分块大<br>
页式：分块小</p>
<p>设计目标<br>
连续分配的缺点：<br>
• 物理内存必须连续<br>
• 存在外碎片和内碎片<br>
• 内存分配的动态修改困难<br>
• 内存利用率较低<br>
非连续分配的设计目标：提高内存利用效率和管理灵活性<br>
• 允许一个程序使用非连续的物理地址空间<br>
• 允许共享代码与数据<br>
• 支持动态加载和动态链接</p>
<p>实现<br>
非连续分配需要解决的问题：<br>
• 如何实现虚拟地址和物理地址的转换：不同的逻辑地址可能位于不连续的物理区域中<br>
○ 软件实现（灵活，开销大）<br>
○ 硬件实现（够用，开销小）<br>
• 非连续分配的硬件辅助机制<br>
○ 如何选择非连续分配中的内存分块大小？内碎片、外碎片问题？<br>
○ 段式存储管理（segmentation）：块大<br>
○ 页式存储管理（paging）：块小</p>
<h3 id="段机制"><a class="markdownIt-Anchor" href="#段机制"></a> 段机制</h3>
<p>6.2 段式存储管理<br>
段地址空间<br>
进程的段地址空间由多个段组成：<br>
• 主代码段<br>
• 子模块代码段<br>
• 公用库代码段<br>
• 堆栈段（stack）<br>
• 堆数据（heap）<br>
• 初始化数据段<br>
• 符号表等</p>
<p>段式存储管理的目的：更细粒度和灵活的分离域共享</p>
<p>段式地址空间的不连续二维结构</p>
<p>虽然在逻辑地址空间中，是按这一顺序排列的，但在物理地址空间中可以不是这样的。</p>
<p>段访问机制<br>
段的概念：<br>
• 段表示访问方式和存储数据等属性相同的一段地址空间<br>
• 对应一个连续的内存“块”<br>
• 若干个段组成进程逻辑地址空间<br>
段访问：逻辑地址由二元组（s，addr）表示<br>
• s——段号<br>
• addr——段内偏移<br>
• 从单地址转换成“段基址+段内偏移”</p>
<p>段访问的硬件实现</p>
<pre><code>• 首先从逻辑地址中得到段号和偏移量
• 在段表中查找段号，得到段基址和段长度
• 由MMU来判断偏移量是否合法（偏移量是否大于段长度）
• 得到物理地址，在物理内存中查找相应内容
</code></pre>
<h3 id="页机制"><a class="markdownIt-Anchor" href="#页机制"></a> 页机制</h3>
<p>6.3 页式存储管理<br>
页帧（帧、物理页面、Frame、Page Frame）（这是物理的）<br>
• 把物理地址空间划分为大小相同的基本分配单位<br>
• 2的n次方，如512,4096,8192，4k是常用大小<br>
页面（页、逻辑页面、Page）（这是逻辑的）<br>
• 把逻辑地址空间也划分为相同大小的基本分配单位<br>
• 帧和页的大小必须是相同的<br>
页面到页帧之间的转换：<br>
• 逻辑地址到物理地址的转换<br>
• 页表<br>
• MMU/TLB</p>
<p>帧（Frame）<br>
物理内存被划分成大小相等的帧<br>
此时内存的物理地址可以表示成二元组（f，o），其中f是帧号，o是帧内的偏移量<br>
物理地址的前F位可以换成帧号，后S位可以换成偏移量<br>
• F：帧号，F位，共有2^F个帧<br>
• o：帧内偏移，S位，每帧有2^S字节<br>
• 物理地址=f*2^S + o</p>
<p>基于页帧的物理地址计算实例<br>
假定：<br>
• 地址空间为16位<br>
• 页帧大小为9位（512字节）</p>
<p>页（Page）<br>
进程逻辑地址空间被划分为大小相等的页<br>
• 页内偏移=帧内偏移<br>
• 然而页号大小≠帧号大小，因为逻辑地址是连续的，但物理地址不一定是连续的<br>
进程逻辑地址的表示：二元组（p，o）<br>
• p：页号（P位，2P个页）<br>
• o：页内偏移（S位，每页有2^S字节）</p>
<p>页式存储中的地址映射<br>
如何将页映射到帧？<br>
• 逻辑地址中的页号<br>
• 物理地址中的帧号是不连续的<br>
• 不是所有的页都有对应的帧</p>
<p>这个表就是页表。</p>
<p>页表</p>
<p>页表保存了逻辑地址（页号）——物理地址（帧号）之间的映射关系。<br>
• CPU从逻辑地址中得到页号和偏移量<br>
• 在页表中以页号作为下标查找帧号<br>
• 用帧号和偏移量组成物理地址</p>
<h4 id="普通页表"><a class="markdownIt-Anchor" href="#普通页表"></a> 普通页表</h4>
<p>6.4 页表概述<br>
页表结构<br>
每个进程都有一个页表<br>
• 每个页面对应一个页表项<br>
• 随进程运行状态而动态变化（可以动态调整内存空间大小）<br>
• 页表基址寄存器：PTBR，Page Table Base Register</p>
<p>页表项的组成：<br>
• 帧号：f<br>
• 页表项标志：<br>
○ 存在位（resident bit）：逻辑页面是否存在与之对应的物理帧<br>
○ 修改位（dirty bit）：对应的页面中的内容是否被修改了<br>
○ 引用位（clock/reference bit）：在过去一段时间内是否访问过页中的某一个存储单元</p>
<p>页表地址转换实例<br>
有了存在位之后，就会发现，有些逻辑页没有对应的物理帧</p>
<p>页式存储管理机制的性能问题<br>
内存访问性能问题：<br>
• 访问一个内存单元需要2次内存访问<br>
• 第一次访问：获取页表项<br>
• 第二次访问：获取数据<br>
页表大小问题：<br>
• 页表可能非常大<br>
• 64位机器如果每页1024字节，那么一个页表的大小会是多少？（2^54个页面*8个多字节）<br>
如何处理？<br>
• 缓存（Caching）<br>
• 间接（Indirection）访问：切段，多级页表</p>
<h4 id="快表"><a class="markdownIt-Anchor" href="#快表"></a> 快表</h4>
<p>6.5 快表和多级页表<br>
快表（Translation Look-aside Buffer，TLB）<br>
目标：缓存近期访问的页表项<br>
• TLB使用关联存储（associated ），具备快速访问性能<br>
• 关联存储器：有一组key，可以并行地查找所有表项，得到匹配项<br>
• 因为快表位于CPU中，所以它的速度快、成本高、功耗大<br>
• 如果TLB命中，物理页号可以很快被获取<br>
• 如果TLB未命中，对应的表项被更新到TLB中</p>
<h4 id="多级页表"><a class="markdownIt-Anchor" href="#多级页表"></a> 多级页表</h4>
<p>多级页表<br>
• 通过间接引用将页号分成k级<br>
• 建立页表“树”<br>
• 可以有效减少每级页表的长度，但是如果所有的页表项都存在，则多级页表并没有减少存储量<br>
• 不过大部分进程并不会用到所有的逻辑地址空间</p>
<p>在x86架构中，CR3寄存器用于存储PTBR（页表基址）</p>
<p>二级页表实例</p>
<h4 id="页寄存器"><a class="markdownIt-Anchor" href="#页寄存器"></a> 页寄存器</h4>
<p>6.6 反置页表<br>
减少页表占用的空间的一种做法</p>
<p>大地址空间问题<br>
对于大地址空间（64-bits）系统，多级页表变得繁琐。<br>
比如：5级页表<br>
逻辑（虚拟）地址空间增长速度快于物理地址空间</p>
<p>页寄存器和反置页面的思路：<br>
• 不让页表与逻辑地址空间的大小相对应<br>
• 让页表与物理地址空间的大小相对应</p>
<p>页寄存器（Page Registers）<br>
每个帧与一个页寄存器（Page Register）关联，寄存器内容包括：<br>
• 使用位（Residence bit）：此帧是否被进程占用<br>
• 占用页号（Occupier）：对应的页号p<br>
• 保护位（Protection bits）：约定这一页的访问方式，可读，可写……</p>
<p>页寄存器示例<br>
• 物理内存大小：4096<em>4096=4K</em>4KB=16MB<br>
• 页面大小：4096bytes=4KB<br>
• 页帧数：4096=4K<br>
• 页寄存器使用的空间：8*4096=32Kbytes（假定每个页寄存器占8字节）<br>
• 页寄存器带来的额外开销：32K/16M=0.2%（大约）<br>
• 虚拟内存的大小：任意</p>
<p>页寄存器方案的特征<br>
优点：<br>
• 页表大小相对于物理内存而言很小<br>
• 页表大小与逻辑地址空间大小无关<br>
缺点：<br>
• 页表信息对调后，需要根据帧号可找页号<br>
• 在页寄存器中搜索逻辑地址中的页号</p>
<p>页寄存器中的地址转换<br>
CPU生成的逻辑地址如何找对应的物理地址？<br>
• 对逻辑地址进行Hash映射，以减少搜索范围<br>
• 需要解决可能的冲突<br>
用快表缓存页表项后的页寄存器搜索步骤<br>
• 对逻辑地址进行Hash变换<br>
• 在快表中查找对应页表项<br>
• 有冲突时遍历冲突项列表<br>
• 查找失败时，产生异常<br>
快表的限制<br>
• 快表的容量限制<br>
• 快表的功耗限制（StrongARM上快表功耗占27%）</p>
<h4 id="反置页表"><a class="markdownIt-Anchor" href="#反置页表"></a> 反置页表</h4>
<p>反置页表<br>
基于Hash映射值查找对应页表项中的帧号<br>
• 进程标识与页号的Hash值可能有冲突<br>
• 页表项中包括保护位、修改位、访问位和存在位等标识</p>
<p>查找过程：<br>
• 从逻辑地址中得到页号<br>
• 根据页号和PID计算出Hash值<br>
• 在反置页表中查找对应的页表项，核对页号是否一致，从中找出相应的物理帧号</p>
<p>反置页表的Hash冲突<br>
例子：在页表项中加入next项，指出全部冲突项的列表</p>
<h3 id="段页式存储管理"><a class="markdownIt-Anchor" href="#段页式存储管理"></a> 段页式存储管理</h3>
<p>6.7 段页式存储管理<br>
段页式存储管理的需求<br>
段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势<br>
段式存储和页式存储能否结合？</p>
<p>段页式存储管理<br>
在段式存储管理基础上，给每个段加一级页表<br>
逻辑地址：段号+若干个页号+页内偏移<br>
物理地址：帧号+页内偏移</p>
<pre><code>• 从逻辑地址中得到段号s和页号p，以及偏移o
• 通过段基址（STBR）和s得到对应的段表项
• 访问段表项对应的页表，得到对应的帧号
</code></pre>
<p>段页式存储管理中的内存共享<br>
通过指向相同的页表基址，实现进程间的段共享</p>
<p>共享段指向同一个页表</p>
<p>小结<br>
段式、页式、段页式内存分配总结<br>
共同点<br>
• 可以不连续<br>
区别：<br>
• 块的大小<br>
问题：<br>
• 加入页表或段表<br>
• 页表大小问题<br>
○ 快表<br>
○ 多级页表<br>
○ 反置页表<br>
• 实现细节</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>描述段管理机制正确的是()</strong></p>
<ul>
<li><strong>段的大小可以不一致</strong></li>
<li><strong>段可以有重叠</strong></li>
<li><strong>段可以有特权级</strong></li>
<li><strong>段与段之间是可以不连续的</strong></li>
</ul>
<p>都对。段的大小显然可以不一致（段描述符中给出的大小不同）。段之间可以重叠（没说不能重叠，而且完全扁平模型就是全都映射到全部物理内存。）段可以有特权级（段描述符中的DPL，访问段的最低特权级）。段之间当然也是可以不连续的。</p>
<hr>
<p><strong>描述页管理机制正确的是()</strong></p>
<ul>
<li><strong>页表在内存中</strong></li>
<li><strong>页可以是只读的</strong></li>
<li><strong>页可以有特权级</strong></li>
<li>上述说法都不对</li>
</ul>
<p>前三个都对。当然有的地方不太准确。在80386系统中，一级页表一定在内存中，但二级页表不一定在内存中。PDE和PTE都可以规定访问权限，不过只有U/S（用户/OS权限）和R/W（只读/可读可写）位。</p>
<hr>
<p><strong>页表项标志位包括()</strong></p>
<ul>
<li><strong>存在位(resident bit)</strong></li>
<li><strong>修改位(dirty bit)</strong></li>
<li><strong>引用位(clock/reference bit)</strong></li>
<li><strong>只读位(read only OR read/write bit)</strong></li>
</ul>
<p>都有。当然，还不止这些。</p>
<p><img src="table4-6_32bit_pte_entry_format.png" alt="PTE的格式（标志位）列表"></p>
<hr>
<p><strong>可有效应对大地址空间可采用的页表手段是()</strong></p>
<ul>
<li><strong>多级页表</strong></li>
<li><strong>反置页表</strong></li>
<li>页寄存器方案</li>
<li>单级页表</li>
</ul>
<p>前两个是对的。至于为什么页寄存器不行，老师在Piazza上给出了回复：</p>
<ul>
<li>页寄存器和反置页表很像，但它们的一个区别是进程ID在地址转换中的使用。没有进程ID（也就是说页寄存器方案）时，页表占用的空间仍然是与进程数相关的（也就是每个进程对应一组页寄存器？）。反置页表的大小只与物理内存大小，与并发进程数无关。</li>
<li>采用页寄存器的硬件开销会很大。所以现在的通用CPU（包括64位的CPU）没有采用这种方式，大部分还是多级页表。由于有TLB作为缓存，效率还不错。</li>
</ul>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>为什么要设计非连续内存分配机制？</strong></p>
<ul>
<li>提高分配的灵活性</li>
<li>提高内存的利用效率</li>
<li>方便共享、充分利用内存空间
<ul>
<li>允许一个程序使用非连续的物理地址空间</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
</ul>
<hr>
<p><strong>非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?</strong></p>
<p>大块好管理，小块更灵活。段式存储下，大小是可变的，且块比较大。页式存储下，大小是固定的，且块比较小。</p>
<hr>
<p><strong>为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？</strong></p>
<p>固定大小好管理，多种大小比一种大小灵活。可变大小更灵活，通常可变大小也会通过对齐来减少管理难度。小块时如果大小可变，则提供的灵活性没有那么多。</p>
<hr>
<p><strong>什么是段、段基址和段内偏移？</strong></p>
<p>段表示访问方式和存储数据的类型等属性相同的一段地址空间。段基址是段的起始地址（线性地址）。段内偏移是地址在段内的偏移量。</p>
<hr>
<p><strong>段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？</strong></p>
<p>段式存储管理中，地址转换是段基址（段号）加段内偏移。</p>
<p>段反映了程序的存储逻辑结构（数据段和代码段是分开的），程序不会从一个段的基址去访问另一个段，于是不同的段可以不连续。</p>
<p>好处是可以不连续，方便内存管理；麻烦是地址转换稍微复杂了一些。</p>
<hr>
<p><strong>什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？</strong></p>
<ul>
<li>页帧（帧、物理页面、Frame、Page Frame）（这是物理的）
<ul>
<li>把物理地址空间划分为大小相同的基本分配单位</li>
<li>大小一般为2的n次方，如512、4096、8192字节，4KB是常用大小</li>
</ul>
</li>
<li>页面（页、逻辑页面、Page）（这是逻辑的）
<ul>
<li>把逻辑地址空间也划分为相同大小的基本分配单位</li>
<li>帧和页的大小必须是相同的</li>
</ul>
</li>
<li>页表：保存了逻辑地址（页号）——物理地址（帧号）之间的映射关系</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener">MMU</a>：一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制，在较为简单的计算机体系结构中，负责总线的仲裁以及存储体切换</li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80" target="_blank" rel="noopener">TLB</a>：为CPU的一种缓存，由存储器管理单元用于改进虚拟地址到物理地址的转译速度</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">Cache</a>：访问速度比一般随机存取内存（RAM）快的一种RAM，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术</li>
</ul>
<hr>
<p><strong>页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？</strong></p>
<p>页式存储管理中，地址转换流程是页号-&gt;物理页帧号加页内偏移。</p>
<p>CPU使用连续的逻辑地址，存储访问时，逻辑地址先分成逻辑页号和页内偏移，然后通过页表定义的对应关系，把逻辑页面转换成物理页号，最后再把物理页号加页内偏移得到物理地址；于是不同的页可以不连续。</p>
<p>好处是可以不连续，方便内存管理中的存储分配和回收；麻烦是地址转换比较复杂（页表项访问开销和页表存储开销），并且频繁进行（每次存储访问会变成两次或更多）。</p>
<hr>
<p><strong>每个页表项有些什么内容？有哪些标志位？它们起什么作用？</strong></p>
<p><img src="fig4-4_pte_and_pde_structure.png" alt="PDE和PTE的格式"></p>
<p><img src="table4-6_32bit_pte_entry_format.png" alt="PTE的格式（标志位）列表"></p>
<hr>
<p><strong>页表大小受哪些因素影响？</strong></p>
<p>页大小、地址空间大小、进程数目、页表级数</p>
<hr>
<p><strong>快表（TLB）与高速缓存（cache）有什么不同？</strong></p>
<p>TLB中缓存的是线性地址&lt;-&gt;物理地址的映射关系，由硬件管理，对软件是透明的。</p>
<p>Cache中缓存的是具体的内存内容，也由硬件管理，对软件是透明的。</p>
<hr>
<p><strong>为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？</strong></p>
<p>因为它是在多个表项中同步查找有没有对应的线性地址项，所以很快。TLB的硬件是怎么实现的……大概瞎写吧。容量小是因为用电路换时间了（多路并行查找），成本和耗电量比较高。</p>
<hr>
<p><strong>什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？</strong></p>
<p>就是套了很多层的页表。地址转换流程就是不断根据每一级的页号和页表基址查找下一级的页表基址（或者查到页表项）。</p>
<p>好处是减小了页表占据的空间（因为程序一般不会用完自己的虚拟地址空间，所以大部分次级页表不需要生成）；麻烦是地址转换变得更加复杂和缓慢了。</p>
<hr>
<p><strong>页寄存器机制的地址转换流程是什么？</strong></p>
<p>对CPU访问的逻辑地址进行hash，然后查相应页寄存器。</p>
<p>用快表缓存页表项后的页寄存器搜索步骤</p>
<ul>
<li>对逻辑地址进行Hash变换</li>
<li>在快表中查找对应页表项</li>
<li>有冲突时遍历冲突项列表</li>
<li>查找失败时，产生异常</li>
</ul>
<hr>
<p><strong>反置页表机制的地址转换流程是什么？</strong></p>
<p>逻辑地址和进程号共同进行hash，然后查相应页寄存器。</p>
<p>查找过程：</p>
<ul>
<li>从逻辑地址中得到页号</li>
<li>根据页号和PID计算出Hash值</li>
<li>在反置页表中查找对应的页表项，核对页号是否一致，从中找出相应的物理帧号；处理hash冲突</li>
</ul>
<hr>
<p><strong>反置页表项有些什么内容？</strong></p>
<p>PID、逻辑页号、标志位（可能还应该有指向下一个hash相同的页表项的指针）</p>
<hr>
<p><strong>段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？</strong></p>
<p>首先从逻辑地址翻译成线性地址（段机制），再从线性地址翻译成物理地址（页机制）。</p>
<p>好处是……。。。</p>
<p>麻烦是，地址访问过程甚至变得更加复杂和耗时了。</p>
<hr>
<p><strong>如何实现基于段式存储管理的内存共享？</strong></p>
<p>……就把需要重用的内存映射到不同的段里……</p>
<hr>
<p><strong>如何实现基于页式存储管理的内存共享？</strong></p>
<p>不同的页表项指向相同的物理页……</p>
<hr>
<p><strong>请简要分析64bit CPU体系结构下的分页机制是如何实现的</strong></p>
<ul>
<li>说明64bit CPU架构的分页机制的大致特点和页表执行过程</li>
<li>正确描述了64bit CPU支持的物理内存大小限制（1分）</li>
<li>正确描述了64bit CPU下的多级页表的级数和多级页表的结构或反置页表的结构（2分）</li>
<li>除上述两点外，进一步描述了在多级页表或反置页表下的虚拟地址–&gt;物理地址的映射过程（3分）</li>
</ul>
<p>64位的寻址空间能够寻址16EB 的内存大小，对于目前的硬件来说太大了。在X64体系结构下，只实现了48位的虚拟地址。不同于x86体系结构，每级页表寻址长度变成9位，由于在x64体系结构中，普通页大小仍为4KB，然而数据却表示64位长，因此一个4KB页在x64体系结构下只能包含512项内容，所以为了保证页对齐和以页为单位的页表内容换入换出，在x64下每级页表寻址部分长度定位9位。</p>
<p>为了正确翻译x64的线性地址，其页表也从x86的2级变成了4级。翻译过程可参考Intel手册或者以下链接 <a href="http://www.cnblogs.com/lanrenxinxin/p/4735027.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanrenxinxin/p/4735027.html</a></p>
<hr>
<p><strong>某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10<sup>-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10</sup>-6s),求不在内存的页面的平均访问时间。请给出计算步骤。</strong></p>
<p>500=0.9<em>150+0.1</em>x</p>
<p>（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。</p>
<p>PTE格式（8 bit） :</p>
<p>VALID | PFN6 … PFN0<br>
PDE格式（8 bit） :</p>
<p>VALID | PT6 … PT0<br>
其</p>
<p>VALID<mark>1表示，表示映射存在；VALID</mark>0表示，表示映射不存在。<br>
PFN6…0:页帧号<br>
PT6…0:页表的物理基址&gt;&gt;5<br>
在物理内存模拟数据文件中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。</p>
<ol>
<li>Virtual Address 6c74<br>
Virtual Address 6b22</li>
<li>Virtual Address 03df<br>
Virtual Address 69dc</li>
<li>Virtual Address 317a<br>
Virtual Address 4546</li>
<li>Virtual Address 2c03<br>
Virtual Address 7fd7</li>
<li>Virtual Address 390e<br>
Virtual Address 748b<br>
比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)</li>
</ol>
<p>Virtual Address 7570:<br>
–&gt; pde index:0x1d  pde contents:(valid 1, pfn 0x33)<br>
–&gt; pte index:0xb  pte contents:(valid 0, pfn 0x7f)<br>
–&gt; Fault (page table entry not valid)</p>
<p>Virtual Address 21e1:<br>
–&gt; pde index:0x8  pde contents:(valid 0, pfn 0x7f)<br>
–&gt; Fault (page directory entry not valid)</p>
<p>Virtual Address 7268:<br>
–&gt; pde index:0x1c  pde contents:(valid 1, pfn 0x5e)<br>
–&gt; pte index:0x13  pte contents:(valid 1, pfn 0x65)<br>
–&gt; Translates to Physical Address 0xca8 --&gt; Value: 16<br>
链接有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。</p>
<p>（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。</p>
<p>链接有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。</p>
<p>（4）假设你有一台支持反置页表的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。</p>
<p>(5)X86的页面结构<br>
扩展思考题<br>
阅读64bit IBM Powerpc CPU架构是如何实现反置页表，给出分析报告。</p>
<p>interactive　understand VM<br>
Virtual Memory with 256 Bytes of RAM：这是一个只有256字节内存的一个极小计算机系统。按作者的[[<a href="https://github.com/RobertElderSoftware/recc#what-can-this-project-do%7C%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">https://github.com/RobertElderSoftware/recc#what-can-this-project-do|特征描述</a>]]，它具备如下的功能。<br>
CPU的实现代码不多于500行；<br>
支持14条指令、进程切换、虚拟存储和中断；<br>
用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；<br>
实现了一个ANSI C89编译器，可生成在该CPU上运行代码；<br>
该编译器支持链接功能；<br>
用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；<br>
支持交叉编译；<br>
所有这些只依赖标准C库。 针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-5-summary/">
              
                  《操作系统》第5讲：“物理内存管理：连续内存分配”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-12
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>本节课的内容比较简单。</p>
<ul>
<li>计算机体系结构和内存层次</li>
<li>地址空间和地址生成</li>
<li>连续内存分配
<ul>
<li>三种不同的分类策略</li>
<li>碎片整理</li>
<li>伙伴系统</li>
</ul>
</li>
<li>uCore中的连续内存管理实现框架</li>
</ul>
<h3 id="计算机体系结构和内存层次"><a class="markdownIt-Anchor" href="#计算机体系结构和内存层次"></a> 计算机体系结构和内存层次</h3>
<p>讲了一些比较抽象的东西。<br>
计算机体系结构由CPU、内存、I/O设备、总线组成。<br>
CPU中包括：</p>
<ul>
<li>ALU、控制逻辑</li>
<li>寄存器</li>
<li>高速缓存：加快读写速度</li>
<li>存储管理单元（MMU）<br>
内存的特点：</li>
<li>最小访问单位是字节（8bit）</li>
<li>一次可以读/写4字节（32位），有地址对齐问题</li>
</ul>
<p>内存可以分为如下层次：</p>
<ul>
<li>CPU中：
<ul>
<li>L1缓存</li>
<li>L2缓存</li>
<li>这些缓存都是由硬件（MMU）来控制的，软件看不到</li>
</ul>
</li>
<li>高速缓存未命中：（这之下由操作系统软件来控制）
<ul>
<li>内存</li>
</ul>
</li>
<li>缺页：</li>
<li>外存（虚拟内存）</li>
</ul>
<h4 id="操作系统的内存管理"><a class="markdownIt-Anchor" href="#操作系统的内存管理"></a> 操作系统的内存管理</h4>
<p>OS内存管理的特点：</p>
<ul>
<li>每个字节有自己的物理地址</li>
<li>分为内存和外存</li>
<li>每个进程有自己用的内存片，它们自己的地址之间是可以重叠的。</li>
<li>MMU：将逻辑（虚拟）地址空间转换为物理地址空间</li>
</ul>
<p>OS内存管理的目标：</p>
<ul>
<li>抽象：逻辑地址空间</li>
<li>保护：独立地址空间</li>
<li>共享：访问相同内存（虽然和保护有一定的矛盾）</li>
<li>虚拟化：更大的地址空间</li>
</ul>
<p>操作系统采用的内存管理方式：</p>
<ul>
<li>重定位（relocation）：段地址+偏移</li>
<li>分段（segmentation）：程序的逻辑结构不需要连成一片，而是分成代码、数据、堆栈3块，每一块的空间就减少了；但每段的内容是连续的</li>
<li>分页（paging）：把内存分成最基本的单位</li>
<li>虚拟存储（virtual memory）：目前多数系统（如Linux）采用的是按需页式虚拟存储</li>
</ul>
<p>内存管理方式的实现是高度依赖硬件的：</p>
<ul>
<li>与计算机存储架构紧密耦合</li>
<li>MMU（内存管理单元）：处理CPU存储访问请求的硬件</li>
</ul>
<p>（当然，我很好奇为什么重定位也算是一种内存管理方式。）</p>
<blockquote>
<p>静态地址重定位：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。<br>
优点：无需硬件支持<br>
缺点：1）程序重定位之后就不能在内存中搬动了；2）要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域中。<br>
动态地址重定位：不是在程序执行之前而是在程序执行过程中进行地址重定位。更确切的说，是在每次访问内存单元前才进行地址变换。动态重定位可使装配模块不加任何修改而装入内存，但是它需要硬件一定位寄存器的支持。<br>
优点：1）目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的；2）一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。<br>
缺点：需要硬件支持。<br>
摘自<a href="https://blog.csdn.net/spaceyqy/article/details/39393877" target="_blank" rel="noopener">地址重定位：静态重定位和动态重定位</a></p>
</blockquote>
<h3 id="地址空间和地址生成"><a class="markdownIt-Anchor" href="#地址空间和地址生成"></a> 地址空间和地址生成</h3>
<p>一般来说，地址空间至少有3种：</p>
<ul>
<li>物理地址空间：硬件支持的地址空间
<ul>
<li>起始地址0</li>
<li>到MAXsys</li>
</ul>
</li>
<li>线性地址空间：CPU看到的地址
<ul>
<li>起始地址0</li>
<li>大小取决于地址线的宽度</li>
</ul>
</li>
<li>逻辑地址空间：在CPU中运行的进程看到的地址
<ul>
<li>起始地址0</li>
<li>到MAXprog</li>
<li>也就是用户程序可见的地址</li>
</ul>
</li>
</ul>
<p>逻辑地址的生成需要经过如下几个过程：</p>
<ul>
<li>高级语言程序：写出函数</li>
<li>编译：对源代码进行编译，成为汇编源代码，此时仍然用符号来指代函数</li>
<li>汇编：汇编成二进制代码，用具体地址来代替符号了，但是有一些函数还没有找到</li>
<li>链接：加入函数库，找到库函数的地址</li>
<li>重定位：程序加载时进行，视程序实际位置改变符号地址</li>
</ul>
<p>一般来说，生成地址有几个时机：</p>
<ul>
<li>编译时（优点：简单）
<ul>
<li>假设起始地址已知</li>
<li>但如果起始地址改变，就必须重新编译</li>
<li>功能手机一般会有这种情况</li>
</ul>
</li>
<li>加载时
<ul>
<li>如果加载时起始位置未知，编译器需生成可重定位的代码（relocatable code）</li>
<li>加载时，生成绝对地址</li>
</ul>
</li>
<li>执行时（优点：灵活）
<ul>
<li>执行时代码可移动</li>
<li>需地址转换（映射）硬件支持（一般是虚拟存储）</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配"><a class="markdownIt-Anchor" href="#连续内存分配"></a> 连续内存分配</h3>
<p>一般分配给一个进程的地址空间是连续的，因此需要进行有效的内存分配。需求是，给进程分配一块不小于指定大小的连续的物理内存区域。定义<strong>碎片</strong>是过小的不能被利用的空闲内存，分为2类：</p>
<ul>
<li>外部碎片：分配单元之间的未被使用内存</li>
<li>内部碎片：分配单元内部的未被使用内存（一般是否有内碎片取决于分配单元大小是否要取整）</li>
</ul>
<p>我们在uCore中进行的是动态分区分配，需要满足以下要求：</p>
<ul>
<li>当程序被加载执行时，分配一个进程指定大小可变的分区（块）</li>
<li>分区的地址是连续的</li>
</ul>
<p>一般来说，操作系统需要维护至少2个数据结构，里面存储的内容是：</p>
<ul>
<li>所有进程的已分配分区</li>
<li>空闲分区（Empty-blocks）</li>
</ul>
<p>常见的几种连续内存分配策略包括：</p>
<ul>
<li>最先匹配（First-fit）</li>
<li>最佳匹配（Best-fit）</li>
<li>最差匹配（worst-fit）</li>
</ul>
<p>总的来说，这些匹配方法各有优劣，至于到底是什么优劣，与使用场景关系很大。</p>
<h4 id="三种不同的分类策略"><a class="markdownIt-Anchor" href="#三种不同的分类策略"></a> 三种不同的分类策略</h4>
<h5 id="最先匹配first-fit-allocation策略"><a class="markdownIt-Anchor" href="#最先匹配first-fit-allocation策略"></a> 最先匹配（First Fit Allocation）策略</h5>
<p>思路：需要分配n个字节时，使用第一个可用的空间比n大的空闲块</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配时搜索第一个合适的分区</li>
<li>释放分区时，检查是否可与邻近的空闲分区合并</li>
</ul>
<p>优点：</p>
<ul>
<li>简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
<p>缺点：</p>
<ul>
<li>容易产生外部碎片</li>
<li>分配大块时较慢</li>
</ul>
<h4 id="最佳匹配best-fit-allocation策略"><a class="markdownIt-Anchor" href="#最佳匹配best-fit-allocation策略"></a> 最佳匹配（Best Fit Allocation）策略</h4>
<p>思路：分配n字节内存时，查找并使用不小于n的最小空闲分区</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按照大小排序</li>
<li>分配时，查找一个合适的分区</li>
<li>释放时，查找并合并邻近的空闲分区（如果找到）</li>
</ul>
<p>优点：</p>
<ul>
<li>大部分分配的尺寸较小时，效果很好
<ul>
<li>可避免大的空闲分区被拆分</li>
<li>可减小外部碎片的大小</li>
<li>相对简单</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>外部碎片较多</li>
<li>释放分区较慢</li>
<li>容易产生很多无用的小碎片</li>
</ul>
<h4 id="最差匹配worst-fit-allocation策略"><a class="markdownIt-Anchor" href="#最差匹配worst-fit-allocation策略"></a> 最差匹配（Worst Fit Allocation）策略</h4>
<p>思路：分配n字节时，使用尺寸不小于n的最大空闲分区</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，检查是否可与邻近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序</li>
</ul>
<p>优点：</p>
<ul>
<li>中等大小的分配较多时，效果最好</li>
<li>避免出现太多的小碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>释放分区较慢</li>
<li>外部碎片较多</li>
<li>容易破坏大的空闲分区，因此难以分配大的分区</li>
</ul>
<h4 id="碎片整理"><a class="markdownIt-Anchor" href="#碎片整理"></a> 碎片整理</h4>
<p>上述方法都会产生外碎片。（但是不会产生内碎片，因为是按需分配的）如果碎片太多，就有可能出现，即使空余内存总数足够大，也无法分配出一块连续内存的情况。为此就需要进行碎片整理。碎片整理的定义是通过调整进程占用的分区位置来减少或避免分区碎片。一般有两种碎片整理的方法</p>
<ul>
<li>紧凑（compaction）通过移动分配给进程的内存分区，以合并外部碎片
<ul>
<li>进行碎片紧凑的条件：所有的应用程序可动态重定位</li>
<li>需要在应用程序等待时进行移动</li>
<li>需要考虑开销</li>
</ul>
</li>
<li>分区对换（Swapping in/out）：通过抢占并回收处于等待状态进程的分区，以增大可用内存空间
<ul>
<li>这就让更多进程能够在内存里交替运行</li>
<li>需要解决的问题：交换哪个（些）进程？</li>
<li>swap分区在linux中是耳熟能详的，在早期很有用，但代价很大，因为外存的速度远远慢于内存</li>
<li>有了虚拟页式存储之后，纯粹的分区对换的意义就不大了</li>
</ul>
</li>
</ul>
<h4 id="伙伴系统"><a class="markdownIt-Anchor" href="#伙伴系统"></a> 伙伴系统</h4>
<p>伙伴系统（Buddy System）是一种连续存储分配的办法，它解决了分配位置和碎片的问题。</p>
<p>假定整个可分配的分区大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>u</mi></msup></mrow><annotation encoding="application/x-tex">2^u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span></span></span>，伙伴系统的分配和释放过程如下：</p>
<ul>
<li>分配过程：
<ul>
<li>需要的分区大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>s</mi><mo>≤</mo><msup><mn>2</mn><mi>u</mi></msup></mrow><annotation encoding="application/x-tex">2^{u-1} &lt; s \le 2^u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span></span></span>时，把整个块分配给该进程</li>
<li>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s \le 2^{i-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则将大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>的当前空闲分区划分成两个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的空闲分区</li>
<li>重复划分过程，直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>&lt;</mo><mi>s</mi><mo>≤</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^{i-1} &lt; s \le 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.863764em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>，并把一个空闲分区分配给该进程</li>
</ul>
</li>
<li>释放过程：
<ul>
<li>将进程占用的块释放</li>
<li>查看它能否与相邻的空闲块合并（注意边界条件）</li>
<li>如果能合并，则不断合并到不能再合并为止</li>
</ul>
</li>
</ul>
<p>由分析可知，内碎片的大小最多是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，没有外碎片。</p>
<h5 id="伙伴系统的具体实现"><a class="markdownIt-Anchor" href="#伙伴系统的具体实现"></a> 伙伴系统的具体实现</h5>
<p>数据结构：</p>
<ul>
<li>空闲块按大小和起始地址组织成二维数组（或者说一维数组+一维链表）</li>
<li>第一维：大小；第二维：地址</li>
<li>初始状态：只有一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>u</mi></msup></mrow><annotation encoding="application/x-tex">2^u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span></span></span></span>的空闲块</li>
</ul>
<p>分配过程：</p>
<ul>
<li><strong>由小到大</strong> 在空闲块数组中找最小的可用空闲块（只要有合适的空闲块，就不切分大块，这是隐含的一个原则吧）</li>
<li>如果块太大，则对可用空闲块进行二等分，直到得到合适大小的块</li>
</ul>
<p>释放过程：</p>
<ul>
<li>把释放的块放入空闲块数组</li>
<li>合并满足合并条件的空闲块，合并条件是：
<ul>
<li>大小相同，均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></li>
<li>地址相邻</li>
<li>相邻两块的低地址必须是2^(i+1)的倍数</li>
</ul>
</li>
</ul>
<h3 id="ucore中的连续内存管理实现框架"><a class="markdownIt-Anchor" href="#ucore中的连续内存管理实现框架"></a> uCore中的连续内存管理实现框架</h3>
<p>这部分就比较简略了。简单来说，uCore定义了一个<code>struct pmm_manager</code>的数据结构，其中保存了各种操作（如分配、释放等）对应的函数指针。因此，可以定义各种不同的管理方法函数，并把函数指针放到该结构体的实例中。这很面向对象了。下面的代码摘自<code>lab2/kern/mm/pmm.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager</span><br><span class="line">// only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used</span><br><span class="line">// by ucore to manage the total physical memory space.</span><br><span class="line">struct pmm_manager &#123;</span><br><span class="line">    const char *name;                                 // XXX_pmm_manager&apos;s name</span><br><span class="line">    void (*init)(void);                               // initialize internal description&amp;management data structure</span><br><span class="line">                                                      // (free block list, number of free block) of XXX_pmm_manager</span><br><span class="line">    void (*init_memmap)(struct Page *base, size_t n); // setup description&amp;management data structcure according to</span><br><span class="line">                                                      // the initial free physical memory space</span><br><span class="line">    struct Page *(*alloc_pages)(size_t n);            // allocate &gt;=n pages, depend on the allocation algorithm</span><br><span class="line">    void (*free_pages)(struct Page *base, size_t n);  // free &gt;=n pages with &quot;base&quot; addr of Page descriptor structures(memlayout.h)</span><br><span class="line">    size_t (*nr_free_pages)(void);                    // return the number of free pages</span><br><span class="line">    void (*check)(void);                              // check the correctness of XXX_pmm_manager</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后就可以定义一个<code>default_pmm_manager</code>用来对内存进行管理了（<code>lab2/kern/mm/default_pmm.c</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const struct pmm_manager default_pmm_manager = &#123;</span><br><span class="line">    .name = &quot;default_pmm_manager&quot;,</span><br><span class="line">    .init = default_init,</span><br><span class="line">    .init_memmap = default_init_memmap,</span><br><span class="line">    .alloc_pages = default_alloc_pages,</span><br><span class="line">    .free_pages = default_free_pages,</span><br><span class="line">    .nr_free_pages = default_nr_free_pages,</span><br><span class="line">    .check = default_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>操作系统中可采用的内存管理方式包括()</strong></p>
<ul>
<li><strong>重定位(relocation)</strong></li>
<li><strong>分段(segmentation</strong></li>
<li><strong>分页(paging)</strong></li>
<li><strong>段页式（segmentation+paging）</strong></li>
</ul>
<p>都有。虽然我还是很难想象重定位是内存管理方式，这难道不是进程的管理方式么，虽然能够把进程在内存中搬移大概是上述几种分配策略的前提……</p>
<hr>
<p><strong>在启动页机制的情况下，在CPU运行的用户进程访问的地址空间是()</strong></p>
<ul>
<li>物理地址空间</li>
<li><strong>逻辑地址空间</strong></li>
<li>外设地址空间</li>
<li>都不是</li>
</ul>
<p>用户进程访问的内存地址是虚拟地址。虚拟地址加上对应的段选择子构成逻辑地址。逻辑地址经过分段翻译成线性地址。线性地址经过分页翻译成物理地址。（但是，即使没有启动页机制，用户进程访问的地址空间也应该是逻辑地址空间吧）</p>
<hr>
<p><strong>连续内存分配的算法中，会产生外碎片的是()</strong></p>
<ul>
<li><strong>最先匹配算法</strong></li>
<li><strong>最差匹配算法</strong></li>
<li><strong>最佳匹配算法</strong></li>
<li>都不会</li>
</ul>
<p>三种算法都会有外碎片，而没有内碎片。相比之下，分页不会有外碎片，只会有内碎片。伙伴系统是可能会产生外碎片的，当然也有内碎片。</p>
<hr>
<p><strong>在使能分页机制的情况下，更合适的外碎片整理方法是()</strong></p>
<ul>
<li>紧凑(compaction)</li>
<li>分区对换(Swapping in/out)</li>
<li><strong>都不是</strong></li>
</ul>
<p>分页方式不会有外碎片。虽然很对，但这道题完全毫无意义。</p>
<hr>
<p><strong>描述伙伴系统(Buddy System)特征正确的是()</strong></p>
<ul>
<li><strong>多个小空闲空间可合并为大的空闲空间</strong></li>
<li><strong>会产生外碎片</strong></li>
<li><strong>会产生内碎片</strong></li>
<li>都不对</li>
</ul>
<p>小空闲空间在满足一定条件时可以合并。因为是一个不断二分的过程，所以外碎片是可能会产生的。因为是分配2的幂大小的内存，所以内碎片也是有的。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>操作系统中存储管理的目标是什么？</strong></p>
<ul>
<li>抽象</li>
<li>保护</li>
<li>共享</li>
<li>虚拟化</li>
</ul>
<hr>
<p><strong>描述编译、汇编、链接和加载的过程是什么？</strong></p>
<ul>
<li>编译：将程序源代码转换为汇编代码</li>
<li>汇编：将汇编代码转为二进制的机器码</li>
<li>链接：将多个二进制的机器码结合成一个可执行环境</li>
<li>加载：将程序从外存中加载到内存中</li>
</ul>
<p>这几个过程并不是完全分开的，例如动态加载的库通常在加载过程中进行链接。 详细过程可参考：<a href="http://blog.csdn.net/ajianyingxiaoqinghan/article/details/70889362" target="_blank" rel="noopener">http://blog.csdn.net/ajianyingxiaoqinghan/article/details/70889362</a></p>
<hr>
<p><strong>什么是内碎片、外碎片？</strong></p>
<p>内碎片是指分配给任务的内存大小比任务所要求的大小所多出来的内存。外碎片指分配给任务的内存之间无法利用的内存。当然，一块内存是否为外碎片取决于需要分配的内存的大小。</p>
<hr>
<p><strong>最先匹配会越用越慢吗？请说明理由（可来源于猜想或具体的实验）？</strong></p>
<p>最先匹配总是先找低地址空间的内存，到后期低地址空间都是大量小的不连续的内存空间，每次都要扫描低地址空间后到达高地质空间才能得到可用的内存。所以大概是会越用越慢的。</p>
<hr>
<p><strong>最差匹配的外碎片会比最优适配算法少吗？请说明理由（可来源于猜想或具体的实验）</strong></p>
<p>应该会的。因为每次都找到最大的内存块进行分割，因此分割剩下的内存块也很大，往往还可以再装下一个程序。</p>
<hr>
<p><strong>理解0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm算法中分区释放后的合并处理过程？ (optional)</strong></p>
<p>它们的处理方式都是查看边上是否也有空闲块，如果有，则合并空闲块，然后将空闲块管理数据插入链表中。如果能进行合并，都需要连续合并。当然，伙伴系统的合并过程需要判断是否满足条件。</p>
<hr>
<p><strong>对换和紧凑都是碎片整理技术，它们的主要区别是什么？为什么在早期的操作系统中采用对换技术？</strong></p>
<p>区别是，紧凑是在内存中搬动进程占用的内存位置，以合并出大块的空闲块；对换是把内存中的进程搬到外存中，以空出更多的内存空闲块。采用对换的原因是，处理简单。不过代价也比较高，因为外存比较慢。</p>
<hr>
<p><strong>一个处于等待状态的进程被对换到外存（对换等待状态）后，等待事件出现了。操作系统需要如何响应？</strong></p>
<p>将进程从硬盘中读取到内存中，在这个过程中，操作系统将该进程标为等待状态并且调度其他进程。</p>
<p>这道题似乎大跃进到第11讲的等待进程模型了。总之，就是进程从等待挂起状态转换到就绪挂起状态，然后在优先级足够高的时候从硬盘读入到内存，进入就绪状态，然后运行。当然，这个做法在现代操作系统里已经凉了。</p>
<p><img src="proc_state.jpg" alt="进程状态转换过程"></p>
<hr>
<p><strong>伙伴系统的空闲块如何组织？</strong></p>
<p>按照内存的大小由一系列链表组织。类似于哈希表，将相同大小的内存区域首地址连接起来。（因为一般来说，内存要按首地址大小排列，链表的插入删除比较简单啊）</p>
<hr>
<p><strong>伙伴系统的内存分配流程？</strong></p>
<p>当向内核请求分配<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">，</mi><msup><mn>2</mn><mi>i</mi></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">(2^{i-1}，2^i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>数目的页块时，按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>大小的块来请求处理。如果对应的块链表中没有空闲页块，则在更大的页块链表中找空闲块，并将大块进行切分，直到得到满足要求的块。如果切出了多余的块，伙伴系统会将这些块插入到对应的空闲页块链表中。</p>
<hr>
<p><strong>伙伴系统的内存回收流程？</strong></p>
<p>当释放多页的块时，内核首先计算出该内存块的伙伴的地址。内核将满足以下条件的三个块称为伙伴：</p>
<ol>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一块的第一个页的物理地址是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mo>(</mo><msup><mn>2</mn><mi>b</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">2 * (2^b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的倍数。</li>
</ol>
<p>如果找到了该内存块的伙伴，确保该伙伴的所有页都是空闲的，以便进行合并。内存继续检查合并后页块的“伙伴”并检查是否可以合并，依次类推。</p>
<p>（所以才叫伙伴系统，了解了）</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>动态链接如何使用？尝试在Linux平台上使用LD_DEBUG查看一个C语言Hello world的启动流程。</strong></p>
<p><a href="https://blog.csdn.net/stanjiang2010/article/details/7069808" target="_blank" rel="noopener">编译链接和加载</a></p>
<p>LD_DEBUG 是Linux平台查看程序运行加载库的重要工具，其可以详细的列出程序执行时如何加载相应符号的。 通过LD_DEBUG =help查看如何使用, LD_DEBUG=all ./hello 完成题目</p>
<p>显然这道题我没有做。</p>
<hr>
<p><strong>观察最先匹配、最佳匹配和最差匹配这几种动态分区分配算法的工作过程，并选择一个例子进行分析分析整个工作过程中的分配和释放操作对维护数据结构的影响和原因。</strong></p>
<hr>
<p><strong>请参考xv6（umalloc.c），ucore lab2代码，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在Linux应用程序/库层面，用C、C++或python来实现malloc/free，给出你的设计思路，并给出可以在Linux上运行的malloc/free实现和测试用例。 可参考：<a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">https://github.com/shellphish/how2heap</a></strong></p>
<hr>
<p><strong>阅读slab分配算法，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。 可参考： <a href="https://github.com/bbu/userland-slab-allocator" target="_blank" rel="noopener">https://github.com/bbu/userland-slab-allocator</a></strong></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-4-summary/">
              
                  《操作系统》第4讲：“实验1-系统软件启动过程”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-12
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>这节课主要介绍了一些和Lab1相关的内容。</p>
<ul>
<li>系统启动过程
<ul>
<li>BIOS</li>
<li>bootloader
<ul>
<li>段机制</li>
<li>操作系统的加载</li>
</ul>
</li>
</ul>
</li>
<li>C语言的一些相关知识
<ul>
<li>函数调用的实现</li>
<li>GCC内联汇编</li>
</ul>
</li>
<li>x86架构下的中断处理过程</li>
</ul>
<h3 id="系统启动过程"><a class="markdownIt-Anchor" href="#系统启动过程"></a> 系统启动过程</h3>
<h4 id="bios"><a class="markdownIt-Anchor" href="#bios"></a> BIOS</h4>
<p>BIOS的工作过程已经在<a href="/post/os-mooc-lecture-3-summary">《操作系统》第3讲：“启动、中断、异常和系统调用”总结</a>中详细说过了，在此不再重复。唯一值得注意的是，虽然实模式下的寻址方式是Base（16位寄存器CS）* 16 + Offset（16位寄存器IP）=线性地址（20位），但是这并不是段机制。</p>
<h4 id="bootloader"><a class="markdownIt-Anchor" href="#bootloader"></a> bootloader</h4>
<p>BIOS将控制权转交给bootloader（见<code>lab1/boot</code>文件夹下的内容）。它的工作内容主要包括：</p>
<ul>
<li>使能保护模式（protection mode）和段机制（segment level protection），切换到32位4G的寻址空间，对段机制进行初始化</li>
<li>从硬盘上读取ELF格式的ucore kernel（位于MBR后面的扇区）并放到内存中固定位置</li>
<li>跳转到ucore OS的入口点（entry point），将控制权转交给ucore OS</li>
</ul>
<h5 id="使能保护模式"><a class="markdownIt-Anchor" href="#使能保护模式"></a> 使能保护模式</h5>
<p>将系统寄存器CR0的第0个bit置为1，说明进入保护模式。当然，在此之前要开A20，并准备好GDT表，将基址加载到GDT基址寄存器中。</p>
<h5 id="段机制"><a class="markdownIt-Anchor" href="#段机制"></a> 段机制</h5>
<p>保护模式下必须开启段机制。所以讲一下段机制的原理。具体可以参见<a href="/post/intel-80x86-architecture-mm-under-protected-mode">Intel80X86架构：保护模式下的内存管理</a>。</p>
<p>总的来说，段机制其实是一种映射关系。一个段指向的是线性地址空间中一段连续的内存，有基址和limit。段与段之间是可以重叠的。</p>
<p>设置段机制的方法是，建立一个数组来存储段描述符表，称为全局描述符表GDT（也称为段表，在ucore中是由bootloader建立的，因为开启保护模式之前就需要设置好GDT），其中包括段描述符表的位置、大小等信息；这样CPU就可以找到段表了（用GDTR寄存器保存段表信息）。除了设置GDT之外，还要为CS、DS等段寄存器设置好对应的Index，使它们能够指向全局描述符表GDT对应的项，这可以在切换到保护模式之后进行。</p>
<p>硬件提供了一些段寄存器。这些段寄存器指向段描述符，比较重要的几个段寄存器包括：</p>
<ul>
<li>CS：代码段寄存器</li>
<li>DS：数据段寄存器</li>
<li>SS：堆栈段寄存器</li>
</ul>
<p>段寄存器的结构是这样的：</p>
<ul>
<li>高13位：GDT index</li>
<li>1位：TI，一般设置为0，因为没有用到LDT（本地描述符表）</li>
<li>2位：RP，表明段优先级，有4个特权级，一般应用程序放在3，操作系统放在0</li>
</ul>
<p>每个段寄存器指向一个GDT或LDT中的段描述符。段描述符描述了一个段的起始地址和它的大小。（一个段描述符的大小是8字节，具体内容比较复杂，不过知道这两点差不多就够了）</p>
<p>uCore中采用的应该是Intel手册中提到的扁平保护模型。</p>
<p><img src="fig3-3_protected_flat_model.png" alt="扁平保护模型"></p>
<p>在设置完所需的表和寄存器之后，段机制就可以完成从逻辑地址到线性地址（在页机制没有开启的时候，线性地址=物理地址）的翻译了。具体的翻译过程如下图：</p>
<p><img src="fig3-5_logical_addr_to_linear_addr.png" alt="逻辑地址到线性地址的翻译过程"></p>
<ul>
<li>通过逻辑地址中的段选择子查找段描述符表项</li>
<li>从表项中读出段基址和段的大小</li>
<li>检查逻辑地址中的offset是否合法</li>
<li>安全性检查（这里还没有讲到）</li>
<li>段基址（Base Address）+段内偏移量（offset）=线性地址（linear address）</li>
</ul>
<h5 id="操作系统的加载"><a class="markdownIt-Anchor" href="#操作系统的加载"></a> 操作系统的加载</h5>
<p>操作系统的加载过程其实就是把ELF文件中的内容填到合适的位置。ELF文件的开头是一个ELF Header，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* file header */</span><br><span class="line">struct elfhdr &#123;</span><br><span class="line">    uint32_t e_magic;     // must equal ELF_MAGIC</span><br><span class="line">    uint8_t e_elf[12];</span><br><span class="line">    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image</span><br><span class="line">    uint16_t e_machine;   // 3=x86, 4=68K, etc.</span><br><span class="line">    uint32_t e_version;   // file version, always 1</span><br><span class="line">    uint32_t e_entry;     // entry point if executable</span><br><span class="line">    uint32_t e_phoff;     // file position of program header or 0</span><br><span class="line">    uint32_t e_shoff;     // file position of section header or 0</span><br><span class="line">    uint32_t e_flags;     // architecture-specific flags, usually 0</span><br><span class="line">    uint16_t e_ehsize;    // size of this elf header</span><br><span class="line">    uint16_t e_phentsize; // size of an entry in program header</span><br><span class="line">    uint16_t e_phnum;     // number of entries in program header or 0</span><br><span class="line">    uint16_t e_shentsize; // size of an entry in section header</span><br><span class="line">    uint16_t e_shnum;     // number of entries in section header or 0</span><br><span class="line">    uint16_t e_shstrndx;  // section number that contains section name strings</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中比较重要的变量是<code>e_phoff</code>（第一个Program Header的地址），<code>e_phnum</code>（文件中共有几个Program Header）和<code>e_magic</code>（用来检验该Header是否合法）。<code>bootmain.c</code>中的代码首先读一页（主引导扇区之后的8个扇区），得到ELF Header；然后，通过上述变量，可以依次访问各个Program Header。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* program section header */</span><br><span class="line">struct proghdr &#123;</span><br><span class="line">    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.</span><br><span class="line">    uint32_t p_offset; // file offset of segment</span><br><span class="line">    uint32_t p_va;     // virtual address to map segment</span><br><span class="line">    uint32_t p_pa;     // physical address, not used</span><br><span class="line">    uint32_t p_filesz; // size of segment in file</span><br><span class="line">    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）</span><br><span class="line">    uint32_t p_flags;  // read/write/execute bits</span><br><span class="line">    uint32_t p_align;  // required alignment, invariably hardware page size</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后通过每个Progeam Header中的<code>ph-&gt;p_memsz</code>（一个代码段的大小）和<code>ph-&gt;p_offset</code>（一个代码段的虚地址），可以从磁盘中读出对应内容，并存储到内存的对应位置（虚地址处）。</p>
<h3 id="c语言的一些相关知识"><a class="markdownIt-Anchor" href="#c语言的一些相关知识"></a> C语言的一些相关知识</h3>
<h4 id="函数调用的实现"><a class="markdownIt-Anchor" href="#函数调用的实现"></a> 函数调用的实现</h4>
<ul>
<li>将需要保存的寄存器入栈，调用函数，然后将需要保存的寄存器出栈</li>
<li>EBP指向的是栈底，其中保存的是调用者的EBP；ESP指向的是栈顶；</li>
<li>调用时会把返回地址也入栈，在EBP下面，再下面是参数</li>
</ul>
<p>其他注意事项：</p>
<ul>
<li>参数和函数返回值可以通过寄存器或位于内存中的栈来传递</li>
<li>不需要保存/恢复（save/restore）所有寄存器（因为寄存器按传统分为caller save和callee save两类）</li>
</ul>
<h4 id="gcc内联汇编"><a class="markdownIt-Anchor" href="#gcc内联汇编"></a> GCC内联汇编</h4>
<p>内联汇编的完整格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm (assembler template  // 字符串</span><br><span class="line">  : output operands (optional)  // 约束：把某个变量用某个寄存器来表示</span><br><span class="line">  : input operands (optional)</span><br><span class="line">  : clobbers (optional)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="例1不带任何约束的简单内联汇编"><a class="markdownIt-Anchor" href="#例1不带任何约束的简单内联汇编"></a> 例1：不带任何约束的简单内联汇编</h5>
<p>内联汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asm(&quot;movl $0xffff, %%eax\n&quot;)</span><br></pre></td></tr></table></figure>
<p>生成的汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl $0xffff, %eax</span><br></pre></td></tr></table></figure>
<h5 id="例2使用特定寄存器和约束的内联汇编"><a class="markdownIt-Anchor" href="#例2使用特定寄存器和约束的内联汇编"></a> 例2：使用特定寄存器和约束的内联汇编</h5>
<p>内联汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint32_t cr0;</span><br><span class="line">asm volatile(&quot;movl %%cr0, %0\n&quot; : &quot;=r&quot;(cr0));  // %0寄存器对应的变量是cr0</span><br><span class="line">cr0 |= 0x80000000;</span><br><span class="line">asm volatile(&quot;movl %0, %%cr0\n&quot; :: &quot;r&quot;(cr0));  // 把cr0变量中的值赋给cr0寄存器</span><br></pre></td></tr></table></figure>
<p>生成的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl %cr0, %ebx</span><br><span class="line">movl %ebx, 12(%esp)</span><br><span class="line">ori $-2147483648, 12(%esp)</span><br><span class="line">movl 12(%esp), %eax</span><br><span class="line">movl %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>其中关键字的含义如下：</p>
<ul>
<li><code>volatile</code>：不需要做进一步优化和调整顺序</li>
<li><code>%0</code>：第一个约束</li>
<li><code>r</code>：约束：GCC可以使用任意寄存器</li>
</ul>
<h5 id="例3使用内联汇编触发系统中断"><a class="markdownIt-Anchor" href="#例3使用内联汇编触发系统中断"></a> 例3：使用内联汇编触发系统中断</h5>
<p>内联汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long __res, arg1=2, arg2=22, arg3=222, arg4=233;</span><br><span class="line">__asm__ volatile(&quot;int $0x80&quot;</span><br><span class="line">  : &quot;=a&quot; (__res)</span><br><span class="line">  : &quot;0&quot;(11), &quot;b&quot;(arg1), &quot;c&quot;(arg2), &quot;d&quot;(arg3), &quot;S&quot;(arg4));</span><br></pre></td></tr></table></figure>
<p>生成的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl $11, %eax</span><br><span class="line">movl -28(%ebp), %ebx</span><br><span class="line">movl -24(%ebp), %ecx</span><br><span class="line">movl -20(%ebp), %edx</span><br><span class="line">movl -16(%ebp), %esi</span><br><span class="line">int $0x80  ## 产生软中断</span><br><span class="line">movl %edi, -12(%ebp)</span><br></pre></td></tr></table></figure>
<p>其中约束条件的含义如下：</p>
<ul>
<li>a=%eax</li>
<li>b=%ebx</li>
<li>c=%ecx</li>
<li>d=%edx</li>
<li>S=%esi</li>
<li>D=%edi</li>
<li>0=和第一个寄存器相同</li>
</ul>
<h3 id="x86架构下的中断处理过程"><a class="markdownIt-Anchor" href="#x86架构下的中断处理过程"></a> x86架构下的中断处理过程</h3>
<p>此处的“中断”包括两类：</p>
<ul>
<li>中断（Interrupts）
<ul>
<li>外部中断（External (hardware generated) interrupts）：串口、硬盘、网卡、时钟</li>
<li>软件产生的中断（Software generated interrupts）：INT n指令，通常用于系统调用</li>
</ul>
</li>
<li>异常（Exceptions）
<ul>
<li>程序错误</li>
<li>软件产生的异常（Software generated exception）：INTO，INT 3和BOUND</li>
<li>机器检查出的异常</li>
</ul>
</li>
</ul>
<h4 id="通过中断号确定中断服务例程isr"><a class="markdownIt-Anchor" href="#通过中断号确定中断服务例程isr"></a> 通过中断号确定中断服务例程（ISR）</h4>
<p>IDT是由操作系统分配的（Lab1的其中一个练习），在分配完空间并填充好IDT之后，需要用特权指令填充中断描述符表寄存器IDTR。</p>
<p>一般来说，每个中断或异常都有一个中断号，每个中断号与一个中断服务例程（Interrupt Service Routine，ISR）关联，其关联关系存储在中断描述符表（Interrupt Descriptor Table，IDT）中。IDT的每一项称为“中断门”或“陷阱门”。IDT的起始地址和大小保存在中断描述符表寄存器IDTR中，地址的表示也需要用到GDT（地址与段相关）。</p>
<p>IDT表中一般可能会含有三种门：中断门、陷阱门和任务门（目前没有用到），每一种门的格式如下：</p>
<p><img src="fig5-2_idt_gate_descriptors.png" alt="IDT门描述符的格式"></p>
<p>可以看出，中断门和陷阱门的格式类似，其中的核心内容包括：</p>
<ul>
<li>段选择子：16位，表示ISR所在的段</li>
<li>段内偏移量：32位，表示ISR地址在段内的偏移量</li>
<li>DPL：用于进行安全性检查（现在还没用到）</li>
</ul>
<p>可以看出，IDT表项实质上就是存储了很多ISR的逻辑地址。通过IDT和GDT（或LDT）访问ISR的过程如下图：</p>
<p><img src="fig6-3_interrupt_procedure_call.png" alt="中断服务例程调用过程"></p>
<h4 id="调用isr和从isr返回的过程"><a class="markdownIt-Anchor" href="#调用isr和从isr返回的过程"></a> 调用ISR和从ISR返回的过程</h4>
<p>中断服务例程的调用和返回这个过程是非常重要的。因为它是用户态进程获得（或者强制进入）OS服务的唯一途径，所以需要进行现场的保存和特权级的切换。这个是非常重要的。</p>
<p>Intel手册6.12.1节“Exception- or Interrupt-Handler Procedures”中说，处理器调用中断服务例程的过程是这样的：</p>
<ul>
<li>如果该中断服务例程将运行在一个更高的特权级下，则会发生栈切换，过程如下：
<ul>
<li>从当前执行任务的TSS中获得ISR将会使用的段选择子和栈指针，将被打断的程序的堆栈段选择子和栈指针压入新栈中</li>
<li>处理器随后将EFLAGS、CS和EIP寄存器的当前值也压入新栈中</li>
<li>如果异常有错误码，则将错误码也压入栈中，位于EIP寄存器的值之后</li>
</ul>
</li>
<li>如果该中断服务例程的特权级不变：
<ul>
<li>处理器直接将EFLAGS、CS和EIP寄存器的当前值压入当前栈中</li>
<li>如果异常有错误码，则将错误码也压入栈中，位于EIP寄存器的值之后</li>
</ul>
</li>
</ul>
<p>下图展示了这一过程（注意栈是向下增长的）：<br>
<img src="fig6-4_stack_usage_on_isr_transfer.png" alt="调用中断服务例程时栈的使用情况"></p>
<p>从中断服务例程返回时，必须使用IRET（或IRETD）指令。IRET指令类似于RET指令，但是它会对保存的寄存器和EFLAGS进行恢复（EFLAGS可能会进行一些修改）。如果调用中断服务例程时发生了栈切换，则IRET指令会在返回时切换回被打断的程序的栈。</p>
<h4 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h4>
<p>系统调用的实现方法是：</p>
<ul>
<li>指定中断号</li>
<li>使用Trap</li>
<li>或使用特殊指令（SYSENTER/SYSEXIT）</li>
</ul>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>80386机器加电启动后，CPU立刻跳转到()执行</strong></p>
<ul>
<li>ucore第一条指令</li>
<li>bootloader第一条指令</li>
<li><strong>BIOS的第一条指令</strong></li>
<li>GRUB的第一条指令</li>
</ul>
<p>加电后的第一条指令是长跳转指令，跳到BIOS去执行。</p>
<hr>
<p><strong>应用程序中的C函数调用中不需要用到()指令</strong></p>
<ul>
<li>push</li>
<li>ret</li>
<li><strong>iret</strong></li>
<li>call</li>
</ul>
<p>iret用于中断服务例程返回。应用程序编写不需要用到IRET。</p>
<hr>
<p><strong>GCC内联汇编 asm(“movl %ecx, %eax”); 的含义是()</strong></p>
<ul>
<li><strong>把 ecx 内容移动到 eax</strong></li>
<li>把 eax 内容移动到 ecx</li>
</ul>
<p>答案是把 ecx 内容移动到 eax。这是显然的AT&amp;T汇编语法。</p>
<hr>
<p><strong>为了让系统正确完成80386的中断处理过程，操作系统需要正确设置()</strong></p>
<ul>
<li><strong>全局描述符表</strong></li>
<li><strong>中断描述符表</strong></li>
<li><strong>中断服务例程</strong></li>
<li><strong>内核堆栈</strong></li>
</ul>
<p>在ucore处理中，上述几个都是要设置好的。显然ISR是必须准备好的。因为中断服务例程会使用内核栈，所以内核堆栈也要设置。发生中断时，硬件通过IDT找到中断号对应的中断描述符，再根据其中的ISR的逻辑地址，通过GDT或LDT得到ISR的线性地址。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>段寄存器的字段含义和功能有哪些？</strong></p>
<ul>
<li>代码段寄存器 CS（Code Segment）存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供</li>
<li>数据段寄存器 DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址</li>
<li>堆栈段寄存器 SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址</li>
<li>附加段寄存器 ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段</li>
<li>附加段寄存器 FS</li>
<li>附加段寄存器 GS</li>
</ul>
<p>常用的就是CS、DS和SS。</p>
<p><strong>描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？</strong></p>
<p>参见<a href="https://blog.csdn.net/better0332/article/details/3416749" target="_blank" rel="noopener">DPL,RPL,CPL 之间的联系和区别</a>一文中对特权级的表述。</p>
<ul>
<li>CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。</li>
<li>RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它的CPL=0对该段仍然只有特权为3的访问权限。</li>
<li>DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。</li>
</ul>
<p>对数据段和堆栈段访问时的特权级控制：要求访问数据段或堆栈段的程序的CPL≤待访问的数据段或堆栈段的DPL，同时选择子的RPL≤待访问的数据段或堆栈段的DPL，即程序访问数据段或堆栈段要遵循一个准则：只有相同或更高特权级的代码才能访问相应的数据段。这里，RPL可能会削弱CPL的作用，访问数据段或堆栈段时，默认用CPU和RPL中的最小特权级去访问数据段，所以要求<strong>max{CPL, RPL} ≤ DPL</strong>，否则访问失败。</p>
<hr>
<p><strong>分析可执行文件格式elf的格式（无需回答）</strong></p>
<ul>
<li>ELF header的格式
<ul>
<li><a href="http://wiki.osdev.org/ELF" target="_blank" rel="noopener">文档：Header</a></li>
<li><a href="https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab1_result/libs/elf.h#L9" target="_blank" rel="noopener">代码</a></li>
</ul>
</li>
<li>proghdr的格式分析
<ul>
<li><a href="http://wiki.osdev.org/ELF" target="_blank" rel="noopener">文档：Program header</a></li>
<li><a href="https://github.com/chyyuu/ucore_os_lab/blob/master/labcodes_answer/lab1_result/libs/elf.h#L28" target="_blank" rel="noopener">代码</a></li>
</ul>
</li>
</ul>
<p><strong>中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？</strong></p>
<p>参见实验指导书<a href="https://objectkuan.gitbooks.io/ucore-docs/lab1/lab1_3_3_2_interrupt_exception.html" target="_blank" rel="noopener">中断与异常</a>部分。当然，上面已经讲得非常详细了。</p>
<p><strong>为什么在用户态的中断响应要使用内核堆栈？</strong><br>
保护中断服务例程代码的安全。</p>
<p>粗略地思考一下，虽然ISR需要在内核态下执行，使用用户态堆栈也不是不可以。代码安全这个我现在是想不清楚了。</p>
<hr>
<p><strong>trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?</strong></p>
<p>调用Interrupt Gate时，Interrupt会被CPU自动禁止<br>
调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子<br>
如果在设置上不做区分，会导致重复触发中断。</p>
<p>硬件中断是可以嵌套的，但指的并不是在处理一个硬件中断的过程中把这个过程打断，而是先关掉中断，处理完当前中断之后再顺序处理下一个。</p>
<hr>
<p><strong>在<code>kdebug.c</code>文件中用到的函数<code>read_ebp</code>是内联的，而函数<code>read_eip</code>不是内联的。为什么要设计成这样？</strong></p>
<p>ebp可以直接获得，若不内联，则会因为函数调用对栈的修改而得到错误的ebp值。而由于没有直接获取eip值的指令，我们需要利用call指令将eip压栈的特性，通过调用read_eip函数来读出压在栈上的eip的值。若将read_eip内联，则不会有函数调用存在，无法获得eip的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static __noinline uint32_t</span><br><span class="line">read_eip(void) &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    asm volatile(&quot;movl 4(%%ebp), %0&quot; : &quot;=r&quot; (eip));</span><br><span class="line">    return eip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>CPU加电初始化后中断是使能的吗？为什么？</strong><br>
不是。CPU启动后，BIOS会在POST自检完成后在内存中建立中断向量表和中断服务程序。</p>
<p>主要还是因为这个时候还在实模式下，根本没有处理普通中断的能力。不过，在实模式下，需要通过某些中断的手段来实现输入输出，这些方法都不能在保护模式下使用。</p>
<hr>
<p><strong>如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？</strong></p>
<hr>
<p><strong>在lab1/bin目录下，通过<code>objcopy -O binary kernel kernel.bin</code>可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)</strong></p>
<p><strong>GRUB是一个通用的bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)</strong></p>
<p>–</p>
<p><strong>如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？</strong></p>
<h3 id="课堂实践"><a class="markdownIt-Anchor" href="#课堂实践"></a> 课堂实践</h3>
<p><strong>在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。</strong></p>
<hr>
<p><strong>在ucore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。</strong></p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-3-summary/">
              
                  《操作系统》第3讲：“启动、中断、异常和系统调用”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-12
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>这节课的主要内容包括：</p>
<ul>
<li>系统启动过程
<ul>
<li>BIOS的原理</li>
<li>BIOS的一些具体工作</li>
<li>系统启动规范</li>
</ul>
</li>
<li>中断，异常和系统调用
<ul>
<li>中断</li>
<li>系统调用</li>
</ul>
</li>
</ul>
<h3 id="系统启动过程"><a class="markdownIt-Anchor" href="#系统启动过程"></a> 系统启动过程</h3>
<h4 id="bios的基本功能"><a class="markdownIt-Anchor" href="#bios的基本功能"></a> BIOS的基本功能</h4>
<p>计算机刚刚启动时的内存布局如图：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>(4GB - 64KB) ~ 4GB</td>
<td>实际BIOS ROM</td>
</tr>
<tr>
<td>1MB ~ (4GB - 64KB)</td>
<td>空闲空间</td>
</tr>
<tr>
<td>640KB ~ 1MB</td>
<td>视频内存，BIOS启动固件（映射）</td>
</tr>
<tr>
<td>0 ~ 640KB</td>
<td>空闲空间</td>
</tr>
</tbody>
</table>
<p>（这是一个非常简略的示意图，具体请见<a href="https://wiki.osdev.org/Memory_Map_(x86)" target="_blank" rel="noopener">Memory Map (x86)</a>）</p>
<blockquote>
<p>这一复杂的映射机制是为了保证向后兼容而设计的。在8086时代，内存只有1MB大小，此时，BIOS的代码固化在EPROM中，且EPROM被编址在1MB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为<code>CS:IP=0xF000:0XFFF0</code>（ Segment:Offset表示） =<code>0xFFFF0</code>（ Linear表示） 。这个地址位于被固化的EPROM中，该地址存储了一条指令，它是一个长跳转指令<code>JMP F000:E05B</code>。这样就开启了BIOS的执行过程。</p>
</blockquote>
<blockquote>
<p>到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制。如果仍然把BIOS启动固件编址在0xF0000起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是0xF0000以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的shadow register的Base值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是0xFFFFFFF0。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。注意，这个长跳转指令会更新CS寄存器和它的shadowregister，即执行<code>jmp F000:E05B</code>后，CS将被更新成<code>0xF000</code>。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成<code>0x000F0000</code>，此时形成的物理地址为<code>Base+EIP=0x000FE05B</code>，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容。</p>
</blockquote>
<p>上述说明指出，在CPU启动之后，它处于实模式之下，执行的第一条指令是<code>jmp F000:E05B</code>，跳转到BIOS程序中。此时，<code>PC = 16*CS + IP</code>，系统地址空间只有20位（1MB）。</p>
<p>• 20位地址空间：1MB</p>
<p>这之后BIOS会进行以下工作：</p>
<ul>
<li>在实模式下提供基本输入输出方法
<ul>
<li>通过中断调用实现</li>
<li>只能在实模式下使用，操作系统不能使用</li>
</ul>
</li>
<li>运行自检程序</li>
<li>用户选择引导设备（从什么介质启动）</li>
<li>将bootloader从磁盘的引导扇区加载到内存中<code>0x7c00</code>开始的位置</li>
<li>跳转到bootloader的位置：<code>CS:IP=0000:7c00</code><br>
• 系统设置信息：<br>
• 开机后自检程序<br>
• 系统自启动程序等</li>
</ul>
<p>这之后，控制权就交给bootloader：</p>
<ul>
<li>切换到保护模式</li>
<li>将操作系统的代码和数据从硬盘加载到内存中（因为BIOS无法处理硬盘的文件系统）</li>
<li>跳转到操作系统的起始地址</li>
</ul>
<p>加载之后的内存布局如下表：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>(4GB - 64KB) ~ 4GB</td>
<td>实际BIOS ROM</td>
</tr>
<tr>
<td>? ~ (4GB - 64KB)</td>
<td>空闲空间</td>
</tr>
<tr>
<td>1MB ~ ?</td>
<td>操作系统</td>
</tr>
<tr>
<td>640KB ~ 1MB</td>
<td>视频内存，BIOS启动固件（映射）</td>
</tr>
<tr>
<td>? ~ 640KB</td>
<td>空闲空间</td>
</tr>
<tr>
<td>0x7c00 ~ ?</td>
<td><strong>bootloader</strong></td>
</tr>
<tr>
<td>0 ~ 0x7c00</td>
<td>BIOS数据</td>
</tr>
</tbody>
</table>
<p>最后，bootloader把控制权转交给操作系统。</p>
<h4 id="bios的一些具体工作"><a class="markdownIt-Anchor" href="#bios的一些具体工作"></a> BIOS的一些具体工作</h4>
<p>上面这些听起来都很不错，但是课程中还涉及了很多烦人的细节。姑且摘录如下：</p>
<h5 id="bios本身的初始化内容"><a class="markdownIt-Anchor" href="#bios本身的初始化内容"></a> BIOS本身的初始化内容</h5>
<p>包括：</p>
<ul>
<li>硬件自检POST</li>
<li>检测系统中内存和显卡等关键部件的存在和工作状态</li>
<li>查找并执行显卡等接口卡BIOS，进行设备初始化</li>
<li>执行系统BIOS，进行系统检测：检测和配置系统中安装的即插即用设备</li>
<li>更新CMOS中的扩展系统配置数据ESCD</li>
<li>按指定启动顺序从硬盘、软盘等设备启动</li>
</ul>
<h5 id="bios如何读取bootloader"><a class="markdownIt-Anchor" href="#bios如何读取bootloader"></a> BIOS如何读取bootloader</h5>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">Wiki</a>上是这么说的：</p>
<ul>
<li>系统开机或者重启。
<ul>
<li>BIOS加电（台湾用语：开机）自检（Power On Self Test – POST）。BIOS执行内存地址为FFFF:0000H处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件（包括内存）进行检查。</li>
<li>读取主引导记录（MBR）。当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处。</li>
<li>检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示&quot;NO ROM BASIC&quot;然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处，然后继续执行。<br>
根据MBR中的引导代码启动引导程序。</li>
</ul>
</li>
<li>事实上，BIOS不仅检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查。如果发现磁盘有写保护，则显示磁盘写保护出错信息；如果发现磁盘中不存在活动分区，则显示类似如下的信息“Remove disk or other media Press any key to restart”。</li>
</ul>
<p>我觉得这个wiki讲得十分清楚，所以就不摘录课件内容了。</p>
<p>标准MBR的结构如下：</p>
<table>
<thead>
<tr>
<th>地址（十进制）</th>
<th>描述</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>代码区</td>
<td>440（最大446）</td>
</tr>
<tr>
<td>440</td>
<td>选用磁盘标志</td>
<td>4</td>
</tr>
<tr>
<td>444</td>
<td>一般为空值; 0x0000</td>
<td>2</td>
</tr>
<tr>
<td>446</td>
<td>标准MBR分区表规划（四个16 byte的主分区表入口）</td>
<td>64</td>
</tr>
<tr>
<td>510</td>
<td>MBR有效标志：0x55AA</td>
<td>2</td>
</tr>
</tbody>
</table>
<h4 id="系统启动规范"><a class="markdownIt-Anchor" href="#系统启动规范"></a> 系统启动规范</h4>
<p>课程中还讲到了BIOS-MBR、BIOS-GPT、PXE和UEFI等系统启动规范，其中UEFI似乎还更重要一点。这似乎是通用的现代BIOS标准。</p>
<h3 id="中断-异常和系统调用"><a class="markdownIt-Anchor" href="#中断-异常和系统调用"></a> 中断、异常和系统调用</h3>
<p>首先下个定义：</p>
<ul>
<li>系统调用（system call）：应用程序主动向操作系统发出的服务请求</li>
<li>异常（exception）：非法指令或其他原因导致当前指令执行失败（如：内存出错）后的处理请求</li>
<li>中断（hardware interrupt）：来自硬件设备的处理请求</li>
</ul>
<p>它们的相同之处是，采用的处理方式大致相同。无论是发生异常、中断，还是系统调用，都需要由硬件保存现场和中断号，转到内核态，进入中断向量表，查找对应的设备驱动程序地址（异常）、异常服务例程地址（异常），或找到系统调用表，并在其中查找对应的系统调用实现的起始地址。处理完毕之后，再进行现场的切换，回到用户态继续执行程序（如果可以继续的话）。</p>
<p><img src="interrupt_exception_syscall.jpg" alt="中断、异常和系统调用处理流程"></p>
<p>它们的区别如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>源头</th>
<th>响应方式</th>
<th>处理机制</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对用户应用程序是透明的</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序或内核意想不到的行为</td>
<td>同步</td>
<td>杀死或重新执行意想不到的应用程序指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求操作提供服务</td>
<td>异步或同步</td>
<td>等待和持续</td>
</tr>
</tbody>
</table>
<p>这三者的处理有时可以嵌套，有时不可以。Intel手册中把中断、异常和系统调用分为Benign、Contributry和Page Fault三类：<br>
<img src="table-6-4-interrupt-and-exception-classes.png" alt="中断和异常分类"></p>
<p>其中8号异常没有列在分类中，因为它是就是Double Fault的中断号。当嵌套中断/异常发生时，根据种类的不同，处理方式也有所不同：<br>
<img src="table-6-5-conditions-for-generating-a-double-fault.png" alt="可能产生Double Fault的情况"></p>
<p>从中可以了解很多有趣的事实。比如，硬件中断“Device Not Available”和系统调用都属于Benign类，因此它们可以和任何其他中断/异常进行嵌套；而Page Fault就不可嵌套（很有道理；如果连缺页服务例程自己都缺页了，那根本就没法解决）。</p>
<p>（以上内容也参考了<a href="http://www.lenky.info/archives/2012/04/1479" target="_blank" rel="noopener">Double Fault &amp; Triple Fault</a>一文）</p>
<p>相比于用户态的函数调用，中断和异常的开销是比较大的，因为它们需要进行：</p>
<ul>
<li>特权级的切换</li>
<li>建立内核堆栈</li>
<li>验证参数的合法性（防止对内核的恶意攻击）</li>
<li>内核态需要映射到用户态的地址空间（因为需要访问用户程序的一些内容），因此需要更新页面映射权限</li>
<li>内核态也拥有独立的地址空间，因此TLB会失效</li>
</ul>
<h4 id="中断的具体处理机制"><a class="markdownIt-Anchor" href="#中断的具体处理机制"></a> 中断的具体处理机制</h4>
<p>中断处理的过程需要软件和硬件的配合（虽然系统调用和异常也是……）<br>
硬件处理内容包括：</p>
<ul>
<li>在CPU初始化时设置中断使能标志</li>
<li>依据内部或外部事件设置中断标志</li>
<li>依据中断向量调用对应的中断服务例程<br>
软件处理内容包括：</li>
<li>现场保存（编译器）</li>
<li>中断服务处理（服务例程）</li>
<li>清除中断标记（服务例程）（系统调用只占用一个中断向量，另有系统调用表）</li>
<li>现场恢复（编译器）</li>
</ul>
<h4 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h4>
<h5 id="系统调用的特点"><a class="markdownIt-Anchor" href="#系统调用的特点"></a> 系统调用的特点</h5>
<ul>
<li>系统调用是操作系统服务的编程接口</li>
<li>通常由高级语言编写（C或C++）</li>
<li>程序访问系统调用通常是通过高层次的API接口（比如封装到标准C库—）而不是直接进行系统调用</li>
<li>3种最常用的应用程序编程接口（API）：
<ul>
<li>Win32 API：Windows</li>
<li>POSIX API：UNIX、LINUX、Mac OS X</li>
<li>Java API：用于JAVA虚拟机（JVM），是对实际系统调用的进一步抽象</li>
</ul>
</li>
</ul>
<h5 id="系统调用的实现"><a class="markdownIt-Anchor" href="#系统调用的实现"></a> 系统调用的实现</h5>
<ul>
<li>每个系统调用对应一个系统调用号
<ul>
<li>系统调用接口根据系统调用号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果</li>
<li>用户不需要知道系统调用的实现
<ul>
<li>需要设置调用参数和获取返回结果</li>
<li>操作系统接口的细节大部分都隐藏在应用编程接口后</li>
</ul>
</li>
<li>通过运行程序支持的库来管理</li>
</ul>
<p>注意，系统调用时，<strong>堆栈需要切换</strong>（内核和用户程序使用的是不同的堆栈），<strong>特权级需要进行转换</strong>。</p>
<h5 id="ucore中系统调用的具体实现"><a class="markdownIt-Anchor" href="#ucore中系统调用的具体实现"></a> uCore中系统调用的具体实现</h5>
<p>以<code>read(fd, buffer, length)</code>的实现为例：</p>
<ol>
<li>用<code>vectors.S</code>中的内容填充IDT表</li>
<li>发生系统调用时，硬件访问IDT表后，跳转到中断服务例程，对中断进行具体处理</li>
<li><code>kern/trap/trapentry.S:alltraps()</code>：中断服务例程</li>
<li><code>kern/trap/trap.c:trap()</code>：针对中断类型进行具体处理
<ol>
<li><code>tf-&gt;trapno == T_SYSCALL</code>：中断类型为系统调用，调用具体的系统调用处理函数</li>
</ol>
</li>
<li><code>kern/syscall/syscall.c:syscall()</code>：进行系统调用
<ol>
<li><code>tf-&gt;tf_regs.reg_eax == SYS_read</code>：读eax（系统调用编号），得到具体是哪个系统调用</li>
</ol>
</li>
<li><code>kern/syscall/syscall.c:sys_read()</code>：处理<code>SYS_READ</code>系统调用，从<code>tf-&gt;sp</code>获取堆栈中的参数（<code>fd</code>, <code>buf</code>, <code>length</code>）</li>
<li><code>kern/fs/sysfile.c:sysfile_read()</code>：<code>SYS_READ</code>系统调用的更具体实现，读取文件，直接操纵驱动程序</li>
<li><code>kern/trap/trapentry.S:trapret()</code>：中断处理返回，将所需内容返回给用户态</li>
</ol>
<h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/02-1-spoc-discussion.md" target="_blank" rel="noopener">lec 3 SPOC Discussion</a>。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>BIOS从磁盘读入的第一个扇区是是什么内容？为什么没有直接读入操作系统内核映像？</strong></p>
<p>BIOS完成硬件初始化和自检后，会根据CMOS中设置的启动顺序启动相应的设备，这里假定按顺序系统要启动硬盘。但此时，文件系统并没有建立，BIOS也不知道硬盘里存放的是什么，所以BIOS是无法直接启动操作系统。另外一个硬盘可以有多个分区，每个分区都有可能包括一个不同的操作系统，BIOS也无从判断应该从哪个分区启动，所以对待硬盘，所有的BIOS都是读取硬盘的0磁头、0柱面、1扇区的内容，然后把控制权交给这里面的MBR (Main Boot Record）。</p>
<p>我认为上述答案并不十分确切。比如，在uCore中，虽然BIOS没有建立文件系统，bootloader也没有建立文件系统啊。但是，加载操作系统是个很复杂的过程：就比如uCore，我们需要完成对ELF文件格式的解析和文件本身的读入。BIOS工作在实模式，本身访存范围只有1MB（能使用的数据只有0 ~ 0x7c00的范围），而且代码长度被限制在64KB。为了将OS读入到高地址的内存中，需要BIOS进行模式的切换。但是，如果BIOS进行了实模式到保护模式的切换，就不能实现向后兼容了。而且不同的OS的文件格式和处理方法也有差异，这会导致BIOS十分复杂。因此，让OS提供自己的启动程序是最好的选择。</p>
<hr>
<p><strong>比较UEFI和BIOS的区别。</strong></p>
<p>统一可扩展固件接口 (Unified Extensible Firmware Interface, UEFI) 是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。</p>
<p>UEFI启动对比BIOS启动的优势有三点：</p>
<ul>
<li>安全性更强：UEFI启动需要一个独立的分区，它将系统启动文件和操作系统本身隔离，可以更好的保护系统的启动；</li>
<li>启动配置更灵活：EFI启动和GRUB启动类似，在启动的时候可以调用EFIShell，在此可以加载指定硬件驱动，选择启动文件。比如默认启动失败，在EFIShell加载U盘上的启动文件继续启动系统；</li>
<li>支持容量更大：传统的BIOS启动由于MBR的限制，默认是无法引导超过2TB以上的硬盘的。随着硬盘价格的不断走低，2TB以上的硬盘会逐渐普及，因此UEFI启动也是今后主流的启动方式。</li>
</ul>
<hr>
<p><strong>分区引导扇区的结束标志是什么？</strong></p>
<p><code>0X55AA</code>。当然，上面也说到了，BIOS除此之外还会检查别的内容。</p>
<hr>
<p><strong>在UEFI中的可信启动有什么作用？</strong></p>
<p>通过启动前的数字签名检查来保证启动介质的安全性。</p>
<hr>
<p><strong>什么是中断、异常和系统调用？</strong></p>
<ul>
<li>中断：外部意外的响应；</li>
<li>异常：指令执行意外的响应；</li>
<li>系统调用：系统调用指令的响应。</li>
</ul>
<p>这个回答真是十分简洁明了。</p>
<hr>
<p><strong>中断、异常和系统调用的处理流程有什么异同？</strong></p>
<ul>
<li>相同点：都会进入异常服务例程，切换为内核态。</li>
<li>不同点：
<ul>
<li>源头不同，中断源是外部设备，异常和系统调用源是应用程序；</li>
<li>响应方式不同，中断是异步的，异常是同步的，系统调用异步和同步都可以。</li>
<li>处理机制不同，中断对用户程序是透明的，异常会重新执行用户指令或杀死用户进程，系统调用一般是用户程序调用的</li>
</ul>
</li>
</ul>
<hr>
<p><strong>以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？</strong></p>
<p>打开<code>kern/syscall/syscall.c</code>，其中定义了如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int (*syscalls[])(uint32_t arg[]) = &#123;</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">    [SYS_gettime]           sys_gettime,</span><br><span class="line">    [SYS_lab6_set_priority] sys_lab6_set_priority,</span><br><span class="line">    [SYS_sleep]             sys_sleep,</span><br><span class="line">    [SYS_open]              sys_open,</span><br><span class="line">    [SYS_close]             sys_close,</span><br><span class="line">    [SYS_read]              sys_read,</span><br><span class="line">    [SYS_write]             sys_write,</span><br><span class="line">    [SYS_seek]              sys_seek,</span><br><span class="line">    [SYS_fstat]             sys_fstat,</span><br><span class="line">    [SYS_fsync]             sys_fsync,</span><br><span class="line">    [SYS_getcwd]            sys_getcwd,</span><br><span class="line">    [SYS_getdirentry]       sys_getdirentry,</span><br><span class="line">    [SYS_dup]               sys_dup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大致可以分为如下4类：</p>
<ul>
<li>进程管理：包括 fork/exit/wait/exec/yield/kill/getpid/sleep</li>
<li>文件操作：包括 open/close/read/write/seek/fstat/fsync/getcwd/getdirentry/dup</li>
<li>内存管理：pgdir命令</li>
<li>外设输出：putc命令</li>
</ul>
<hr>
<p><strong>通过分析<a href="https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md" target="_blank" rel="noopener">lab1_ex0</a>了解Linux应用的系统调用编写和含义。(仅实践，不用回答)</strong></p>
<p>按说是应该做一下的，但现在没有时间了……</p>
<hr>
<p><strong>通过调试<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab1/lab1-ex1.md" target="_blank" rel="noopener">lab1_ex1</a>了解Linux应用的系统调用执行过程。(仅实践，不用回答)</strong></p>
<p>按说是应该做一下的，但现在没有时间了……+1</p>
<hr>
<p><strong>基于实验八的代码分析ucore的系统调用实现，说明指定系统调用的参数和返回值的传递方式和存放位置信息，以及内核中的系统调用功能实现函数。</strong></p>
<p>在ucore中，执行系统调用前，需要将系统调用的参数储存在寄存器中。 eax表示系统调用类型，其余参数依次存在 edx, ecx, ebx, edi, esi 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">int num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">...</span><br><span class="line">arg[0] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">arg[1] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">arg[2] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">arg[3] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">arg[4] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说实话，我不知道这个题目在问什么。姑且把lab5 report中的说法粘贴过来：</p>
<p><code>fork</code>/<code>wait</code>/<code>exit</code>系统调用的执行过程，以<code>fork</code>为例：</p>
<ul>
<li>应用态进程调用<code>user/libs/ulib.c:fork</code>函数</li>
<li><code>user/libs/ulib.c:fork</code>调用<code>user/libs/syscall.c:sys_fork</code>函数</li>
<li><code>user/libs/syscall.c:sys_fork</code>函数调用user/libs/<code>syscall.c:syscall</code>函数，保存好相应的中断号和参数，引发系统调用中断</li>
<li><code>vectors.S:vector128</code>：系统调用对应的中断向量</li>
<li><code>trapentry.S:__alltraps</code>：进入中断处理例程</li>
<li><code>trap.c:trap</code></li>
<li><code>trap.c:trap_dispatch</code>：进入系统中断的具体处理例程</li>
<li><code>kern/syscall/syscall.c:syscall</code>：根据<code>%eax</code>寄存器中保存的值，进入<code>sys_fork</code>函数处理<code>SYS_fork</code>这一具体系统调用</li>
<li><code>kern/syscall/syscall.c:sys_fork</code>：调用<code>do_fork</code>函数</li>
<li><code>proc.c:do_fork</code></li>
</ul>
<hr>
<p><strong>以ucore lab8的answer为例，分析ucore应用的系统调用编写和含义。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syscall(int num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    uint32_t a[MAX_ARGS];</span><br><span class="line">    int i, ret;</span><br><span class="line">    for (i = 0; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;int %1;&quot;</span><br><span class="line">        : &quot;=a&quot; (ret)</span><br><span class="line">        : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">          &quot;a&quot; (num),</span><br><span class="line">          &quot;d&quot; (a[0]),</span><br><span class="line">          &quot;c&quot; (a[1]),</span><br><span class="line">          &quot;b&quot; (a[2]),</span><br><span class="line">          &quot;D&quot; (a[3]),</span><br><span class="line">          &quot;S&quot; (a[4])</span><br><span class="line">        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是用户态的<code>syscall</code>函数，其中<code>num</code>参数为系统调用号，该函数将参数准备好后，通过<code>SYSCALL</code>汇编指令进行系统调用，进入内核态，返回值放在<code>eax</code>寄存器，传入参数通过<code>eax</code>~<code>esi</code>依次传递进去。在内核态中，首先进入<code>trap()</code>函数，然后调用 <code>trap_dispatch()</code>进入中断分发，当系统得知该中断为系统调用后，OS调用如下的<code>syscall</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void) &#123;</span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    uint32_t arg[5];</span><br><span class="line">    int num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        if (syscalls[num] != NULL) &#123;</span><br><span class="line">            arg[0] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[1] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[2] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[3] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[4] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数得到系统调用号<code>num = tf-&gt;tf_regs.reg_eax;</code>，通过计算快速跳转到相应的<code>sys_</code>开头的函数，最终在内核态中，完成系统调用所需要的功能。</p>
<hr>
<p><strong>以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具strace的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。</strong></p>
<p>利用<code>trap.c</code>的<code>trap_in_kernel()</code>函数判断是否是用户态的系统调用，调用<code>syscall()</code>时传入此参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case T_SYSCALL:</span><br><span class="line">    syscall(trap_in_kernel(tf));</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<p>更改<code>syscall()</code>的函数原型为<code>void syscall(bool);</code>；</p>
<p>之后在<code>syscall(bool)</code>中加入输出即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">    if (syscalls[num] != NULL) &#123;</span><br><span class="line">        arg[0] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">        arg[1] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">        arg[2] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">        arg[3] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">        arg[4] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line"></span><br><span class="line">    if (!in_kernel) &#123;</span><br><span class="line">    	cprintf(&quot;SYSCALL: %d\n&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">        tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是qemu运行的输出结果片段，可以看出在用户程序输出前调用了<code>SYS_open</code>，输出<code>sh is running</code>的过程中调用了<code>SYS_write</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iter 1, No.0 philosopher_sema is thinking</span><br><span class="line">kernel_execve: pid = 2, name = &quot;sh&quot;.</span><br><span class="line">SYSCALL: 100</span><br><span class="line">SYSCALL: 100</span><br><span class="line">SYSCALL: 103</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>系统调用与函数调用的区别是什么？</strong></p>
<ul>
<li>汇编指令的区别
<ul>
<li>系统调用：使用INT和IRET指令</li>
<li>函数调用：使用CALL和RET指令</li>
</ul>
</li>
<li>安全性的区别
<ul>
<li>系统调用有堆栈和特权级的转换过程，函数调用没有这样的过程，系统调用相对更为安全</li>
</ul>
</li>
<li>性能的区别
<ul>
<li>时间角度：系统调用比函数调用要做更多和特权级切换的工作，所以需要更多的时间开销</li>
<li>空间角度：在一些情况下，如果函数调用采用静态编译，往往需要大量的空间开销，此时系统调用更具有优势</li>
</ul>
</li>
</ul>
<hr>
<p><strong>通过分析int、iret、call和ret的指令准确功能和调用代码，比较函数调用与系统调用的堆栈操作有什么不同？</strong></p>
<p>int指令压栈的内容请参考Interrupt and Exception Handling on the x86第10页。</p>
<h3 id="实践练习"><a class="markdownIt-Anchor" href="#实践练习"></a> 实践练习</h3>
<p>看不完了==</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-2-summary/">
              
                  《操作系统》第2讲：“实验0-操作系统实验环境准备”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-08
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>这节课的主要内容包括：</p>
<ul>
<li>对8个实验内容的更详细的介绍</li>
<li>对X86-32硬件的介绍</li>
<li>uCore的部分编程技巧和数据结构</li>
<li>如何使用工具编写和调试实验</li>
</ul>
<h3 id="实验具体内容"><a class="markdownIt-Anchor" href="#实验具体内容"></a> 实验具体内容</h3>
<p>我认为在此处把实验具体内容再列举一遍毫无意义。所以我给出了我自己对这些实验的意义的一个总结：</p>
<ul>
<li>0：实验环境准备
<ul>
<li>配置环境：安装适当的库、应用或直接下载虚拟机</li>
<li>我认为此时应该尝试编译一下答案，避免出现QEMU no output的情况</li>
<li>环境出问题时，不外乎就是<code>make clean</code>和重装两种解决方式</li>
</ul>
</li>
<li>1：系统启动及中断
<ul>
<li>这个实验主要是了解操作系统加载到内存，开始运行和处理中断的过程</li>
<li>大部分都是看和总结</li>
<li>有少量编程，但与硬件相关性极强，很难独立做出来</li>
</ul>
</li>
<li>2：物理内存管理
<ul>
<li>实现了一个管理空闲内存的算法，就是把一大块内存分页，然后按需求进行分配和释放</li>
</ul>
</li>
<li>3：虚拟内存管理
<ul>
<li>实现了虚拟内存管理，也就是PDE-&gt;PTE-&gt;Page的映射</li>
<li>实现了页替换算法，需要进行换入和换出</li>
<li>代码开始变得非常复杂</li>
</ul>
</li>
<li>4：内核线程管理
<ul>
<li>建立了一些新的内核线程</li>
<li>除了每个线程新建了一个内核栈之外，其实没有怎么用到虚拟内存管理，因为内核线程共用OS本身的内存管理结构</li>
<li>初步涉及了进程调度的概念</li>
<li>进程的切换是难点，不同特权级之间进程的切换是超难点（虽然此时还不需要）</li>
<li>细节很复杂</li>
</ul>
</li>
<li>5：用户进程管理
<ul>
<li>建立了用户线程，终于用到了特权级切换和虚拟内存管理</li>
<li>把用户进程的程序内容加载到虚拟空间中是一个难点；此时由于还没有文件系统，程序内容的位置是链接时生成的变量，在程序中直接使用</li>
<li>系统调用的实现过程与特权级很相关</li>
<li>程序的状态开始有了更多的意义；僵尸态、等待态、就绪态、执行态都出现了</li>
<li>仍然只是初步涉及了进程调度的概念</li>
<li>测试时有一些很坑爹的细节，比如需要修改lab1中的一些代码</li>
</ul>
</li>
<li>6：CPU调度
<ul>
<li>终于开始写调度算法了</li>
<li>过于水的一次lab，除了调度算法之外似乎什么都没有</li>
</ul>
</li>
<li>7：同步与互斥
<ul>
<li>难度突然上升的一次lab</li>
<li>需要先了解信号量和条件变量</li>
<li>利用信号量实现一个没有什么用处的哲学家就餐问题</li>
<li>利用信号量实现条件变量</li>
<li>利用管程机制再把完全没有什么用处的哲学家就餐问题实现一遍</li>
<li>总之这是一次注重理解的lab</li>
</ul>
</li>
<li>8：文件系统
<ul>
<li>代码量和难度再次直线上升！</li>
<li>首先理解uCore中文件系统的实现方法（细节十分多！特别多！巨多！代码巨多！）</li>
<li>然后尝试填写文件系统中某个层次的读文件的代码（反正我写不出来）</li>
<li>修正用户进程加载程序内容的方法，改为从文件系统加载</li>
<li>代码全都写不出来！！</li>
</ul>
</li>
</ul>
<h3 id="x86-32硬件简单介绍"><a class="markdownIt-Anchor" href="#x86-32硬件简单介绍"></a> X86-32硬件简单介绍</h3>
<p>这个时候就应该参见之前认真写的那篇文章了（<a href="/post/intel-80x86-architecture-overview">Intel80X86架构概述</a>）。这一讲中并未讲得太细，大致概括如下：</p>
<ul>
<li>运行模式
<ul>
<li>80386共有四种运行模式，我们只用到了其中两种</li>
<li>实模式：加电后的默认模式，在bootloader中就会切换为保护模式</li>
<li>保护模式：一般的模式</li>
</ul>
</li>
<li>寻址方法（参见<a href="intel-80x86-architecture-mm-under-protected-mode">Intel80X86架构：保护模式下的内存管理</a>）
<ul>
<li>逻辑地址：由16位的段选择子和32位的偏移量组成，是应用程序直接使用的地址空间（大概就是程序运行时访问的地址吧）</li>
<li>线性地址：由逻辑地址的偏移量+段基址得到，是虚存管理下每个运行的应用程序能访问的地址空间</li>
<li>物理地址：处理器提交到总线上用于访问计算机系统中内存和外设的最终地址。如果未开启页机制，则物理地址=线性地址；否则通过页表和线性地址可得到物理地址</li>
</ul>
</li>
<li>寄存器
<ul>
<li>通用寄存器
<ul>
<li>EAX：累加器</li>
<li>EBX：基址寄存器</li>
<li>ECX：计数器</li>
<li>EDX：数据寄存器</li>
<li>ESI：源地址指针寄存器</li>
<li>EDI：目的地址指针寄存器</li>
<li>EBP：基址指针寄存器</li>
<li>ESP：堆栈指针寄存器</li>
</ul>
</li>
<li>段寄存器
<ul>
<li>CS：代码段（Code Segment）</li>
<li>DS：数据段（Data Segment）</li>
<li>ES：附加数据段（Extra Segment）</li>
<li>SS：堆栈段（Stack Segment）</li>
<li>FS：附加段</li>
<li>GS：附加段</li>
</ul>
</li>
<li>指令寄存器EIP：指令的段内偏移地址</li>
<li>标志寄存器EFLAGS：
<ul>
<li>TF：开启单步调试</li>
<li>IF：开启硬件中断</li>
<li>IOPL：I/O特权级，CPL&lt;=IOPL时才能进行I/O操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ucore的部分编程技巧和数据结构"><a class="markdownIt-Anchor" href="#ucore的部分编程技巧和数据结构"></a> uCore的部分编程技巧和数据结构</h3>
<p>主要就讲了两个东西：函数指针和链表。</p>
<h4 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h4>
<p>大家都知道，uCore是用C写的。但是C也是可以写出面向对象代码的。就比如说<code>swap_manager</code>，我们只定义了一个<code>swap_manager</code>类型的结构体变量，它的成员变量全是函数指针。然后，我们可以定义各种各样的成员函数，比如<code>__fifo_swap_out_victim</code>，把函数的值赋给成员变量。需要进行换入换出的时候，就调用这个函数指针。正因为如此，把<code>__fifo_swap_out_victim</code>换成<code>__clock_swap_out_victim</code>之类也是可以的。</p>
<h4 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h4>
<p>uCore中有大量的东西都是用双向链表实现的，比如空闲内存块链表、内存中页面链表、状态队列……</p>
<p>uCore的双向链表的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_entry &#123;</span><br><span class="line">    struct list_entry *prev, *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个数据结构，每有<strong>一种</strong>它需要连接到里面的链表（后期<code>struct Page</code>结构就有至少两个<code>list_entry</code>类型的成员变量，一个用来进行空闲页管理，一个用来辅助页替换算法），就在里面多加一个<code>list_entry</code>项，然后把这些<code>list_entry</code>连接起来。一般来说，每个有实际用途的双向链表的逻辑都是，有一个<strong>不是其他变量的成员变量的</strong><code>head</code>指针，每次可以从它开始访问，直到绕了一圈回来为止（因为是双向链表）。</p>
<p>uCore提供了用于管理链表的宏，不需要自己手动管理，总的来说挺好用的：</p>
<ul>
<li><code>list_init</code>：初始化一个双向链表</li>
<li><code>list_add</code>和<code>list_add_before</code>：在某链表项前或后插入一个新的项</li>
<li><code>list_next</code>和<code>list_prev</code>：向前或后移动一个链表项</li>
<li><code>list_del</code>：从链表中删除某个项</li>
</ul>
<p>另一个关键问题是如何通过链表项指针访问对应的结构体变量（从结构体变量访问成员链表项的方法是显然的）。uCore提供了<code>le2page</code>宏，可以通过计算结构体变量开头的地址访问这个变量。总的来说特别好用。</p>
<h3 id="编写和调试工具"><a class="markdownIt-Anchor" href="#编写和调试工具"></a> 编写和调试工具</h3>
<p>全部都用文本编辑器来写代码、看代码当然没有什么问题。用eclipse-CDT建立<code>Makefile</code>项目再看的话，在函数之间跳转比较方便。在eclipse中配置调试是可以的，不过我一般都直接用命令行调试了。</p>
<p>至于从之前的实验中移植代码到后面的实验中这个问题……由于有的时候代码还需要修改，所以所有的代码我都是手动粘的。当然这也是因为我用不惯diff和meld工具。</p>
<h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/01-3-lab0-spoc-discussion.md" target="_blank" rel="noopener">lab0 SPOC思考题</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/01-3-lab0-quiz.md" target="_blank" rel="noopener">lab0在线练习</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<hr>
<p>清华大学目前的操作系统实验中采用的OS对象是()</p>
<ul>
<li>Linux</li>
<li><strong>ucore</strong></li>
<li>xv6</li>
<li>Nachos</li>
</ul>
<p>是参考了xv6, OS161, Linux的教学操作系统ucore OS。</p>
<hr>
<p>在ucore lab的实验环境搭建中，使用的非开源软件是()</p>
<ul>
<li>eclipse CDT</li>
<li><strong>Scitools Understand</strong></li>
<li>gcc</li>
<li>qemu</li>
</ul>
<p>Scitools Understand是非开源软件，主要可以用于分析代码，可免费试用一段时间。</p>
<hr>
<p>在ucore lab的实验环境搭建中，用来模拟一台PC机（即基于Intel 80386 CPU的计算机）的软件是()</p>
<ul>
<li>apt</li>
<li>git</li>
<li>meld</li>
<li><strong>qemu</strong></li>
</ul>
<p>qemu是一个支持模拟多种CPU的模拟软件。apt是Unix系统的软件包管理器，git是版本管理工具，meld是文本比较工具。</p>
<hr>
<p>ucore lab实验中8个实验是否可以不按顺序完成？</p>
<ul>
<li>是</li>
<li><strong>否</strong></li>
</ul>
<p>每个实验i依赖前面所有的实验(0～i-1)，即完成了lab i，才能完成lab i+1。</p>
<hr>
<p>ucore lab实验中在C语言中采用了面向对象的编程思想，包括函指针表和通用链表结构。是否正确？</p>
<ul>
<li><strong>是</strong></li>
<li>否</li>
</ul>
<p>是的，这使得可编出更加灵活的操作系统功能模块和数据结构。当然，这也不是严格的面向对象，不过至少是模块化的，而且能用。</p>
<hr>
<p>x86-32 CPU（即80386）有多种运行模式，ucore lab中碰到和需要处理哪些模式？</p>
<ul>
<li><strong>实模式</strong></li>
<li><strong>保护模式</strong></li>
<li>SMM模式</li>
<li>虚拟8086模式</li>
</ul>
<p>ucore需要碰到和处理16位的实模式和32位的保护模式。其中保护模式的重要性大得多。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>你理解的对于类似ucore这样需要进程/虚存/文件系统的操作系统，在硬件设计上至少需要有哪些直接的支持？至少应该提供哪些功能的特权指令？</strong></p>
<p>进程的切换需要硬件支持时钟中断；虚存管理需要地址映射机制，从而需要MMU等硬件；对于文件系统，需要硬件有稳定的存储介质来保证操作系统的持久性。 对应的，应当提供中断使能，触发软中断等中断相关的，设置内存寻址模式，设置页表等内存管理相关的，执行I/O操作等文件系统相关的特权指令。</p>
<p>对于现代操作系统（每个进程占一个时间片）时钟中断是非常需要的。存储介质当然也是非常必要的。当然，事实上，MMU没有也行，可以用用户态函数库来实现地址转换，但这样可能就保证不了安全性了。</p>
<p>Intel手册第3卷2.8节“System Instruction Summary”中给出了一个系统指令列表。“系统指令完成的是系统级的功能，包括加载系统寄存器、管理Cache、管理中断和设置调试寄存器。其中的大部分指令都必须由操作系统或特权级为0的进程执行；另一部分可以由任何特权级的进程执行。”</p>
<p><img src="intel-manual-table-2-3.png" alt="表2.8 系统指令列表"></p>
<p>其中我们直接用到的不多。LGDT在建立段映射机制的时候用过，INVLPG在切换页表的时候大概用过，其他的就不知道了。</p>
<hr>
<p><strong>你理解的x86的实模式和保护模式有什么区别？物理地址、线性地址、逻辑地址的含义分别是什么？</strong></p>
<p>保护模式和实模式的根本区别是进程内存是否受保护。（我的意见是，实模式既是一个历史包袱，又有一定的实际用途。在实模式下，BIOS自检和加载bootloader的程序可以尽可能简单，因为不需要建立复杂的段映射。但是段机制必须开启这一点也是历史包袱。总之，bootloader一开始就开了A20，设置了GDT然后长跳转切换到保护模式了。）实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向“实在”的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个被修改的系统程序或用户程序，其后果就很可能是灾难性的。为了克服这种低劣的内存管理方式，处理器厂商开发出保护模式。这样，物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。</p>
<p>物理地址：是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。<br>
逻辑地址：在有地址变换功能的计算机中，访问指令给出的地址叫逻辑地址。（一般的定义是段选择子+段内偏移量是逻辑地址。大概）<br>
线性地址：线性地址是逻辑地址到物理地址变换之间的中间层，是处理器通过段(Segment)机制控制下的形成的地址空间。<br>
虚拟地址（不得不补上）：对这个名称的定义总是模糊不清。不过，在这门课中，似乎虚拟地址就是程序内存的地址，不知道我的理解是不是错了。</p>
<hr>
<p><strong>理解list_entry双向链表数据结构及其4个基本操作函数和ucore中一些基于它的代码实现（此题不用填写内容）</strong></p>
<p>我感觉刚才已经说得很多了。uCore中没有多么复杂的数据结构，也就只有数组和链表了。<code>list_entry</code>的确可以当做一个对象来看待，它可以作为其他对象的一部分，并且进行自己独立的操作。</p>
<hr>
<p><strong>对于如下的代码段，请说明&quot;:&quot;后面的数字是什么含义。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">   unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment</span><br><span class="line">   unsigned gd_ss : 16;            // segment selector</span><br><span class="line">   unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates</span><br><span class="line">   unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)</span><br><span class="line">   unsigned gd_type : 4;            // type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">   unsigned gd_s : 1;                // must be 0 (system)</span><br><span class="line">   unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level</span><br><span class="line">   unsigned gd_p : 1;                // Present</span><br><span class="line">   unsigned gd_off_31_16 : 16;        // high bits of offset in segment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>“:”后的数字表示每一个域在结构体中所占的位数，详细说明见<a href="http://en.cppreference.com/w/cpp/language/bit_field" target="_blank" rel="noopener">Bit field</a>。总的来说就是把struct的变量定义精确到了bit的程度。这个结构体是IDT中的门描述符，一个门描述符的大小为8字节。</p>
<hr>
<p>对于如下的代码段，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span><br><span class="line">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;        \</span><br><span class="line">    (gate).gd_ss = (sel);                                \</span><br><span class="line">    (gate).gd_args = 0;                                    \</span><br><span class="line">    (gate).gd_rsv1 = 0;                                    \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = 0;                                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                                \</span><br><span class="line">    (gate).gd_p = 1;                                    \</span><br><span class="line">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在其他代码段中有如下语句，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned intr;</span><br><span class="line">intr=8;</span><br><span class="line">SETGATE(intr, 1,2,3,0);</span><br></pre></td></tr></table></figure>
<p>请问执行上述指令后， intr的值是多少？</p>
<p>在实验1中这个宏在填充IDT表中还是挺好用的。显然可以逐步计算出intr。事实上，这个填充过程应该是直接把intr的地址当成了一个<code>gatedesc</code>的地址，从代码中也可以看出来。之后事实上又把这个<code>gatedesc</code>cast成了unsigned类型，也就是输出了它的前半部分（因为unsigned的长度为4个字节）。</p>
<ul>
<li><code>gd_off_15_0 = 3 &amp; 0xffff = 0x0003</code></li>
<li><code>gd_ss = sel = 0x0002</code></li>
<li><code>gd_args = b00000</code></li>
<li><code>gd_rsv1 = b000</code></li>
<li><code>gd_type = STS_TG32 = 0xf</code></li>
<li><code>gd_s = b0</code></li>
<li><code>gd_dpl = b00</code></li>
<li><code>gd_p = b1</code></li>
<li><code>gd_off_31_16 = 0x0000</code></li>
</ul>
<p>可以得到这个内存中的<code>gatedesc</code>为：<code>0x0003000200f10000</code>。我也不知道为什么输出就变成了<code>0x20003</code>。这之中肯定有大小端的问题。</p>
<p>参考答案中给出了一个可以直接输出的参考代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef unsigned uint32_t;</span><br><span class="line"></span><br><span class="line">#define STS_IG32 0xE  // 32-bit Interrupt Gate</span><br><span class="line">#define STS_TG32 0xF  // 32-bit Trap Gate</span><br><span class="line"></span><br><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)             \</span><br><span class="line">    &#123;                                                    \</span><br><span class="line">        (gate).gd_off_15_0 = (uint32_t)(off)&amp;0xffff;     \</span><br><span class="line">        (gate).gd_ss = (sel);                            \</span><br><span class="line">        (gate).gd_args = 0;                              \</span><br><span class="line">        (gate).gd_rsv1 = 0;                              \</span><br><span class="line">        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \</span><br><span class="line">        (gate).gd_s = 0;                                 \</span><br><span class="line">        (gate).gd_dpl = (dpl);                           \</span><br><span class="line">        (gate).gd_p = 1;                                 \</span><br><span class="line">        (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;     \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">    unsigned gd_off_15_0 : 16;   // low 16 bits of offset in segment</span><br><span class="line">    unsigned gd_ss : 16;         // segment selector</span><br><span class="line">    unsigned gd_args : 5;        // # args, 0 for interrupt/trap gates</span><br><span class="line">    unsigned gd_rsv1 : 3;        // reserved(should be zero I guess)</span><br><span class="line">    unsigned gd_type : 4;        // type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">    unsigned gd_s : 1;           // must be 0 (system)</span><br><span class="line">    unsigned gd_dpl : 2;         // descriptor(meaning new) privilege level</span><br><span class="line">    unsigned gd_p : 1;           // Present</span><br><span class="line">    unsigned gd_off_31_16 : 16;  // high bits of offset in segment</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const* argv[]) &#123;</span><br><span class="line">    unsigned intr = 8;</span><br><span class="line"></span><br><span class="line">    gatedesc gate = *(gatedesc*)&amp;intr;</span><br><span class="line">    SETGATE(gate, 1, 2, 3, 0);</span><br><span class="line"></span><br><span class="line">    intr = *(unsigned*)&amp;gate;</span><br><span class="line">    printf(&quot;0x%x\n&quot;, intr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为0x20003，若将SETGATE(gate, 1, 2, 3, 0)改为SETGATE(gate, 0, 1, 2, 3)，则结果为0x10002。</p>
<h3 id="实践练习"><a class="markdownIt-Anchor" href="#实践练习"></a> 实践练习</h3>
<p><strong>请在ucore中找一段你认为难度适当的AT&amp;T格式X86汇编代码，尝试解释其含义。</strong></p>
<p>那就找一下后期的用于切换上下文的switch.S。把当前寄存器保存在<code>struct context from</code>中，再从<code>struct context to</code>中恢复寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码其实很简单。核心问题是栈如何被操纵。开始时，栈顶是返回地址，下面（<code>esp-4</code>）是<code>from</code>（因为参数是从右往左压栈的），再下面是<code>to</code>。系统先从栈中取出<code>from</code>，然后把该函数的返回地址弹出，保存到<code>from-&gt;eip</code>中。然后依次保存各个通用寄存器（段寄存器不需要保存，因为内核线程之间这些寄存器都一样）。因为<code>eax</code>中保存的总是返回值，所以可以不保存它，简化代码。之后就是从栈中再取出<code>to</code>，恢复通用寄存器，最后把<code>to-&gt;eip</code>入栈，保证返回之后能跳转到正确地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl switch_to</span><br><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&apos;s registers</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    popl 0(%eax)                # save eip !popl</span><br><span class="line">    movl %esp, 4(%eax)</span><br><span class="line">    movl %ebx, 8(%eax)</span><br><span class="line">    movl %ecx, 12(%eax)</span><br><span class="line">    movl %edx, 16(%eax)</span><br><span class="line">    movl %esi, 20(%eax)</span><br><span class="line">    movl %edi, 24(%eax)</span><br><span class="line">    movl %ebp, 28(%eax)</span><br><span class="line"></span><br><span class="line">    # restore to&apos;s registers</span><br><span class="line">    movl 4(%esp), %eax          # not 8(%esp): popped return address already</span><br><span class="line">                                # eax now points to to</span><br><span class="line">    movl 28(%eax), %ebp</span><br><span class="line">    movl 24(%eax), %edi</span><br><span class="line">    movl 20(%eax), %esi</span><br><span class="line">    movl 16(%eax), %edx</span><br><span class="line">    movl 12(%eax), %ecx</span><br><span class="line">    movl 8(%eax), %ebx</span><br><span class="line">    movl 4(%eax), %esp</span><br><span class="line"></span><br><span class="line">    pushl 0(%eax)               # push eip</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>宏定义和引用在内核代码中很常用。请枚举ucore中宏定义的用途，并举例描述其含义。</strong></p>
<p>参考答案给出了3点：</p>
<ul>
<li>利用宏进行复杂数据结构中的数据访问；</li>
<li>利用宏进行数据类型转换；如 <code>to_struct</code></li>
<li>常用功能的代码片段优化；如 <code>ROUNDDOWN</code>, <code>SetPageDirty</code></li>
</ul>
<p>我觉得很有道理。因为现在手边没有代码，所以就不粘贴了，反正不是重点。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-1-summary/">
              
                  《操作系统》第1讲：“操作系统概述”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-08
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>这一讲对课程内容和操作系统做了一个概括性的介绍，主要包括以下几块内容：</p>
<ul>
<li>教学安排</li>
<li>什么是操作系统</li>
<li>操作系统的演变</li>
<li>操作系统结构的分类</li>
</ul>
<h3 id="教学安排"><a class="markdownIt-Anchor" href="#教学安排"></a> 教学安排</h3>
<p>本课程将讲述的内容包括：</p>
<ul>
<li>操作系统结构</li>
<li>中断和系统调用</li>
<li>内存管理</li>
<li>进程和线程</li>
<li>处理机调度</li>
<li>同步互斥</li>
<li>文件系统</li>
<li>I/O子系统</li>
</ul>
<p>实验共有8个，包括：</p>
<ul>
<li>0：实验环境准备</li>
<li>1：系统启动及中断</li>
<li>2：物理内存管理</li>
<li>3：虚拟内存管理</li>
<li>4：内核线程管理</li>
<li>5：用户进程管理</li>
<li>6：CPU调度</li>
<li>7：同步与互斥</li>
<li>8：文件系统</li>
</ul>
<p>实验安排与教学安排是基本匹配的。</p>
<h3 id="什么是操作系统"><a class="markdownIt-Anchor" href="#什么是操作系统"></a> 什么是操作系统</h3>
<p>操作系统可以是：</p>
<ul>
<li>一个控制程序</li>
<li>一个资源管理器</li>
<li>一套标准库</li>
</ul>
<p>操作系统通常由内核、命令行和GUI组成。我们研究的主要是内核。以uCore为例，可以分成以下4个层次：</p>
<ul>
<li>应用程序</li>
<li>命令行程序、编译器、解释器、系统库</li>
<li>内核
<ul>
<li>内核向上提供系统调用接口</li>
<li>同时调用下层提供的硬件抽象</li>
</ul>
</li>
<li>硬件设备</li>
</ul>
<p>操作系统内核的特征：</p>
<ul>
<li>并发：OS需要管理和调度多个同时运行的程序</li>
<li>共享：对资源的互斥共享</li>
<li>虚拟：对CPU和内存资源的虚拟化</li>
<li>异步：程序的运行是时常会停止的，OS需要保证程序暂停之后状态不变</li>
</ul>
<h3 id="操作系统的演变"><a class="markdownIt-Anchor" href="#操作系统的演变"></a> 操作系统的演变</h3>
<ul>
<li>单用户系统：1945-1955
<ul>
<li>OS=装载器+通用子程序库</li>
<li>问题是，任务完全为串行执行，由于读卡时间过长，执行时间比例降低</li>
</ul>
</li>
<li>批处理系统：1955-1965
<ul>
<li>每个任务在每个组件中串行执行，总体看来是并行执行的</li>
<li>解决了利用率问题</li>
</ul>
</li>
<li>多道程序系统：1965-1980
<ul>
<li>将多个程序存储在内存中，复用CPU</li>
<li>在程序进行I/O操作时将其阻塞，切换到别的程序</li>
</ul>
</li>
<li>分时系统：1970-
<ul>
<li>定时中断当前程序，实现对CPU的复用</li>
</ul>
</li>
<li>个人电脑操作系统</li>
<li>分布式操作系统</li>
<li>……</li>
</ul>
<h3 id="操作系统结构的分类"><a class="markdownIt-Anchor" href="#操作系统结构的分类"></a> 操作系统结构的分类</h3>
<p>操作系统的结构可以分为以下几种：</p>
<ul>
<li>简单结构：没有拆分为模块，没有很好地分离接口和功能
<ul>
<li>应用程序可以直接访问最底层的服务，也可以使用操作系统的服务</li>
<li>例：MS-DOS</li>
</ul>
</li>
<li>分层结构：将操作系统分为多层，每层建立在底层上
<ul>
<li>优点：可移植性强</li>
<li>缺点：层次过多会导致效率降低</li>
<li>例：UNIX</li>
</ul>
</li>
<li>微内核结构：将一些内核服务移动到用户态，内核只保留进程通信和硬件支持功能
<ul>
<li>优点：灵活，安全</li>
<li>缺点：性能差</li>
<li>例：目前的系统结构是微内核结构和分层结构的混合体</li>
</ul>
</li>
<li>外核结构：内核只起到资源的保护和隔离功能，操作系统原有功能由用户态操作系统库支持</li>
<li>虚拟机结构：操作系统与虚拟机管理器交互，虚拟机管理器负责和硬件交互</li>
</ul>
<h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/01-2-spoc-discussion.md" target="_blank" rel="noopener">操作系统概述</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<hr>
<ul>
<li>当前常见的操作系统主要用<strong>C，C++，ASM编程语言</strong>编写。</li>
</ul>
<hr>
<ul>
<li>&quot;Operating system&quot;这个单词起源于<strong>Operator</strong>。</li>
</ul>
<p>指的是原来的系统操作员。</p>
<hr>
<ul>
<li>在计算机系统中，控制和管理各种资源、有效地组织多道程序运行的系统软件称作<strong>操作系统</strong>。</li>
</ul>
<p>对操作系统定义的考察。当然我觉得这个答案并不全面，加上“提供了一套标准库”（也就是系统调用）会更好。</p>
<hr>
<ul>
<li>允许多用户将若干个作业提交给计算机系统集中处理的操作系统称为<strong>批处理</strong>操作系统。</li>
</ul>
<p>这说明单用户系统是每个任务手动提交上去的。</p>
<hr>
<ul>
<li>你了解的当前世界上使用最多的32bit CPU是<strong>ARM</strong>，其上运行最多的操作系统是<strong>Android</strong>。</li>
</ul>
<p>答案如此，没有找到信源。不过知道这个也没什么意义。</p>
<hr>
<ul>
<li>应用程序通过<strong>系统调用</strong>接口获得操作系统的服务。</li>
</ul>
<p>系统调用是非常重要的。这是应用程序主动进入内核态的方式。</p>
<hr>
<ul>
<li>现代操作系统的特征包括<strong>并发性，共享性，虚拟性，异步性，持久性</strong>。</li>
</ul>
<p>特征到底应该包括哪些也是见仁见智。OSTEP中总结出的三点是虚拟，并发和持久性。异步性和共享性大概可以归入并发性。同时我也觉得持久性未必是操作系统的特点，而是存储设备的特点。当然这也可能是我的理解不够。</p>
<p>UPD：操作系统本身也是需要从持久性存储设备中读入的。文件系统也是OS的重要组成成分。所以我想得可能太片面了。</p>
<hr>
<ul>
<li>操作系统内核的架构包括<strong>宏内核，微内核，外核</strong>。</li>
</ul>
<p>这个答案和上面讲的并不相符。那么，当然应该填简单结构、分层结构、微内核结构、外核结构和虚拟机结构了。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>请总结你认为操作系统应该具有的特征有什么？并对其特征进行简要阐述。</strong></p>
<p>操作系统应该具有的特征有：虚拟性、并发性、异步性、共享性和持久性。</p>
<ul>
<li>虚拟性：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。</li>
<li>并发性：并发是指两个或多个事件在同一时间间隔内发生，在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。</li>
<li>异步性：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。异步性使得操作系统运行在一种随机的环境下，可能导致进程产生于时间有关的错误。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</li>
<li>共享性：系统中的资源可供内存中多个并发执行的进程共同使用。（事实上，只能做到互斥共享，或者说同时。）</li>
<li>持久性：通过实现文件系统，操作系统可以将程序以及数据存储在磁盘等存储介质中。 详细解释可以参考操作系统的特征。</li>
</ul>
<hr>
<p><strong>为什么现在的操作系统基本上用C语言来实现？为什么没有人用python，java来实现操作系统？</strong></p>
<p>C语言是编译型语言，有良好的性能，能够直接嵌入汇编，可以方便地操作硬件；Python，Java无法保证性能，不能直接操作硬件。</p>
<p>不过，仍然是有人用这些语言来编写操作系统的，比如：</p>
<ul>
<li>用Java实现的操作系统：<a href="https://en.wikipedia.org/wiki/JavaOS" target="_blank" rel="noopener">JavaOS</a></li>
<li>用Python实现的操作系统：<a href="https://github.com/tornewuff/pycorn" target="_blank" rel="noopener">pycorn</a>，<a href="https://github.com/wfxpanisa/pythonix" target="_blank" rel="noopener">pythonix</a></li>
<li>用Rust实现的操作系统：<a href="https://www.redox-os.org/" target="_blank" rel="noopener">Redox</a></li>
</ul>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p>此次的实践题全部与V9-computer相关，和本课程关系不大，所以先不做了。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/the-nightingale-by-r-barnfield/">
              
                  《英诗金库》I-34：The Nightingale, by R. Barnfield
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：The Nightingale（夜莺）<br>
作者：Richard Barnfield（理查德·巴恩菲尔德）<br>
出版年代：1598<br>
编注：理查德·巴恩菲尔德（Richard Barnfield，1574-1627），英国学者及诗人，主要作品有《钟情的牧羊人》等。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>As it fell upon a day<br>
In the merry month of May,<br>
Sitting<a href="#note1" id="note1ref"><sup>1</sup></a> in a pleasant shade<br>
Which a grove<a href="#note2" id="note2ref"><sup>2</sup></a> of myrtles made,<br>
Beasts did leap and plants did spring,<br>
Every thing did banish moan<br>
Save the Nightingale alone.<br>
She, poor bird, as all forlorn,<br>
Lean’d her breast up-till<a href="#note3" id="note3ref"><sup>3</sup></a> a thorn,<br>
And there sung the dolefull’st ditty<br>
That<a href="#note4" id="note4ref"><sup>4</sup></a> to hear it was great pity.<br>
Fie, fie, fie, now would she cry;<br>
Teru, Tereu, by and by:<br>
That to hear her so complain<br>
Scarce I could from tears refrain;<br>
For her griefs so lively<a href="#note5" id="note5ref"><sup>5</sup></a> shown<br>
Made me think upon mine own.<br>
—Ah, thought I, thou mourn’st in vain,<br>
None takes pity on thy pain:<br>
Senseless trees, they cannot hear thee,<br>
Ruthless beasts, they will not cheer thee;<br>
King Pandion, he is dead,<br>
All thy friends are lapp’d in lead<a href="#note6" id="note6ref"><sup>6</sup></a>:<br>
All thy fellow birds do sing<br>
Careless of thy sorrowing:<br>
Even so, poor bird, like thee<br>
None alive will pity me.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="付勇林-译"><a class="markdownIt-Anchor" href="#付勇林-译"></a> 付勇林 译</h3>
<p>在欢乐的五月里<br>
恰逢有一天，<br>
我坐在舒适的荫凉处<br>
头顶上有一丛长春藤攀援，<br>
处处野兽奔逐，鸟儿啼啭，<br>
万木葱茏、百草吐艳。<br>
世间的万物都已忘掉了忧愁<br>
唯独那只夜莺郁郁寡欢。<br>
她呀，可怜的鸟儿，神色凄苦，<br>
胸脯靠着蒺藜，<br>
低吟着一支小曲悲楚哀怨<br>
让人听着实在可怜。<br>
啾、啾、啾，这时她在哭诉；<br>
嘟噜、嘟噜，一会儿又愁肠欲断；<br>
听着她满腹冤屈<br>
我止不住泪流满面；<br>
她的痛苦是这样历历在目，<br>
让我也想起自己的苦难。<br>
——唉，我思量，你忧伤也是枉然，<br>
谁也不会把你可怜：<br>
没心肝的树啊，它们充耳不闻，<br>
残忍的野兽，也不把你鼓舞、慰勉；<br>
潘狄翁国王已魂归九天，<br>
你的挚友也都进了铅造的墓棺：<br>
所有的小鸟还在婉转歌唱，<br>
毫不理睬你正遭受着苦难：<br>
正是这样，可怜的鸟儿，我象你<br>
活着的谁也不把我可怜。</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>我知道这个故事。</p>
<p>菲洛墨拉（希腊语：Φιλομήλα，字面意思是“爱歌者”）希腊神话中阿提刻（雅典及其附近地区）国王潘狄翁与妻子宙克西珀所生之女，是普罗克涅、厄瑞克透斯和部忒斯的妹妹。</p>
<p>菲洛墨拉的姐夫色雷斯国王忒柔斯凶暴好色，企图霸占菲洛墨拉，遂将妻子普罗克涅藏于密林，谎称已死，要潘狄翁把另一个女儿送来。菲洛墨拉到达后即遭其强奸，又被割掉舌头。普罗克涅得知后气极，为报复竟杀死与忒柔斯的孩子，并将孩子的肉做成饭给忒柔斯吃，然后带菲洛墨拉逃跑。忒柔斯发觉真相后暴怒，拼命追赶两人。两姐妹在绝望中向神祈祷，天神把他们三人都变成了鸟：普罗克涅变成夜莺，菲洛墨拉变成燕子，忒柔斯变成戴胜。晚期的罗马作家不知出于什么原因改动了神话，把无舌的菲洛墨拉说成是夜莺，普罗克涅则说成燕子。<a href="#bib1" id="bib1ref"><sup>[1]</sup></a></p>
<p>因此大概可以看出，诗句中的“Tereu”大概不完全是拟声词。读了读英文维基，也没有什么令人震惊的重要发现。按我这个现代人的想法，忒柔斯显然没有得到应有的惩罚，为何他们三人都变成鸟了呢？忒柔斯的行径当然是糟糕至极，普罗克涅一时冲动也犯下大错，可是菲洛墨拉是无辜的啊。或许神认为忒柔斯不知不觉地吃下了自己孩子的肉，他已经付出了足够的代价。当然，以现代人的价值观去评价这些古希腊人也是不太合适的。总之，冲动是魔鬼。</p>
<p>回到这首诗。哦不……我们先回到这个诗人。原注中对他的介绍实在是不太够。理查德·巴恩菲尔德（1574 – 1620），英国诗人，由于和莎士比亚的密切却不为人所知的关系，成为了研究者们感兴趣的对象。在1598年，巴恩菲尔德发表了第三本书《The Encomion of Lady Pecunia》，这是一首赞颂钱财的诗歌（pecunia是拉丁语“钱”的意思）。这本书的附录中出现了一些非常有趣的事情：这可能是对莎士比亚的第一次赞美。在一篇名为《A Remembrance of some English Poets》的文章中，当时默默无名的莎士比亚被作为《维纳斯与阿童尼》的作者，与斯宾塞、丹尼尔（Samuel，1562-1619，英国诗人及历史家，于1599-1619年荣获桂冠诗人；因为我也没听说过这个人所以记一下）、杜雷顿等人并列。其中同时包含了十四行诗《If Music and sweet Poetrie agree》，以及这首美丽的颂歌《As it fell upon a day》，这首诗曾经一度被认为是莎士比亚所作。</p>
<p>在1599年，《热情的朝圣者》（The Passionate Pilgrim）出版，标题页上写着“By W. Shakespeare”。人们在很长一段时间内认为这一署名是正确的，然而，至少有两首诗是巴恩菲尔德所作（就是刚才提到的两首），他在1598年和1605年都强调了这一点。事实上，莎士比亚实际所作的诗可能只有五首。</p>
<p>巴恩菲尔德的诗很久以来都被人忽视。他的诗歌纯净、甜美、悦耳，尽管缺乏广度和原创性。他的诗歌天才由这首被误认为是莎士比亚的诗毫无疑问地证明了，虽然只有一首。<a href="#bib2" id="bib2ref"><sup>[2]</sup></a>有人认为他就是莎士比亚的第78-86首十四行诗中提到的“Rival Poet”。<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>（我对这一概念还没有很深刻的了解，不能再讲太多了，真可惜。）</p>
<p>下面开启吐槽模式。老实说，我真没觉得这首诗“纯净、甜美、悦耳”；恰恰相反，我觉得它矫揉造作。然而，看了这些介绍之后，我对巴恩菲尔德其人和这首诗的观感都完全不一样了。我觉得他可能是个不幸的人，活在莎士比亚的阴影下。可是他自己未必是这么想的，也许他是因为崇拜莎士比亚才这么做的。总之这种事实在是难说。此处选择的版本似乎是《热情的朝圣者》中的缩减版，原版似乎还有以下这些行：</p>
<blockquote>
<p>Whilst as fickle Fortune smiled,<br>
Thou and I were both beguiled.<br>
Every one that flatters thee<br>
Is no friend in misery.<br>
Words are easy, like the wind;<br>
Faithful friends are hard to find.<br>
Every man will be thy friend<br>
Whilst thou hast wherewith to spend;<br>
But if store of crowns be scant,<br>
No man will supply thy want.<br>
If that one be prodigal,<br>
Bountiful they will him call,<br>
And with suchlike flattering,<br>
“Pity but he were a king.”<br>
If he be addict to vice,<br>
Quickly him they will entice.<br>
If to women he be bent,<br>
They have at commandment;<br>
But if Fortune once do frown,<br>
Then farewell his great renown:<br>
They that fawned on him before<br>
Use his company no more.<br>
He that is thy friend indeed,<br>
He will help thee in thy need;<br>
If thou sorrow, he will weep;<br>
If thou wake, he cannot sleep;<br>
Thus of every grief in heart<br>
He with thee doth bear a part.<br>
These are certain signs to know<br>
Faithful friend from flattering foe.<a href="#bib4" id="bib4ref"><sup>[4]</sup></a></p>
</blockquote>
<p>再回头看的时候，感受到了一丝清澈的忧伤，也体会到了音乐性。（但是这首诗的前半段和后半段根本不是一个画风吧！）</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> 菲洛墨拉. <a href="https://zh.wikipedia.org/wiki/%E8%8F%B2%E6%B4%9B%E5%A2%A8%E6%8B%89" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/菲洛墨拉</a><br>
<a id="bib2" href="#bib2ref"><sup>[2]</sup></a> Richard Barnfield. <a href="https://en.wikipedia.org/wiki/Richard_Barnfield" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Richard_Barnfield</a><br>
<a id="bib3" href="#bib3ref"><sup>[3]</sup></a> Rival Poet. <a href="https://en.wikipedia.org/wiki/Rival_Poet" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rival_Poet</a><br>
<a id="bib4" href="#bib4ref"><sup>[4]</sup></a> XX. As it fell upon a day. <a href="https://en.wikisource.org/wiki/The_Passionate_Pilgrim#XX._As_it_fell_upon_a_day" target="_blank" rel="noopener">https://en.wikisource.org/wiki/The_Passionate_Pilgrim#XX._As_it_fell_upon_a_day</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>Sitting</em>: ‘as I was sitting.’<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>grove</em>: so in the original and in the <em>Passionate Pilgrim</em>, England’s Helicon has ‘group.’<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>up-till</em>: ‘up to’.<br>
<a id="note4" href="#note4ref"><sup>4</sup></a><em>That</em> is the conjunction, = ‘so that.’<br>
<a id="note5" href="#note5ref"><sup>5</sup></a><em>lively</em>: ‘vividly.’<br>
<a id="note6" href="#note6ref"><sup>6</sup></a><em>lapp’d in lead</em>: ‘enclosed in leaden coffins.’</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/付勇林/"><i class="fas fa-hashtag fa-fw"></i>付勇林</a>
                
                    <a href="/tags/R-Barnfield/"><i class="fas fa-hashtag fa-fw"></i>R.Barnfield</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/they-that-have-power-to-hurt-and-will-do-none-by-w-shakespeare/">
              
                  《英诗金库》I-32：They that have power to hurt and will do none, by W. Shakespeare
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-02
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：The Life without Passion（无激情的人生）<br>
作者：William Shakespeare（威廉·莎士比亚）<br>
出版年代：1609<br>
编注：此诗系莎氏十四行诗第九四首。诗人说，只有忠贞不渝，能抗拒诱惑的人才配得上天赐的美貌。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>They that have power to hurt and will do none,<br>
That do not do the thing they most do show<a href="#note1" id="note1ref"><sup>1</sup></a>,<br>
Who, moving others, are themselves as stone,<br>
Unmoved, cold, and to temptation slow, —</p>
<p>They rightly do inherit<a href="#note2" id="note2ref"><sup>2</sup></a> Heaven’s graces,<br>
And husband nature’s riches from expense<a href="#note3" id="note3ref"><sup>3</sup></a>;<br>
They are the lords and owners of their faces,<br>
Others, but stewards of their excellence.</p>
<p>The summer’s flower is to the summer sweet,<br>
Though to itself<a href="#note4" id="note4ref"><sup>4</sup></a> it only live and die;<br>
But if that flower with base infection meet<a href="#note5" id="note5ref"><sup>5</sup></a>,<br>
The basest weed outbraves his dignity:</p>
<p>For sweetest things turn sourest by their deeds;<br>
Lilies that fester smell far worse than weeds.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="梁宗岱-译"><a class="markdownIt-Anchor" href="#梁宗岱-译"></a> 梁宗岱 译</h3>
<p>谁有力量损害人而不这样干，<br>
谁不做人以为他们爱做的事，<br>
谁使人动情，自己却石头一般，<br>
冰冷、无动于衷、对诱惑能抗拒——</p>
<p>谁就恰当地承受上天的恩宠，<br>
善于贮藏和保管造化的财富；<br>
他们才是自己美貌的主人翁，<br>
而别人只是自己姿色的家奴。</p>
<p>夏天的花把夏天熏得多芳馥，<br>
虽然对自己它只自开又自落，<br>
但是那花若染上卑劣的病毒，<br>
最贱的野草也比它高贵得多：</p>
<p>极香的东西一腐烂就成极臭，<br>
烂百合花比野草更臭得难受。</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>这首诗给人的感觉就远不止是爱情了。人的好名声的毁损也是同样的。</p>
<p>好吧，没时间翻译解析了<a href="#bib1" id="bib1ref"><sup>[1]</sup></a>……但是这一篇还挺有意思的。</p>
<p>TODO</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> Sonnet 94. <a href="http://www.sparknotes.com/shakespeare/shakesonnets/section5/" target="_blank" rel="noopener">http://www.sparknotes.com/shakespeare/shakesonnets/section5/</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>do the thing they most do show</em>: i.e. devote themselves to the service of love, for which their appearance has so amply qualified them.<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>rightly do inherit</em>, etc.: ‘it is right that they should be endowed with supreme beauty.’<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>from expense</em>: ‘from being expended.’<br>
<a id="note4" href="#note4ref"><sup>4</sup></a><em>Though to itself</em>, etc.: i.e. that which is sel-contained and self-centred will yet give pleasure if it be beautiful. The ‘only’ is misplaced, as so often in English; it goes with ‘to itself.’<br>
<a id="note5" href="#note5ref"><sup>5</sup></a><em>with base infection meet</em>: ‘become tainted with decay.’</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/W-Shakespeare/"><i class="fas fa-hashtag fa-fw"></i>W.Shakespeare</a>
                
                    <a href="/tags/Sonnet/"><i class="fas fa-hashtag fa-fw"></i>Sonnet</a>
                
                    <a href="/tags/梁宗岱/"><i class="fas fa-hashtag fa-fw"></i>梁宗岱</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/that-time-of-year-thou-mayst-in-me-behold-by-w-shakespeare/">
              
                  《英诗金库》I-28：That time of year thou mayst in me behold, by W. Shakespeare
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-02-06
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：That time of year thou mayst in me behold<br>
作者：William Shakespeare（威廉·莎士比亚）<br>
出版年代：1609<br>
编注：此诗系莎氏十四行诗第七三首。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>That time of year thou may’st in me be behold<br>
When yellow leaves, or none, or few, do hang<br>
Upon those boughs which shake against the cold<br>
Bare ruin’d choirs, where late the sweet birds sang.</p>
<p>In me thou see’st the twilight of such day<br>
As after sunset fadeth in the west,<br>
Which by and by black night doth take away,<br>
Death’s second self, that seals up all in rest.</p>
<p>In me thou see’st the glowing of such fire<a href="#note1" id="note1ref"><sup>1</sup></a>,<br>
That on the ashes of his youth doth lie<br>
As the death-bed whereon it must expire,<br>
Consumed with<a href="#note2" id="note2ref"><sup>2</sup></a> that which it was nourish’d by:</p>
<p>—This thou perceiv’st, which makes thy love more strong,<br>
To love that well which thou must leave ere long.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="屠岸-译"><a class="markdownIt-Anchor" href="#屠岸-译"></a> 屠岸 译</h3>
<p>你从我身上能看到这个时令：<br>
黄叶落光了，或者还剩下几片<br>
没脱离那乱打冷颤的一簇簇枝梗——<br>
不再有好鸟歌唱的荒凉唱诗坛。</p>
<p>你从我身上能看到这样的傍晚：<br>
夕阳的回光沉入了西方的天际，<br>
死神的化身——黑夜，慢慢出现，<br>
挤走黄昏，把一切封进了安息。</p>
<p>你从我身上能看到这张火焰：<br>
它躺在自己青春的灰烬上燃烧，<br>
象躺在临终的床上，一息奄奄，<br>
跟供它养料的燃料一同毁灭掉。</p>
<p>看出了这个，你的爱会更加坚贞，<br>
好好地爱着你快要失去的爱人！</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>我又想不动了……<a href="#bib1" id="bib1ref"><sup>[1]</sup></a></p>
<p>TODO</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> Sonnet 73: That time of year thou mayst in me behold. <a href="https://www.poetryfoundation.org/poems/45099/sonnet-73-that-time-of-year-thou-mayst-in-me-behold" target="_blank" rel="noopener">https://www.poetryfoundation.org/poems/45099/sonnet-73-that-time-of-year-thou-mayst-in-me-behold</a></p>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>such fire That</em>, etc. : in strict grammar ‘that’ should be ‘as.’ his=its, referring to ‘fire.’<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>Consumed with</em>: i.e. ‘together with’; fire and fuel disappear together.</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/W-Shakespeare/"><i class="fas fa-hashtag fa-fw"></i>W.Shakespeare</a>
                
                    <a href="/tags/屠岸/"><i class="fas fa-hashtag fa-fw"></i>屠岸</a>
                
                    <a href="/tags/Sonnet/"><i class="fas fa-hashtag fa-fw"></i>Sonnet</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/archives/2018/page/27/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  28 / 29
              </p>
              
                  <a class="next" rel="next" href="/archives/2018/page/29/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->



    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
