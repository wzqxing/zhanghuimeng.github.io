<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018/7 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018.7'}
    </script>




  <section class="post-list">
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-357-count-numbers-with-unique-digits/">
              
                  Leetcode 357. Count Numbers with Unique Digits（组合数学）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/count-numbers-with-unique-digits/description/" target="_blank" rel="noopener">https://leetcode.com/problems/count-numbers-with-unique-digits/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：2/5</p>
<p>代码效率：100.00%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定<strong>非负整数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">[0, 10^n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>中没有重复数字的数的个数。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这道题的数据量非常小（显然，n&gt;10时的个数与n=10时是相同的），因此，可以直接打表计算。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<p>结果错了好多次……</p>
<p>两个边界情况：</p>
<ul>
<li>n=0时应该返回1</li>
<li>n&gt;10时应该返回8877691。虽然我开始时返回0也过了……</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNumbersWithUniqueDigits(int n) &#123;</span><br><span class="line">        // 显然，n&lt;=10</span><br><span class="line">        // 所以干脆直接打表算了。</span><br><span class="line">        // 下面的n指的是，这个数长度为n（因此0不能在第一位）</span><br><span class="line">        // n = 1: 10</span><br><span class="line">        // n = 2: 9 * 9 = 81</span><br><span class="line">        // n = 3: 9 * 9 * 8 = 648</span><br><span class="line">        // n = 4: 9 * 9 * 8 * 7 = 4536</span><br><span class="line">        // n = 5: 9 * 9 * 8 * 7 * 6 = 27216</span><br><span class="line">        // n = 6: 9 * 9 * 8 * 7 * 6 * 5 = 136080</span><br><span class="line">        // n = 7: 9 * 9 * 8 * 7 * 6 * 5 * 4 = 544320</span><br><span class="line">        // n = 8: 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 = 1632960</span><br><span class="line">        // n = 9: 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 = 3265920</span><br><span class="line">        // n = 10: 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 3265920</span><br><span class="line">        if (n == 0) return 1;</span><br><span class="line">        if (n == 1) return 10;</span><br><span class="line">        if (n == 2) return 91;</span><br><span class="line">        if (n == 3) return 739;</span><br><span class="line">        if (n == 4) return 5275;</span><br><span class="line">        if (n == 5) return 32491;</span><br><span class="line">        if (n == 6) return 168571;</span><br><span class="line">        if (n == 7) return 712891;</span><br><span class="line">        if (n == 8) return 2345851;</span><br><span class="line">        if (n == 9) return 3265920;</span><br><span class="line">        if (n &gt;= 10) return 8877691;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Math/"><i class="fas fa-hashtag fa-fw"></i>alg:Math</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-696-count-binary-substrings/">
              
                  Leetcode 696. Count Binary Substrings（观察）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/count-binary-substrings/description/" target="_blank" rel="noopener">https://leetcode.com/problems/count-binary-substrings/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：5.22%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一个01串，问其中形如<code>0011</code>或<code>1100</code>（所有0连在一起，所有1也连在一起，数目相等）的子串共有多少个，不去重。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这就是一个大水题，把所有连续的0或1子串的长度统计出来，就可以直接做了。</p>
<p>P.S. 我刚才本来想用正则表达式来表达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">0^n 1^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mi>n</mi></msup><msup><mn>0</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">1^n 0^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>这个意思的，结果突然想起来，正则表达式的表示能力相当于有限状态自动机，而有限状态自动机表示不了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">0^n 1^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>……（如果我没记错的话）</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countBinarySubstrings(string s) &#123;</span><br><span class="line">        // 需要找出01数量相同，且所有0和所有1都连在一起（也就是形如0011或1100的串）</span><br><span class="line">        // 只需把字符串分成连续的0或1，然后统计即可</span><br><span class="line"></span><br><span class="line">        // 这个写法效率低，但是很直观</span><br><span class="line">        vector&lt;int&gt; sub;</span><br><span class="line">        char cur;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (len == 0) &#123;</span><br><span class="line">                cur = s[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (cur == s[i])</span><br><span class="line">                len++;</span><br><span class="line">            else &#123;</span><br><span class="line">                sub.push_back(len);</span><br><span class="line">                cur = s[i];</span><br><span class="line">                len = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (len != 0)</span><br><span class="line">            sub.push_back(len);</span><br><span class="line"></span><br><span class="line">        if (sub.size() &lt; 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; sub.size() - 1; i++)</span><br><span class="line">            ans += min(sub[i], sub[i+1]);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-String/"><i class="fas fa-hashtag fa-fw"></i>alg:String</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-289-game-of-life/">
              
                  Leetcode 289. Game of Life（模拟）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/game-of-life/description/" target="_blank" rel="noopener">https://leetcode.com/problems/game-of-life/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：100%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定生命游戏（元胞自动机）的现有状态，根据规则计算下一个状态。</p>
<p>进阶：</p>
<ul>
<li>能否就地解决这个问题？</li>
<li>如果棋盘无穷大，如何解决该问题？</li>
</ul>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>如果不要求就地解决，这就是一个模拟大水题。但是，</p>
<h3 id="what-is-in-place"><a class="markdownIt-Anchor" href="#what-is-in-place"></a> What is in-place?</h3>
<p>我本来以为就地解决会用到什么高级的思路，因此我没有想出来。结果别人给出的“<a href="https://leetcode.com/problems/game-of-life/discuss/73223/Easiest-JAVA-solution-with-explanation" target="_blank" rel="noopener">就地解法</a>”竟然只是把前后两个状态通过位运算的方法硬塞进一个int里而已……虽然我脑子在这种方面是不太灵光啦，但我认为这只是一种hack的方法，它利用的是编程语言的性质，而非真正的数学思路；从抽象的角度来说，每个格子只有位置信息和1 bit的状态信息，仅此而已。</p>
<p>但是我很快就不得不收回自己说的话。我刚才看了<a href="http://www.cnblogs.com/grandyang/p/4854466.html" target="_blank" rel="noopener">另一份题解</a>，其实也可以从另一个角度来解释这种做法：其实我们在这个元胞自动机的每一个格子里又塞了一个有限状态自动机，像下图这样的。</p>
<p><img src="simple-automata.jpg" alt="一个压缩了前后两种状态的有限状态自动机"></p>
<p>我原来的想法可能有一定的道理，但显然是狭隘的。</p>
<h3 id="数据的实际状况以及状态压缩"><a class="markdownIt-Anchor" href="#数据的实际状况以及状态压缩"></a> 数据的实际状况，以及状态压缩</h3>
<p>读了<a href="http://www.jagregory.com/abrash-black-book/#chapter-17-the-game-of-life" target="_blank" rel="noopener">Chapter 17 – The Game of Life</a>和<a href="http://www.jagregory.com/abrash-black-book/#chapter-18-its-a-plain-wonderful-life" target="_blank" rel="noopener">Chapter 18 – It’s a plain Wonderful Life</a>之后，我意识到了一些甚至更有趣的事情。这本书中给出了对模拟生命游戏进行进一步的速度优化的两种主要思路（我决定不把对指针的巧妙操作列为主要思路之一）：</p>
<ul>
<li>关注数据的实际状态。通过生命游戏的规则，我们很容易看出，活细胞的数量不会太多，而且细胞状态的变化并不频繁。因此，我们可以维护一张实际变化了的细胞位置的表，并在更新时主要处理这张表指向的细胞。</li>
<li>状态压缩。除了像上面说的那样，把当前和未来状态打包起来以外，我们还可以把相邻活细胞的数量也记为状态的一部分，甚至还可以把多个细胞的状态一起压缩。除了减少空间占用之外，查表的复杂度也减小了。</li>
</ul>
<p>书中David Stafford的解法把这几种思路有机地结合在了一起，创造了一份非常精妙的代码，以至于我很难分别描述每种思路各自的好处。总之他的思路非常棒。</p>
<p><img src="cell-triplet.jpg" alt="同时存储三个细胞"></p>
<h3 id="无穷多个细胞"><a class="markdownIt-Anchor" href="#无穷多个细胞"></a> 无穷多个细胞？</h3>
<p>即使细胞有无穷多个，活细胞的数目也应该是有限的，所以我们只需分别更新每个活细胞及其周围细胞的状态即可。参见<a href="https://leetcode.com/problems/game-of-life/discuss/73217/Infinite-board-solution" target="_blank" rel="noopener">Infinite board solution</a>。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<p>这时候我的代码反而显得微不足道了呢……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int n = board.size();</span><br><span class="line">        if (n &lt; 1)</span><br><span class="line">            return;</span><br><span class="line">        int m = board[0].size();</span><br><span class="line">        // 直接将原状态保存下来</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; original;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">                tmp.push_back(board[i][j]);</span><br><span class="line">            original.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新board</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                if (i &gt; 0) cnt += original[i-1][j];</span><br><span class="line">                if (i &lt; n-1) cnt += original[i+1][j];</span><br><span class="line">                if (j &gt; 0) cnt += original[i][j-1];</span><br><span class="line">                if (j &lt; m-1) cnt += original[i][j+1];</span><br><span class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0) cnt += original[i-1][j-1];</span><br><span class="line">                if (i &gt; 0 &amp;&amp; j &lt; m-1) cnt += original[i-1][j+1];</span><br><span class="line">                if (i &lt; n-1 &amp;&amp; j &gt; 0) cnt += original[i+1][j-1];</span><br><span class="line">                if (i &lt; n-1 &amp;&amp; j &lt; m-1) cnt += original[i+1][j+1];</span><br><span class="line"></span><br><span class="line">                if (original[i][j] == 1) &#123;</span><br><span class="line">                    if (cnt &lt; 2 || cnt &gt; 3)</span><br><span class="line">                        board[i][j] = 0;</span><br><span class="line">                    else</span><br><span class="line">                        board[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (cnt == 3)</span><br><span class="line">                    board[i][j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Array/"><i class="fas fa-hashtag fa-fw"></i>alg:Array</a>
                
                    <a href="/tags/alg-Automata/"><i class="fas fa-hashtag fa-fw"></i>alg:Automata</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-93-restore-ip-address/">
              
                  Leetcode 93. Restore IP Address（搜索）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">https://leetcode.com/problems/restore-ip-addresses/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/3</p>
<p>代码效率：9.95%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>把一个数字串用小数点分隔成4段，问共能形成多少个合法的IP地址。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这就是一个简单的搜索题，但是需要注意两个边界条件：</p>
<ul>
<li>每一段的数字必须在0-255之间</li>
<li>数字不能有前导0</li>
</ul>
<p>以及，做题过程中大概会用到两个函数：</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/string/stoi/" target="_blank" rel="noopener">stoi</a>：<code>string</code>转<code>int</code></li>
<li><a href="http://www.cplusplus.com/reference/string/string/substr/" target="_blank" rel="noopener">substr(pos, len)</a>：取<code>string</code>的子串，注意参数的含义</li>
</ul>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<p>我这个代码实在写得太繁琐了。与其用4层循环，还不如稍微简化一下……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        // 看起来像是简单的搜索问题。一个IP地址的一段只能是0-255，因此长度最多为3</span><br><span class="line">        // 中间可以进行剪枝</span><br><span class="line">        // 不知道有没有什么奇怪的边界情况</span><br><span class="line">        // 果然是有的，比如不应该有前导0</span><br><span class="line">        // 以及是否需要去重？</span><br><span class="line">        // 事实说明不需要。</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        int len[4], byte[4];</span><br><span class="line"></span><br><span class="line">        // 因为模板的原因，必须cast成int？</span><br><span class="line">        for (len[0] = 1; len[0] &lt;= min(3, (int) s.length()); len[0]++) &#123;</span><br><span class="line">            byte[0] = stoi(s.substr(0, len[0]));</span><br><span class="line">            if (byte[0] &gt; 255)</span><br><span class="line">                continue;</span><br><span class="line">            // 考虑前导0问题</span><br><span class="line">            if (len[0] &gt; 1 &amp;&amp; s[0] == &apos;0&apos;)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            for (len[1] = 1; len[1] &lt;= min(3, (int) s.length() - len[0]); len[1]++) &#123;</span><br><span class="line">                byte[1] = stoi(s.substr(len[0], len[1]));</span><br><span class="line">                if (byte[1] &gt; 255)</span><br><span class="line">                    continue;</span><br><span class="line">                if (len[1] &gt; 1 &amp;&amp; s[len[0]] == &apos;0&apos;)</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                for (len[2] = 1; len[2] &lt;= min(3, (int) s.length() - len[0] - len[1]); len[2]++) &#123;</span><br><span class="line">                    byte[2] = stoi(s.substr(len[0] + len[1], len[2]));</span><br><span class="line">                    if (byte[2] &gt; 255)</span><br><span class="line">                        continue;</span><br><span class="line">                    if (len[2] &gt; 1 &amp;&amp; s[len[0]+len[1]] == &apos;0&apos;)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                    len[3] = s.length() - len[0] - len[1] - len[2];</span><br><span class="line">                    // 除了要考虑位数不够的情况，也要考虑位数太多的情况，这也是不合法的</span><br><span class="line">                    if (len[3] &lt;= 0 || len[3] &gt; 3)</span><br><span class="line">                        continue;</span><br><span class="line">                    byte[3] = stoi(s.substr(len[0] + len[1] + len[2], len[3]));</span><br><span class="line">                    if (byte[3] &gt; 255)</span><br><span class="line">                        continue;</span><br><span class="line">                    if (len[3] &gt; 1 &amp;&amp; s[len[0]+len[1]+len[2]] == &apos;0&apos;)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                    string ip = s.substr(0, len[0]) + &quot;.&quot; + s.substr(len[0], len[1]) + &quot;.&quot; +</span><br><span class="line">                        s.substr(len[0] + len[1], len[2]) + &quot;.&quot; + s.substr(len[0] + len[1] + len[2], len[3]);</span><br><span class="line">                    ans.push_back(ip);</span><br><span class="line">                    // cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-String/"><i class="fas fa-hashtag fa-fw"></i>alg:String</a>
                
                    <a href="/tags/alg-Backtracking/"><i class="fas fa-hashtag fa-fw"></i>alg:Backtracking</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-173-binary-search-tree-iterator/">
              
                  Leetcode 173. Binary Search Tree Iterator（中序遍历）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-search-tree-iterator/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：98.53%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>写一个二叉搜索树的迭代器，包括初始化、<code>next()</code>和<code>hasNext()</code>操作，要求平摊时间复杂度为O(1)，空间复杂度为O(h)。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>因为空间复杂度是O(h)，所以肯定不能把整个树直接存成一个数组然后直接查找，而是要利用树的性质。好吧，其实《数据结构》里在迭代版中序遍历中讲了这个东西。</p>
<p><img src="in-order-traverse.png" alt="中序遍历过程"></p>
<blockquote>
<p>与所有遍历一样，中序遍历的实质功能也可理解为，为所有节点赋予一个次序，从而将半线性的二叉树转化为线性结构。于是一旦指定了遍历策略，即可与向量和列表一样，在二叉树的节点之间定义前驱与后继关系。其中没有前驱（后继）的节点称作首（末）节点。<br>
对于后面将要介绍的二叉搜索树，中序遍历的作用至关重要。相关算法必需的一项基本操作，就是定位任一节点在中序遍历序列中的直接后继。为此，可实现succ()接口如代码5.16所示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 代码5.16 二叉树节点直接后继的定位</span><br><span class="line">template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;::succ() &#123; //定位节点v的直接后继</span><br><span class="line">    BinNodePosi(T) s = this; //记录后继的临时变量</span><br><span class="line">    if (rChild) &#123; //若有右孩子，则直接后继必在右子树中，具体地就是</span><br><span class="line">        s = rChild; //右子树中</span><br><span class="line">        while (HasLChild(*s)) s = s-&gt;lChild; //最靠左（最小）的节点</span><br><span class="line">    &#125; else &#123; //否则，直接后继应是“将当前节点包含于其左子树中的最低祖先”，具体地就是</span><br><span class="line">        while (IsRChild(*s)) s = s-&gt;parent; //逆向地沿右向分支，不断朝左上方移动</span><br><span class="line">        s = s-&gt;parent; //最后再朝右上方移动一步，即抵达直接后继（如果存在）</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，共分两大类情况。若当前节点有右孩子，则其直接后继必然存在，且属于其右子树。此时只需转入右子树，再沿该子树的最左侧通路朝左下方深入，直到抵达子树中最靠左（最小）的节点。<br>
反之，若当前节点没有右子树，则若其直接后继存在， 必为该节点的某一祖先，且是将当前节点纳入其左子树的最低祖先。于是首先沿右侧通路朝左上方上升，当不能继续前进时，再朝右上方移动一步即可。<br>
作为后一情况的特例，出口时s可能为NULL。这意味着此前沿着右侧通路向上的回溯，抵达了树根。也就是说，当前节点是全树右侧通路的终点——它也是中序遍历的终点，没有后继。<br>
（摘自《数据结构(C++语言版)》（第三版），清华大学出版社，2013.9）</p>
</blockquote>
<p>我的代码实现得不怎么漂亮，不过里面被注释掉的关键的一句代码<code>path.push(_cur);</code>变相实现了“右侧通路朝左上方上升，当不能继续前进时，再朝右上方移动一步”这个操作：栈中实际上存储的就是经过这个操作之后能够得到的结点，因此右转时的结点是不能入栈的。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="我的代码"><a class="markdownIt-Anchor" href="#我的代码"></a> 我的代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode* _root;</span><br><span class="line">    TreeNode* _cur;</span><br><span class="line">    stack&lt;TreeNode*&gt; path;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        _root = root;</span><br><span class="line">        _cur = root;</span><br><span class="line">        // 找到树中最小的结点</span><br><span class="line">        while (_cur != NULL &amp;&amp; _cur-&gt;left != NULL) &#123;</span><br><span class="line">            path.push(_cur);</span><br><span class="line">            _cur = _cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // cout &lt;&lt; _cur-&gt;val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @return whether we have a next smallest number */</span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        // 和next()的判断逻辑相同：</span><br><span class="line">        // 当前结点有右子树，或者仍然有向上回溯的空间</span><br><span class="line">        return _cur != NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @return the next smallest number */</span><br><span class="line">    int next() &#123;</span><br><span class="line">        int smallest = _cur-&gt;val;</span><br><span class="line">        // cout &lt;&lt; smallest &lt;&lt; &apos; &apos; &lt;&lt; path.size() &lt;&lt; endl;</span><br><span class="line">        // 寻找_cur的后继</span><br><span class="line">        // _cur的右子树不为空，此时后继必为_cur的右子树中最靠左的结点</span><br><span class="line">        if (_cur-&gt;right != NULL) &#123;</span><br><span class="line">            // 必须注释掉这句话，因为path（这个名字起得不好）指的并不是从root到当前结点的路径上的所有结点</span><br><span class="line">            // 而是“右子树仍未被访问到的结点”</span><br><span class="line">            // path.push(_cur);</span><br><span class="line">            _cur = _cur-&gt;right;</span><br><span class="line">            while (_cur-&gt;left != NULL) &#123;</span><br><span class="line">                path.push(_cur);</span><br><span class="line">                _cur = _cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // _cur的右子树为空，此时需要向上回溯</span><br><span class="line">        // 因为TreeNode的定义中没有提供父结点指针，所以只好用栈来记录了</span><br><span class="line">        // 当然，按照邓公的意见，这样可以省空间，应该是最好的……</span><br><span class="line">        else &#123;</span><br><span class="line">            if (path.size() &gt; 0) &#123;</span><br><span class="line">                _cur = path.top();</span><br><span class="line">                path.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                _cur = NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) cout &lt;&lt; i.next();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="sample-20ms-submission"><a class="markdownIt-Anchor" href="#sample-20ms-submission"></a> Sample 20ms Submission</h3>
<p>我刚发现在提交后的结果页面点时间会得到相应的标程，惊了，Leetcode真是越来越强了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    void addToStack(TreeNode * root)&#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        addToStack(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @return whether we have a next smallest number */</span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        return s.size()&gt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @return the next smallest number */</span><br><span class="line">    int next() &#123;</span><br><span class="line">        int res = s.top()-&gt;val;</span><br><span class="line">        TreeNode * top = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        if(top-&gt; right)&#123;</span><br><span class="line">            addToStack(top-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) cout &lt;&lt; i.next();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Tree</a>
                
                    <a href="/tags/alg-In-Order-Traversal/"><i class="fas fa-hashtag fa-fw"></i>alg:In-Order Traversal</a>
                
                    <a href="/tags/alg-Binary-Search-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Binary Search Tree</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-21-merge-two-sorted-lists/">
              
                  Leetcode 21. Merge Two Sorted Lists（链表操作）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-30
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：100.00%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>合并两个已排序的链表。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>注意边界情况。以及和链表搞来搞去实在并不能算是一件很有趣味的事情。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);  <span class="comment">// 新增的头结点，没有实际意义。当然也可以不加，写起来更麻烦一点。</span></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="comment">// 其实我刚才写了半天才发现自己理解错了。我以为要求是把两个list交替拼接起来。</span></span><br><span class="line">        <span class="comment">// 但实际上是合并排序……</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="literal">NULL</span>)</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Linked-List/"><i class="fas fa-hashtag fa-fw"></i>alg:Linked List</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-207-course-schedule/">
              
                  Leetcode 207. Course Schedule（拓扑排序）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-30
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>题目来源：<a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/2</p>
<p>代码效率：99.48%</p>
<h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2>
<p>给定一些课程和每门课对应的若干先修课程，要求必须修完对应先修课程才能修这门课，问是否存在一种修课顺序，能够修完所有的课。</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>这本质上就是一个在有向图中寻找拓扑序的问题，直接套用模型就可以了。</p>
<p>P.S. 我们都知道拓扑排序一般的做法是记录每个结点的入度，然后在删除结点的同时更新其他点的入度。也就是说，我们用一个数字统计量来代替了集合，而这样做是十分合理的，因为在这一问题中，只有入度的<strong>累计</strong>才有意义，其具体内容没有意义。这很有趣。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 我感觉这个只是问一个有向图里有没有圈。</span></span><br><span class="line">    <span class="comment">// 所以感觉简单的拓扑排序就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">int</span> in[numCourses];  <span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            in[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            graph.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [0, 1]: 1 -&gt; 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = prerequisites[i].first;</span><br><span class="line">            <span class="keyword">int</span> y = prerequisites[i].second;</span><br><span class="line">            in[x]++;</span><br><span class="line">            graph[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暂时不做堆优化，直接暴力</span></span><br><span class="line">        <span class="keyword">int</span> finished = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (finished &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">int</span> found = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    found = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (found == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 上这门课</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[found].size(); j++)</span><br><span class="line">                in[graph[found][j]]--;</span><br><span class="line">            in[found] = <span class="number">-1</span>; <span class="comment">// 将这门课从已上列表里去掉……刚才忘了</span></span><br><span class="line">            finished++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="一些废话"><a class="markdownIt-Anchor" href="#一些废话"></a> 一些废话</h2>
<p>因为要准备保研的机试，所以还是要刷题。但是我实在不知道该刷什么比较好。POJ上充满了经典题，CodeForces上每周都有比赛，UVa和《算法竞赛入门经典》是配套的。结果我最后还是来刷炙手可热的Leetcode了，因为最方便，可以勉强维持一点手感。我本来一直觉得用水题刷自己博客的屏很不合适，但是如果不这样，则实在没有办法逼自己继续做下去了。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
                
                    <a href="/tags/alg-Graph/"><i class="fas fa-hashtag fa-fw"></i>alg:Graph</a>
                
                    <a href="/tags/alg-Topological-Sort/"><i class="fas fa-hashtag fa-fw"></i>alg:Topological Sort</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/stretching-spokes-translation/">
              
                  如何伸缩Spokes
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-08
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>这篇文章翻译自<a href="https://githubengineering.com/stretching-spokes/" target="_blank" rel="noopener">Stretching Spokes</a>，我加入了一些自己的注解。</p>
<hr>
<p>GitHub的Spokes系统存储了Git仓库的多个分布式副本。本文讨论了如何把把Spokes为仓库制作的副本分散到相互之间距离很远的的数据中心。</p>
<h2 id="spokes的背景"><a class="markdownIt-Anchor" href="#spokes的背景"></a> Spokes的背景</h2>
<p>GitHub开发了一个名为Spokes的系统来存储我们用户的Git仓库的多个副本，并使副本保持同步。Spokes使用多种策略来确保在大多数情况下每个Git更新都能安全地复制到所有副本，并且在所有情况下至少能够复制到严格多数个副本。Spoke取代了在文件系统块级别进行复制的旧系统，改为在Git应用程序级别进行复制。</p>
<p><img src="spokes-diagram.jpg" alt="Spokes的push操作"></p>
<p>每个对Git仓库的push操作都会通过代理，这一代理会透明地将操作复制到多个文件服务器。早期版本的Spoke需要代理与所有副本之间都能够进行低延迟通信，以维持较高的更新速率。因此，副本之间的距离必须比较近。</p>
<p>但是，将仓库副本的位置分离的优点是众所周知的：</p>
<ul>
<li>副本分散得越开，在影响一片较大地理区域的灾难中（例如飓风、地震和外星人入侵<a href="#note1" id="note1ref"><sup>1</sup></a>），就越有可能有副本幸存。</li>
<li>如果多个区域中都有可用的副本，则可以将Git读取请求定向到距离最近的副本，从而减少传输时间。</li>
</ul>
<p>本文首先解释了为什么延迟会带来问题，我们如何克服问题，使得Git数据能够分布式地存储在整片大陆上，以及这为我们的用户带来了哪些改进。、</p>
<h2 id="副本之间相隔很远-那有什么好大惊小怪的呢"><a class="markdownIt-Anchor" href="#副本之间相隔很远-那有什么好大惊小怪的呢"></a> 副本之间相隔很远。那有什么好大惊小怪的呢？</h2>
<p>在开发Spokes之前，我们使用<a href="https://en.wikipedia.org/wiki/Distributed_Replicated_Block_Device" target="_blank" rel="noopener">DRBD</a>，对文件系统进行块级复制，以创建仓库副本。该系统对延迟非常敏感，因此我们不得不保证文件服务器副本相互靠近。这显然不够理想，解决这一问题就是最初推动Spokes发展的动力。</p>
<p>自从我们开始运行Spokes之后，我们就开始增加Spokes的仓库副本彼此之间的距离极限。副本之间相距越远，它们之间的延迟就越大。延迟大小限制了Spokes能够为每个仓库维持的Git引用更新（reference update）<a href="#note2" id="note2ref"><sup>2</sup></a>的最大速率。</p>
<p>你可能会惊讶，我们居然需要担心这种问题。单个仓库的推送频率不会<strong>那么</strong>高吧？</p>
<p>嗯，<strong>大多数</strong> 用户根本不会经常推送。但是如果你托管了近7000万个仓库，你总会发现<a href="https://www.youtube.com/watch?v=-ZNKR9wFe8o" target="_blank" rel="noopener">某些项目使用了你从未预料到的工作流程</a>。我们非常努力，才能保证Github能够为几乎所有的项目提供正常服务，但仍有一些极其荒谬的案例除外。</p>
<p>此外，为了进行内部记录，Github本身也产生了大量的引用更新。例如，每次用户推送一个pull request分支时，我们都必须记录push操作本身，可能需要将该分支同步到目标仓库，为该pull request计算测试merge和测试rebase<a href="#note3" id="note3ref"><sup>3</sup></a>，这些操作都会产生引用。如果用户推送到项目的<code>master</code>分支，我们就需要为每一个目标是<code>master</code>的活跃pull request都计算一个测试merge和测试rebase。在某些仓库中，这可能会触发超过一百个引用的更新。</p>
<p>能够对具有高延迟的远程副本进行足够快的引用更新对于Spokes的可用性至关重要。具体来说，我们希望能够支持的每个仓库每秒的更新次数大于1。这意味着每次更新操作的预算只有使用几百毫秒。请记住，无论我们采用何种方法优化写操作，都不能因此减慢读操作的速度，因为读操作和写操作数量之比约为100:1。</p>
<h2 id="减少往返次数"><a class="markdownIt-Anchor" href="#减少往返次数"></a> 减少往返次数</h2>
<p>考虑到光速有限之类的烦心事，每次到副本的往返通信都需要时间。例如，横跨美国大陆的一次网络往返通信需要60-80毫秒。多往返几次就会耗尽我们的时间预算。</p>
<p>我们使用<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">三阶段提交</a><a href="#note4" id="note4ref"><sup>4</sup></a>来更新副本，同时将副本作为分布式锁，以确保更新数据库的顺序是正确的。总而言之，远程副本需要四次往返通信；这无疑是昂贵的，但还没有到无法接受的地步。（我们正在计划通过使用更先进的一致性算法来减少往返次数。）</p>
<p>我们尽可能地利用等待网络请求的时间来完成其他的工作。例如，当一个副本获取互斥锁时<a href="#note5" id="note5ref"><sup>5</sup></a>，另一个副本可能正在计算校验和，而协调器（coordinator）<a href="#note6" id="note6ref"><sup>6</sup></a>可能正在读数据库。</p>
<h2 id="git引用更新事务"><a class="markdownIt-Anchor" href="#git引用更新事务"></a> Git引用更新事务</h2>
<p>三阶段提交是保持副本同步的关键。为了实现这一协议，我们需要每个副本能够回答“你能执行这些引用更新吗？”这一问题，然后根据协调器的指示提交或回滚事务。为了实现这一目标，我们在开源Git项目中<a href="https://github.com/git/git/compare/8eaf517835d0534767d6a54d12d072ce30276ad9...2cc70cefdd4a249fab895943890d21071e03f8c7" target="_blank" rel="noopener">实现了Git引用更新事务</a>（可以通过类似于<code>git update-ref --stdin</code>的命令使用这一特性<a href="#note7" id="note7ref"><sup>7</sup>&lt;/a）；为了保证<a href="https://github.com/git/git/compare/538569bc8a212a45b7b3f124822b4c3e458752f5...3ad8b5bf26362ac67c9020bf8c30eee54a84f56d" target="_blank" rel="noopener">事务</a>的<a href="https://github.com/git/git/compare/08bb3500a2a718c3c78b0547c68601cafa7a8fd9...87492cb24d9d8be8e18217b89ae5f090089ff31d" target="_blank" rel="noopener">执行结果</a>在副本间是<a href="https://github.com/git/git/compare/53083f8547cd45cdfabcf2f1bd21461cd6769189...711a11c301dafe84389624f009a2abfb7da5d83f" target="_blank" rel="noopener">确定的</a>（deterministic），我们<a href="https://github.com/git/git/compare/c380cf85a79c78d9dceb9290c9d4017d30804521...33d4669aaa658f3e35f88748ed2db51c84203f62" target="_blank" rel="noopener">做</a>了<a href="https://github.com/git/git/compare/7543dea8b2a33e4a56b0fdd408bc47769238025e...11cb3130d551590ae2dbd582e809763bfc353a47" target="_blank" rel="noopener">大量</a>的<a href="https://github.com/git/git/compare/97c12a8b71e7d42b87b9588ba2fe0e1e44411c21...fd9de868c359a1bbd214e354aefdb0f1eaa898bd" target="_blank" rel="noopener">工作</a>。<a href="#note8" id="note8ref"><sup>8</sup></a>首先，Git获取所有必要的本地引用的锁，然后验证旧值符合预期且新值是有意义的。如果一切正常，则提交这一试探性事务（tentative transaction）；否则，它将回滚一切更改。</a></p>
<h2 id="加速git引用更新"><a class="markdownIt-Anchor" href="#加速git引用更新"></a> 加速Git引用更新</h2>
<p>除了网络延迟之外，我们还必须考虑在单个副本上更新Git引用所需的时间。为此，我们<a href="https://github.com/git/git/compare/8e606f97f8dee35f839b50900db8ab98fe189b3c...a7ddaa8eacb45fdd5241e52d72e6f75d8b67b953" target="_blank" rel="noopener">还</a>为与引用相关的操作<a href="https://github.com/git/git/compare/5f02274e4c4506b923b510a24da7991656f4db14...be9cb560e31c76c00760dadb151b5e3059970586" target="_blank" rel="noopener">实现</a>了<a href="https://github.com/git/git/compare/a080a5ce8d9f6897668bb36cb1891f70d685b6c3...44c2339e55df11b2cfd8bdc28ceee6b4d1ca1928" target="_blank" rel="noopener">一些</a><a href="https://github.com/git/git/compare/9124cca61f7edfed70dc5d8bced7fb7cb9fe2221...1a2e1a76ec2cbbafe60ffd124f673f62045fb0d3" target="_blank" rel="noopener">加速</a>。这些变化也贡献回了开源Git项目。</p>
<h2 id="使用校验和对副本进行比较"><a class="markdownIt-Anchor" href="#使用校验和对副本进行比较"></a> 使用校验和对副本进行比较</h2>
<p>我们通过计算副本的所有引用及其值（和一些其他的东西）的校验和来概括副本的状态，称之为“Spokes校验和”。如果两个副本的Spokes校验和相同，则它们肯定拥有相同的逻辑内容。我们在每次更新后计算每个副本的Spokes校验和，作为验证它们保持同步的一项额外检查。</p>
<p>在具有大量引用的繁忙仓库中，从头开始计算Spokes校验和是比较昂贵的，并且会限制引用更新的最大速率。因此，我们会尽可能用逐步的方法来计算Spokes校验和。我们将该值定义为所有<code>(refname, value)</code>对的hash值的异或。因此，在更新引用时，我们可以通过下式来更新校验和的这一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_checksum = old_checksum XOR hash(refname, oldvalue) XOR hash(refname, newvalue)</span><br></pre></td></tr></table></figure>
<p>在我们知道旧Spokes校验和的情况下，计算新Spokes校验和的代价就很小了。</p>
<h2 id="优先考虑用户发起的更新"><a class="markdownIt-Anchor" href="#优先考虑用户发起的更新"></a> 优先考虑用户发起的更新</h2>
<p>即使进行了所有这些优化，一次参考更新仍然需要大约三分之一秒。这在大多数情况下都足够了。但是在我们之前提到的情况下，对<code>master</code>进行一次更新可能会导致上百次内部记录的引用更新（bookkeeping reference update），处理这些更新可能会使仓库在30秒内都处于忙状态。如果这些更新会在如此长的时间内阻止用户发起引用更新，则用户请求将被高度延迟，甚至会超时。</p>
<p>为了解决这一问题，我们将一些内部记录更新合并为几个事务，并且令用户发起的更新优先于内部记录更新（因为它们不需要立即被执行）。</p>
<h2 id="githubcom和github-enterprise的地理复制"><a class="markdownIt-Anchor" href="#githubcom和github-enterprise的地理复制"></a> GitHub.com和GitHub Enterprise的地理复制</h2>
<p>Spokes为GitHub用户带来的最切实的好处是，可以通过地理位置较近的Spokes副本提供Git读取操作（fetch和clone）。由于Spokes可以快速找出哪些副本是最新的，它可以将读操作发送到距离最近的最新副本。Spokes已经在这方面加速了GitHub.com的许多用户的传输速度，而且，随着我们在更多地理区域增加副本，传输速度还会进一步提高。</p>
<p>GitHub Enterprise是GitHub的企业本地版，通过相同的底层Spokes技术，它现在也支持<a href="https://help.github.com/enterprise/2.11/admin/guides/installation/about-geo-replication/" target="_blank" rel="noopener">地理复制</a>（Geo-replication）<a href="#note9" id="note9ref"><sup>9</sup></a>了。甚至当用户远离中心GHE主机（main GHE host）<a href="#note10" id="note10ref"><sup>10</sup></a>时，靠近这样的副本的用户也可以享受更快的Git传输速度。这些副本被配置为无投票权的（non-voting）<a href="#note11" id="note11ref"><sup>11</sup></a>，因此，即使被地理复制的主机暂时无法访问，对中心GHE主机的Git推送也能继续进行。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>通过对Spokes的精心设计，以及对分布式引用更新的性能的仔细优化，Spokes现在能够在更长的距离范围内复制Git仓库了。这提高了GitHub.com和GitHub Enterprise的健壮性、速度和灵活性。</p>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a>虽然我觉得，一旦外星人真的入侵，应该也没有时间考虑这个问题了。</p>
<p><a id="note2" href="#note2ref"><sup>2</sup></a>我不太明白“reference update”这一术语指代的是什么。<a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">Git文档</a>似乎表明，这是用于保存commit对应的SHA-1值的文件：</p>
<blockquote>
<p>我们可以借助类似于<code>git log 1a410e</code>这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住<code>1a410e</code>是最后一个提交。我们需要一个文件来保存SHA-1值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的SHA-1值。<br>
在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在<code>.git/refs</code>目录下找到这类含有 SHA-1 值的文件。</p>
</blockquote>
<p><a id="note3" href="#note3ref"><sup>3</sup></a>我感觉自己对merge和rebase的区别一无所知，也无从理解为什么要做这样的计算。大概是为了显示差异比较？（<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="noopener">5.1 代码合并：Merge、Rebase 的选择</a>）</p>
<p><a id="note4" href="#note4ref"><sup>4</sup></a><a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">三阶段提交</a>：</p>
<blockquote>
<p>三阶段提交（英语：Three-phase commit），也叫三阶段提交协议（英语：Three-phase commit protocol），是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。三阶段提交是为解决两阶段提交协议的缺点而设计的。<br>
与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
</blockquote>
<p><a id="note5" href="#note5ref"><sup>5</sup></a>并不理解具体是获取什么锁。</p>
<p><a id="note6" href="#note6ref"><sup>6</sup></a>我猜测这里的协调器指的应该是分布式事务处理协调器（distributed transaction coordinator），这种技术能够使得分布式计算的事务是可靠的。（参考了<a href="https://blogs.msdn.microsoft.com/florinlazar/2004/03/04/what-is-msdtc-and-why-do-i-need-to-care-about-it/" target="_blank" rel="noopener">What is MSDTC and why do I need to care about it?</a>，虽然不知道和数据库有什么关系。分布式系统真有趣！）</p>
<p><a id="note7" href="#note7ref"><sup>7</sup></a>我之前从未听说过<code>update-ref</code>这个命令。于是查阅<a href="https://git-scm.com/docs/git-update-ref" target="_blank" rel="noopener">手册</a>，得知这是一个用于安全地更新引用中存储的对象名称的命令。</p>
<p><a id="note8" href="#note8ref"><sup>8</sup></a>为了说明他们<strong>确实</strong>做了很多工作，作者在这一句话里插入了9个链接，全是指向对应的commit和merge记录的。真是辛苦了……</p>
<p><a id="note9" href="#note9ref"><sup>9</sup></a>简单来说，“<a href="https://help.github.com/enterprise/2.11/admin/guides/installation/about-geo-replication/" target="_blank" rel="noopener">地理复制</a>”（Geo-replication）这个东西指的就是，通过多个活跃副本完成来自地理区域不同的数据中心的请求。不过好像还有一些其他的细节。</p>
<p><a id="note10" href="#note10ref"><sup>10</sup></a>“GHE”是“Github Enterprise”的缩写。</p>
<p><a id="note11" href="#note11ref"><sup>11</sup></a>“投票权”说的应该是<a href="/post/building-resilience-in-spokes-translation">在Spokes中实现弹性</a>这篇文章中提到的实现持久性的方法：保证多数一致。在这里，我猜失去投票权的意思是，无论它的写入结果如何，都不参与投票（不需要获得对于它的独占锁定），如果发生不一致，再进行更新。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Translation/"><i class="fas fa-hashtag fa-fw"></i>Translation</a>
                
                    <a href="/tags/Github/"><i class="fas fa-hashtag fa-fw"></i>Github</a>
                
                    <a href="/tags/Spokes/"><i class="fas fa-hashtag fa-fw"></i>Spokes</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-05-summary-interlude-process-api/">
              
                  OSTEP第05章总结：Interlude: Process API
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-07
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf</a>。</p>
<hr>
<p>本章的内容是“幕间休息”（interlude）：这些章节讲的是OS中与具体API相关的内容，和原理关系不大，如果不想了解这些具体内容，可以跳过。（但是最好还是不跳过，因为实践出真知，对吧？）本章主要介绍了以下三个与进程创建相关的UNIX系统调用，以及它们的设计原理：</p>
<ul>
<li><code>fork()</code></li>
<li><code>wait()</code></li>
<li><code>exec()</code></li>
</ul>
<h2 id="fork系统调用通过复制来创建新进程"><a class="markdownIt-Anchor" href="#fork系统调用通过复制来创建新进程"></a> fork系统调用：通过复制来创建新进程</h2>
<p>下面的例子说明了<code>fork()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// p1.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        printf(&quot;hello, I am parent of %d (pid:%d)\n&quot;,</span><br><span class="line">        rc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，程序开始执行的时候打印了一条信息，其中包含了<strong>进程标识符</strong>（process identifier，PID）。该进程的PID是29146。在UNIX系统中，PID是进程的唯一标识。然后进程调用了<code>fork()</code>系统调用，通过拷贝当前进程创建了一个新进程。有趣的是，这两个进程几乎相同，都正准备从<code>fork()</code>系统调用返回。新进程（称为子进程；原来的进程称为父进程）不会从<code>main()</code>开始运行（因为<code>hello world</code>只被打印了一次），而是好像自己已经调用了<code>fork()</code>一样。这样设计的原因，将在后面进行解释。</p>
<p>子进程和父进程几乎相同（地址空间、寄存器、PC），只有一点区别：<code>fork()</code>调用的返回值不同。父进程的返回值是子进程的PID，而子进程的返回值是0。这一区别使得我们可以撰写代码分别处理这两种情况。</p>
<p>值得注意的另一点是，p1.c的输出是<strong>不确定的</strong>（nondeterminism）：当子进程创建的时候，系统中出现了两个活跃进程，而CPU调度器选择哪一个先开始运行是不确定的。因此，如果子进程被创建之后立刻开始运行，上述程序的输出就会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="wait系统调用等待子进程退出"><a class="markdownIt-Anchor" href="#wait系统调用等待子进程退出"></a> wait系统调用：等待子进程退出</h2>
<p>下面的例子说明了<code>wait()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// p2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (wc:29267) (pid:29266)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，父进程调用<code>wait()</code>，使得它在子进程结束执行之后才继续执行。当子进程结束之后，<code>wait()</code>调用才返回。此时，上述代码的输出显然是确定（deterministic）的了。如果父进程先运行，它会立刻调用<code>wait()</code>，等待子进程运行结束；因此子进程必然先运行。</p>
<h2 id="exec系统调用通过覆盖改变当前进程的内容"><a class="markdownIt-Anchor" href="#exec系统调用通过覆盖改变当前进程的内容"></a> exec系统调用：通过覆盖改变当前进程的内容</h2>
<p>下面的例子说明了<code>exec()</code>系统调用的使用方法，它一般和<code>fork()</code>一起使用，用于创建新进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p3.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">        printf(&quot;this shouldn’t print out&quot;);</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (wc:29384) (pid:29383)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>事实上，在Linux中，<code>exec()</code>是一类系统调用的总称，一共有6个变种：<code>execl()</code>，<code>execlp()</code>，<code>execle()</code>，<code>execv()</code>，<code>execvp()</code>和<code>execvpe()</code>。详情见<a href="http://man7.org/linux/man-pages/man3/exec.3.html" target="_blank" rel="noopener">exec(3)</a></p>
<p>在这个例子中，在调用<code>fork()</code>创建子进程后，子进程调用了<code>execvp()</code>，用程序<code>wc</code>覆盖自己并开始执行该程序。<code>wc</code>是字数统计（word counting）程序，此处它被用来统计源文件<code>p3.c</code>中行、词和字节的数量。</p>
<p><code>fork()</code>系统调用的设计固然很怪，它的“同伙”<code>exec()</code>也有够怪的。事实上，<code>exec()</code>所做的事情是这样的：给定一个可执行文件的名字（如<code>wc</code>）和一些参数（如<code>p3.c</code>），它会<strong>加载</strong>（load）这个可执行文件的代码（和静态数据），覆盖当前进程的代码段和静态数据，并且重新初始化进程的堆栈和其他内存空间。然后OS把参数作为新进程的<code>argv</code>数组，直接开始运行新程序。所以<code>exec()</code>调用并没有创建一个新进程；它只是把当前正在运行的进程（<code>p3</code>）换成了一个新的程序（<code>wc</code>）。在子进程执行<code>exec()</code>调用之后，<code>p3.c</code>就好像从未运行过一样了；对<code>exec()</code>的成功调用是不会返回的。</p>
<h2 id="fork和exec的设计原因方便shell和管道的实现"><a class="markdownIt-Anchor" href="#fork和exec的设计原因方便shell和管道的实现"></a> fork和exec的设计原因：方便shell和管道的实现</h2>
<p>我们为什么要这样设计创建新进程的API呢？事实上，对于UNIX shell来说，在创建新进程的过程中把<code>fork()</code>和<code>exec()</code>分开是非常必要的，因为这样shell才能在调用<code>fork()</code>之后，调用<code>exec()</code>的过程之前运行一些代码来改变即将运行的程序的环境，这就使得我们可以创造很多有趣的特性。</p>
<p>shell是一个帮助你执行程序（命令）的用户程序。它显示一个<strong>命令提示符</strong>（prompt），然后等待你在里面打字。你在里面打一个命令（比如可执行程序的名字和参数）；然后，shell一般会找到这个可执行程序在文件系统中的位置，调用<code>fork()</code>创建一个新的子进程，然后（子进程）调用<code>exec()</code>的某个变种开始执行命令，最后（父进程）调用<code>wait()</code>等待命令执行结束。当子进程运行结束之后，shell（父进程）从<code>wait()</code>返回，再次打印出命令提示符，等待你的下一条指令。</p>
<p>把<code>fork()</code>和<code>exec()</code>分开使得shell能在其间够做很多有用的东西。比如，我们执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; wc p3.c &gt; newfile.txt</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>wc</code>的输出被<strong>重定向</strong>（redirect）到输出文件<code>newfile.txt</code>中。shell完成这个任务的方法很简单：在创建子进程之后，调用<code>exec()</code>之前，shell关闭<strong>标准输出</strong>（standard output）并打开文件<code>newfile.txt</code>。这样，即将被执行的程序<code>wc</code>的任何输出都会被发送到这个文件而不是屏幕。</p>
<p>下面的代码实现了子进程输出的重定向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p4.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child: redirect standard output to a file</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        // now exec &quot;wc&quot;...</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p4</span><br><span class="line">prompt&gt; cat p4.output</span><br><span class="line">32 109 846 p4.c</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>这种方法的工作原理与OS管理文件描述符的方法相关。UNIX系统在分配文件描述符时，会从0开始寻找空闲的文件描述符。<a href="/post/ostep-ch-04-summary-the-abstraction-the-process">上一章</a>中曾经讲过，对于一个进程，默认有三个文件描述符是开启的：标准输入（<code>STDIN_FILENO=0</code>）、标准输出（<code>STDOUT_FILENO=1</code>）和标准错误输出（<code>STDERR_FILENO=2</code>）。关闭标准输出之后，在调用<code>open()</code>分配新的文件描述符时，<code>STDOUT_FILENO=1</code>就成了第一个可用的文件描述符，于是它就指向了我们需要的输出文件<code>./p4.output</code>。于是，子进程之后对标准输出文件描述符的写操作会被透明地指向新打开的文件。（真是有趣的设计啊）</p>
<p>UNIX<strong>管道</strong>（pipe）机制的实现方法类似。通过<code>pipe()</code>系统调用，一个进程的输出被连接到一个内核管道（pipe）中，另一个进程的输入也连接到这个相同的管道；这样，一个进程的输出就无缝连接到另一个进程的输入了。下面的例子通过管道命令实现了在文件中查找词并计算这个词出现次数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o foo file | wc -l</span><br></pre></td></tr></table></figure>
<h2 id="温馨提示"><a class="markdownIt-Anchor" href="#温馨提示"></a> 温馨提示</h2>
<h3 id="rtfm"><a class="markdownIt-Anchor" href="#rtfm"></a> RTFM</h3>
<p>我们刚才只是大概介绍了这些系统调用的基本原理，还有许多细节没有涉及到。为了了解这些细节，你应当去阅读手册。作为一个系统程序员，阅读<strong>手册</strong>（manual/man pages）是非常重要的，因为里面提供了很多细节，而且还可以帮助你减少烦你的同事的次数。如果你直接去问他们细节问题，他们可能会回答你：“<a href="https://zh.wikipedia.org/zh/RTFM" target="_blank" rel="noopener">RTFM</a>。”（Read the fucking manual！）</p>
<h3 id="get-it-right"><a class="markdownIt-Anchor" href="#get-it-right"></a> Get it right</h3>
<p>兰普森（<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%89%B9%E5%8B%92%C2%B7%E8%98%AD%E6%99%AE%E6%A3%AE" target="_blank" rel="noopener">Butler W. Lampson</a>）在他那篇广受好评的论文“<a href="https://microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf" target="_blank" rel="noopener">Hints for Computer Systems Design</a>”中这样说：“做正确的事。（<strong>Get it right.</strong>）抽象和简化都不能代替正确的做法。”</p>
<p>实际上，设计进程创建API有很多方法，但是UNIX的设计者选择了正确的那一种。（虽然我觉得本章中并没有充分论述它的正确性）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/building-resilience-in-spokes-translation/">
              
                  在Spokes中实现弹性（resilience）
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-05
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>这篇文章翻译自<a href="https://githubengineering.com/building-resilience-in-spokes/" target="_blank" rel="noopener">Building resilience in Spokes</a>，我加入了一些自己的注解。</p>
<hr>
<p>Spokes是我们的文件服务器的复制系统，我们在里面存储了超过3800万个Git仓库和超过3600万个gists。它至少存储了每个仓库和每个gist的三个副本，这样，即使服务器和网络出现故障，我们也可以提供持久且高可用的内容访问。Spokes使用Git和rsync<a href="#note1" id="note1ref"><sup>1</sup></a>的组合来对存储库进行复制，修复和重新平衡。</p>
<h2 id="spokes是什么"><a class="markdownIt-Anchor" href="#spokes是什么"></a> Spokes是什么？</h2>
<p>在我们进入这一主题——如何实现弹性——之前，我们需要声明一个新的名字：DGit现在改名为Spokes了。</p>
<p>今年早些时候，我们<a href="https://githubengineering.com/introducing-dgit/" target="_blank" rel="noopener">宣布了</a>我们的应用级Git复制系统，名为“DGit”（“Distributed Git”）。我们得到的反馈表明，“DGit”这个名字的区分度不高，可能会导致与Git项目本身混淆。所以我们决定重命名这个系统为<em>Spokes</em>。</p>
<h2 id="弹性的定义"><a class="markdownIt-Anchor" href="#弹性的定义"></a> “弹性”的定义</h2>
<p>在任何系统或服务中，有两种衡量弹性的关键方法：可用性（availability）和持久性（durability）。系统的可用性指的是系统提供它应当提供的服务所需的运行时间。它可以提供内容吗？它能接受写操作吗？可用性可能是部分的，完整的或退化的：每个仓库都可用吗？是否有一些仓库——或者整个服务器——的访问很缓慢？</p>
<p>系统的持久性指的是它对永久性数据丢失的抵抗能力。一旦系统接受了一个写操作——推送，合并，通过网站进行的编辑，创建新仓库等——它就应该永远不会破坏或回退该内容到之前的状态。这里的关键问题出现在系统接受写入时：需要存储多少副本，以及在哪里存储？显然，必须存储足够数量的副本，才能保证写操作不丢失的可能性足够高。</p>
<p>系统可以是持久但不可用的。例如，如果系统能够为当前写操作制造的副本数量不能超过最低要求，则系统可能会拒绝接受写操作。这样的系统对于写操作是暂时不可用的，不过它同时能够保证不会丢失数据。当然，系统也可以是不持久但可用的。例如，接收任何写入，无论它们是否可以安全地提交，。</p>
<p>读者可能会意识到这与<a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP定理</a><a href="#note2" id="note2ref"><sup>2</sup></a>有关。简而言之，系统最多可以满足以下三个特性中的两个：</p>
<ul>
<li>一致性（consistency）：所有节点都读到相同的数据</li>
<li>可用性（availability）：系统可以满足读写请求</li>
<li>分区容错性（partition tolerance）：即使节点关闭或无法通信，系统也能正常工作</li>
</ul>
<p>Spokes将一致性和分区容错性放在首位。在最坏的情况下，它将拒绝接受一些写入，对于这些写入，它不能同步提交至至少两个副本。</p>
<h2 id="可用性"><a class="markdownIt-Anchor" href="#可用性"></a> 可用性</h2>
<p>Spokes的可用性取决于底层服务器和网络的可用性，以及我们检测和绕过服务器和网络问题的能力。</p>
<p>单个服务器经常会变得不可用。自从今年春天开始试用Spokes以来，由于内核死锁和RAM芯片故障，我们的一些服务器崩溃了。有时，由于较轻的硬件故障或较高的系统负载，服务器能够提供的服务退化了。在所有这些情况下，Spokes都必须快速检测出问题并绕过它。每个存储库都复制在三台服务器上，因此即使一台服务器处于脱机状态，也基本总会有一个最新的可用副本可以访问。不过，Spokes可不只是它的每个单独的容错部分的总和。<a href="#note3" id="note3ref"><sup>3</sup></a></p>
<p>快速检测问题只是第一步。Spokes同时使用心跳服务（heartbeat）<a href="#note4" id="note4ref"><sup>4</sup></a>和实际应用程序流量的组合来确定文件服务器何时停止工作。使用实际应用流量很关键，原因如下。首先，心跳服务的学习和反应速度很慢。我们的每个文件服务器每秒需要处理超过100个请求。如果心跳每秒发生一次，则只有在一百个请求都已经失败后才能发现故障。其次，心跳测试只能覆盖服务器功能的一个子集：例如，服务器是否可以接受TCP连接并响应无操作请求。但是如果失败的情形更微妙呢？如果Git二进制文件已损坏怎么办？如果磁盘访问停止了怎么办？如果所有经过身份验证的操作都失败怎么办？当真正的流量失败时，有时无操作服务仍然能够成功。</p>
<p>因此，Spokes会在处理实际应用程序流量时监视失败情况，如果有太多请求失败，它会将节点标记为脱机。当然，实际请求在正常情况下有时也会失败。例如，有人会尝试读取已经删除的分支，或尝试推送到他们无权访问的分支。因此，Spoke仅仅在三个请求连续失败时才将节点标记为脱机。这有时会导致完全健康的节点脱机——在正常情况下，三个请求也可能会连续失败——但这种情况很少发生，并且导致的代价并不大。</p>
<p>Spokes也使用心跳服务，但不是作为主要的故障检测机制。相反的是，心跳有两个目的：轮询系统负载，并在节点被标记为脱机后提供全清信号（all-clear signal）<a href="#note5" id="note5ref"><sup>5</sup></a>。一旦心跳成功，该节点将再次标记为在线。如果在服务器出现问题的情况下心跳成功（检索系统负载几乎是无操作），则在三次失败的请求之后，节点将再次标记为脱机。</p>
<p>因此，Spokes在节点大约发生三次失败之后就会检测到故障。但是连续三次失败的操作仍然太多了！对于干净的故障——连接被拒绝或超时——所有操作都知道如何尝试下一个主机。请记住，Spokes对于每个仓库都维护了三个或更多的副本。对仓库的路由查询不只返回一个服务器，而是返回按优先顺序排序的三个（大约）最新副本的列表。如果对首选副本上的操作失败，则通常还有至少两个个副本可以尝试。</p>
<p>从一个服务器故障转移到另一个服务器的操作图（此处为远程过程调用（Remote Procedure Call，RPC）<a href="#note6" id="note6ref"><sup>6</sup></a>）清楚地显示了服务器何时脱机。在下图中，有一个服务器在约1.5小时的时间内不可用；在此期间，数千个RPC操作被重定向到其他服务器。这样的图表是Spokes团队发现出错服务器的最佳检测方法。</p>
<p><img src="one-server-down.png" alt="一台服务器停机"></p>
<p>Spokes的节点离线检测只是建议性的——这只是一种优化。连续三次失败的节点只会被移动到所有读操作的优先顺序列表的末尾，而不是直接从副本列表中移除。尝试一个可能离线的副本还是比根本不进行尝试要好的。</p>
<p>这个故障检测器对服务器故障很有效：当服务器过载或脱机时，对它的操作将失败。Spokes检测到这些故障，并暂时停止将流量定向到故障服务器，直到心跳成功为止。但是，网络和应用程序（Rails）服务器的故障更加混乱。给定的文件服务器可能只对应用程序服务器的一个子集处于脱机状态，而一个出错的应用程序服务器可能会看到每个文件服务器都处于脱机状态的假象。因此，Spokess的故障检测实际上是MxN<a href="#note7" id="note7ref"><sup>7</sup></a>的：每个应用程序服务器都保留自己的脱机文件服务器列表。如果我们发现许多应用程序服务器都将某个文件服务器标记为脱机，那么它可能确实脱机了。而如果我们发现某一个应用程序服务器将许多文件服务器标记为脱机，则发现了一个应用程序服务器的错误。</p>
<p>下图说明了故障检测的MxN特性，并以红色显示，如果文件服务器<code>dfs4</code>处于脱机状态，哪些故障检测器会发现错误。<a href="#note8" id="note8ref"><sup>8</sup></a></p>
<p><img src="mxn.png" alt="MxN故障检测"></p>
<p>在最近的一次事件中，开发环境中的一个前端应用程序服务器发生了无法解析文件服务器的DNS名称的错误。因为它无法到达文件服务器以向它们发送RPC操作或心跳，所以它得出结论，每个文件服务器都处于脱机状态。但是，只有那台应用程序服务器发生了这些错误；所有其他应用服务器都在正常工作。因此，这台坏掉的应用程序服务器在RPC故障转移图中变得非常明显，并没有没有生产流量因此受到影响。<a href="#note9" id="note9ref"><sup>9</sup></a></p>
<h2 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h2>
<p>有时，服务器会失效。磁盘可能会失效；RAID控制器可能会失败；甚至整个服务器或整个机架上的全部机器都可能出现故障。即使面对这种逆境，Spokes也为仓库数据提供了持久性。</p>
<p>就像可用性那样，持久性的的实现基础是复制。Spokes至少保留了每个存储库，wiki和gist的三个副本，且这些副本位于不同的机架中。除非严格多数个副本可以应用更改并获得相同的结果，否则不接受对仓库的更新——推送，重命名，编辑维基等。</p>
<p>Spokes只需要一个额外的副本即可避免单节点故障。那么，为什么需要严格多数呢？存储库很可能在大致相同的时间被多次写入，这种情况是很常见的。这些写入可能会发生冲突：例如，一个用户可能会删除一个分支，而另一个用户将新的提交推送到同一个分支。冲突的写入必须被序列化——也就是说，必须在每个副本上以相同的顺序应用（或拒绝）这些写入，这样每个副本才能得到相同的结果。Spokes将写入序列化的方式是确保每次写入都获得对大多数副本的独占锁定。两个写入不可能同时获得多数锁定，因此Spokes通过完全消除并发写入来避免冲突。</p>
<p>如果一个仓库恰好有三个副本上，则在两个副本上的成功写入既保证了持久性，也保证了多数。如果仓库有四个或五个副本，则成功写入需要三个副本。</p>
<p>在很多其他的复制和共识协议（consensus protocols）中，写入到主副本的顺序是官方顺序，所有其他副本都必须按该顺序进行写入。主副本通常需要手动指定，或使用选举协议（election protocol）自动指定。Spokes简单地跳过这一步骤，并将每次写操作都视为一次选举——选择出胜出的顺序之后，可以直接得到写入结果，而不是得到一个能够指示写入顺序的获胜服务器。</p>
<p>无法在多数副本上以相同方式应用的任何写操作都会被Spokes从它被应用的副本上回退。实质上，每个写入操作都需要经过一个投票协议，投票失败方的任何副本都被标记为不健康——不可读取或写入——直到它们被修复。维修是自动和快速的。由于需要多数副本同意接受或回滚更新，在修复不健康的副本时，仍然至少有两个副本可以继续接受读取和写入。</p>
<p>需要明确的一点是，分歧和修复发生的概率是很小的。GitHub每天接受数百万次仓库写入操作。在典型的一天里，几十次写入才会导致一次非一致投票，通常是因为一个副本特别繁忙，到它的连接超时了，而其他副本在没有它的情况下投票成功，继续前进。落后的副本几乎总是在一两分钟内恢复，不会对仓库的可用性造成用户可见的影响。</p>
<p>整个磁盘和整个服务器的故障更罕见，但它们确实会发生。当我们必须移除整个服务器时，突然有数十万个仓库只剩下有两个副本了，而不是三个。这一状况也是可修复的。Spokes会定期检查每个仓库是否具有所需数量的副本；如果没有，则创建更多副本。可以在任何地方创建新副本，并且可以通过每个仓库剩余的两个副本中的任何一个进行复制。因此，服务器故障后的修复是N对N的。文件服务器的集群越大，从单节点故障中恢复的速度就越快。</p>
<h2 id="正常关机"><a class="markdownIt-Anchor" href="#正常关机"></a> 正常关机</h2>
<p>如上所述，Spokes可以快速透明地处理服务器脱机和永久失效。那么，我们可以将这一方法直接用于需要计划维护时对服务器的重启或移除吗？是，也不是。</p>
<p>我们的确可以通过<code>sudo reboot</code>重新启动服务器，也可以通过直接把服务器拔掉来移除它。但这样做有一些微妙的缺点，因此我们需要设计一种更谨慎的机制，重用一些用于应对崩溃和故障的相同逻辑。</p>
<p>简单地重新启动服务器不会影响未来的读写操作，这些操作将被透明地指向其他副本。它也不影响正在进行的写入操作，因为这些操作发生在所有副本上，而其他两个副本可以直接投票成功并继续写入，不需要我们正在重新启动的服务器上的副本。但重启确实会打断正在进行的读取操作。大多数读取操作——例如，获取README以显示在仓库的主页上——速度都很快，能够在服务器正常关闭之前完成。但有些读取，特别是大型仓库的克隆，取决于最终用户的网速，需要几分钟或几小时才能完成。直接打断这些操作是非常粗鲁的。可以在另一个副本上重新启动这些操作，但到目前为止的所有进度都将丢失。</p>
<p>因此，在Spokes中，为了主动重启一台服务器，我们需要先将它置于静默期（quiescing period）。当服务器处于静默状态时，它对于新的读取操作被标记为脱机，但允许现有的读取操作（包括克隆）完成。静默期可能会持续几秒到几个小时，具体取决于被重启的服务器上哪些读取操作处于活动状态。</p>
<p>可能会令人惊讶的是，写操作像往常一样被发送到服务器，即使它们静默也是如此。这是因为写操作需要在所有副本上运行，因此单个副本可以随时丢弃，不会发生用户可见的影响。此外，如果副本在静默时没有接收到任何写入操作，那么该副本将大大落后于其他副本，当它最终完全重新上线时，时会产生大量的追赶负载（catch-up load）。</p>
<p>我们不在Spokes文件服务器上执行“混乱猴子”（chaos monkey）测试<a href="#note10" id="note10ref"><sup>10</sup></a>，原因与我们在重新启动它们之前要将它们置为静默状态的原因相同：避免中断需要长时间运行的读取操作。也就是说，我们不会仅仅为了确认突发的单节点故障仍然（在大多数情况下）是无害的而随机重启文件服务器。</p>
<p>虽然我们不执行“混乱猴子”测试，我们仍然会按需要对服务器轮流进行重启，这实现了大致相同的测试目标。当我们需要进行一些需要重启的更改时——比如更改内核或文件系统参数，或更改BIOS设置——我们会将这些服务器置于静默状态并重启它们。我们将机架作为可用性区域<a href="#note11" id="note11ref"><sup>11</sup></a>，因此我们一次将整个机架置于静默状态。当给定机架中的服务器结束静默状态——即完成所有未完成的读取操作——我们分批重启这些服务器，每次最多五个。整个机架重启结束后，我们继续前进到下一个机架。</p>
<p>下图显示了在轮流重启期间失败的RPC操作。用不同的颜色标记每个服务器。值是堆叠的，因此在最高的峰值表示的时刻中，八个服务器在同时重启。浅红色块表示一台服务器未能正常重启，因此离线了大约两个小时。</p>
<p><img src="rolling-reboots.png" alt="滚动重启"></p>
<p>用直接插拔的方法移除服务器的弊端与计划外重启的弊端类似。除了会中断任何正在进行的读取操作外，这种行为还会为在这台服务器上托管的所有仓库带来几个小时的额外风险。当一台服务器突然消失时，之前存储在里面的所有仓库现在都只剩下两个副本了。两个副本足够执行任何读取或写入操作，但两个副本无法承受额外的故障。换句话说，在没有警告的情况下就删除服务器，这样会增加在同一天晚些时候写入操作被拒绝的概率。我们的目标是将这种可能性保持在最低水平。</p>
<p>因此，在准备移除一台服务器之前，我们不再把它存储的仓库副本作为任何仓库的活跃副本。Spokes仍然可以使用该服务器进行读写操作。但当它询问是否所有仓库都有足够的副本时，其中一些仓库——有副本位于将被移除的服务器上的那些 ——将声称不够，然后创建更多的副本。修复这一问题的过程类似于服务器直接消失后的修复过程，不过，区别在于，现在服务器仍然可用，以防其他服务器出现故障。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>可用性是很重要的，而持久性甚至更为重要。可用性衡量的是服务响应请求的时间长度<a href="#note12" id="note12ref"><sup>12</sup></a>。持久性衡量的是，服务能够可信地存储输入数据中的多少。</p>
<p>为了提供可用性和持久性，Spokes为每个仓库至少保留了三个副本。三个副本意味着，即使一个服务器失效，也不会对用户产生可见的影响。如果两个服务器都发生了故障，Spokes仍然可以为大部分仓库提供完全的访问权限，并为那些恰好有两个副本存储在这两个故障服务器上的存储库提供只读访问。</p>
<p>Spokes只在大多数副本——一般至少为两个——能够提交写入并得到相同的仓库状态时才接受对仓库的写入，这一要求通过确保所有副本上的写入顺序相同提供了一致性。通过在至少两个位置存储每个已提交的写入，它也可以在单个​​服务器发生故障时提供持久性。</p>
<p>Spokes的故障检测器通过监视实时应用程序流量，确定服务器何时脱机并绕过该问题。最后，Spokes具有自动修复功能，可在磁盘或服务器发生永久性故障时快速恢复。</p>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a>关于<a href="https://zh.wikipedia.org/wiki/Rsync" target="_blank" rel="noopener">rsync</a>：</p>
<blockquote>
<p>rsync是Unix下的一款应用软件，它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。rsync中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。<br>
在常驻模式（daemon mode）下，rsync默认监听TCP端口873，以原生rsync传输协议或者通过远程shell如RSH或者SSH提供文件。SSH模式下，rsync客户端运行程序必须同时在本地和远程机器上安装。<br>
rsync是以GNU通用公共许可证发行的自由软件。</p>
</blockquote>
<p><a id="note2" href="#note2ref"><sup>2</sup></a><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">CAP定理</a>：</p>
<blockquote>
<p>在理论计算机科学中，<strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
</blockquote>
<ul>
<li>一致性（<strong>C</strong>onsistence） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（<strong>P</strong> artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）<br>
根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li>
</ul>
<p><a id="note3" href="#note3ref"><sup>3</sup></a>不知道这个地方在说什么。是说Spokes能提供的功能远多于冗余性吗？</p>
<p><a id="note4" href="#note4ref"><sup>4</sup></a>heartbeat的定义（<a href="http://blog.51cto.com/hoolee/1408615" target="_blank" rel="noopener">http://blog.51cto.com/hoolee/1408615</a>）：</p>
<blockquote>
<p>Heartbeat 项目是Linux-HA工程的一个组成部分，它实现了一个高可用集群系统。心跳服务和集群通信是高可用集群的两个关键组件，在 Heartbeat 项目里，由 heartbeat 模块实现了这两个功能。<br>
heartbeat（Linux-HA）的工作原理：heartbeat最核心的包括两个部分，心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗 余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运行在对方主机上的资源或者服务。</p>
</blockquote>
<p><a id="note5" href="#note5ref"><sup>5</sup></a>所谓“<a href="https://en.wikipedia.org/wiki/All_clear" target="_blank" rel="noopener">All clear</a>”是一种防空警报，它的含义是空袭已经结束，民众可以离开防空洞。</p>
<p><a id="note6" href="#note6ref"><sup>6</sup></a><a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="noopener">远程过程调用</a>：</p>
<blockquote>
<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。</p>
</blockquote>
<p><a id="note7" href="#note7ref"><sup>7</sup></a>我没有完全理解M*N是什么意思。不过我猜测，这指的是错误是可以双向检测的。</p>
<p><a id="note8" href="#note8ref"><sup>8</sup></a>这张图大概显示了3个fetch请求，一个远端git worker请求和一个web api请求。</p>
<p><a id="note9" href="#note9ref"><sup>9</sup></a>此处令人思考的是，这一故障检测是如何实现的。我们需要了解请求是否会失败，以及一些能够进行请求的非文件服务器记录下的请求失败情况。通过其他服务器的请求情况，实际上，我们可以确定这些服务器的实际运行状况。而RPC图大概是需要通过收集所有请求的实际状况来绘制的。绘制完成之后，Spokes系统可能会根据某种策略自动进行结点状况判断，也可以绘制成实时状态图，让人类判断里面发生错误的结点。</p>
<p><a id="note10" href="#note10ref"><sup>10</sup></a><a href="https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey" target="_blank" rel="noopener">Chaos monkey</a>：</p>
<blockquote>
<p>Chaos Monkey是一种识别系统组并随机终止组中某个系统的服务。该服务在受控时间（不在周末和假日运行）和间隔（仅在工作时间运行）运行。在大多数情况下，我们将应用程序设计为在对等设备脱机时继续工作，但在这些特殊情况下，我们希望确保周围有人来解决和学习任何问题。考虑到这一点，Chaos Monkey只在工作时间运行，其目的是让工程师保持警觉并能够做出响应。</p>
</blockquote>
<p>（其实就是在系统里自动造成随机失败，增加工程师的警觉性）</p>
<p><a id="note11" href="#note11ref"><sup>11</sup></a>（原注）将机架作为可用性区域处理意味着我们放置仓库副本的时候需要保证同一机架中不会存储同一存储库的两个副本。这样就可以保证，即使丢失了整个服务器机架，也不会影响托管在里面的任何仓库的可用性或持久性。我们选择机架作为可用性区域，是因为几种重要的故障模式（failure mode），特别是与电源和网络相关的故障模式，可能会同时影响整个服务器机架。</p>
<blockquote>
<p>“可用性区域”（Availability Zone）由独立的数据中心构成，每个地区都是一个数据中心集群，这些数据中心之间距离足够近，这样可以保证数据库等应用的延迟足够低，但又足够远，这样可以防止出现意外时同时宕机，例如亚马逊在日本的数据中心就分布在不同的地震区。（<a href="https://ctocio.com/ccnews/5685.html" target="_blank" rel="noopener">香港：亚马逊云计算全球化布局下一站？</a>）</p>
</blockquote>
<p><a id="note12" href="#note12ref"><sup>12</sup></a>所以这个是单次请求所需的时间长度，和服务器自己的运行时间没有关系？那么，看来前面搞错了……</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Translation/"><i class="fas fa-hashtag fa-fw"></i>Translation</a>
                
                    <a href="/tags/Github/"><i class="fas fa-hashtag fa-fw"></i>Github</a>
                
                    <a href="/tags/Spokes/"><i class="fas fa-hashtag fa-fw"></i>Spokes</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
              <p class="current">
                  1 / 2
              </p>
              
                  <a class="next" rel="next" href="/archives/2018/07/page/2/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->



    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
