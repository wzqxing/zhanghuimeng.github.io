<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018/7 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018.7'}
    </script>




  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/introducing-dgit-translation/">
              
                  DGit简介
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-05
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>这篇文章翻译自<a href="https://githubengineering.com/introducing-dgit/" target="_blank" rel="noopener">Introducing DGit</a>，我加入了一些自己的注解。（大部分翻译来自谷歌翻译，水平比我更高，只有少数地方译错，我感觉翻译行业的前景很不乐观。）</p>
<hr>
<p>Edit：<a href="http://githubengineering.com/building-resilience-in-spokes/" target="_blank" rel="noopener">DGit现在改名叫Spokes了</a></p>
<p>GitHub在数百台服务器<a href="#note1" id="note1ref"><sup>1</sup></a>上托管了超过3500万个存储库和超过3000万个Gists。在过去的一年中，我们构建了DGit，这是一种新的分布式存储系统，可显著提高对Git内容的提取和存储的可用性（availability），可靠性（reliability）和性能（performance）。</p>
<p>DGit是“Distributed Git”的缩写。正如许多读者已经知道的那样，Git本身是分布式的——Git存储库的任何副本都包含项目整个历史记录中的每个文件，分支和提交。DGit使用Git的这个属性在三个不同的服务器上保存每个存储库的三个副本。即使其中一个服务器出现故障，DGit的设计也能够使存储库的可用性不会发生中断。即使在极端情况下，存储库的两个副本同时不可用，存储库仍然可读（readable）；即，提取（fetch），克隆（clone）和大多数Web UI仍然能够继续工作。</p>
<p>DGit在应用程序层执行复制，而不是在磁盘层执行复制。不妨把这些副本看做是三个通过Git协议保持同步的松散耦合的Git仓库，而不是相同的充满了仓库的磁盘映像。此设计使我们能够以极大的灵活性确定仓库副本的存储位置以及用哪个副本进行读取操作。</p>
<p>如果需要使文件服务器脱机，则DGit会自动确定哪些仓库的副本少于三个，并在其他文件服务器上创建这些存储库的新副本。此“修复”过程将所有剩余的服务器用作源和目标。由于“修复”过程的吞吐量是N-N<a href="#note2" id="note2ref"><sup>2</sup></a>，因此速度非常快。所有这一切都没有任何停机时间。</p>
<h2 id="dgit只使用普通的git"><a class="markdownIt-Anchor" href="#dgit只使用普通的git"></a> DGit只使用普通的Git</h2>
<p>大多数最终用户将其Git仓库作为对象、包文件和引用存储在单个<code>.git</code>目录中。他们使用Git命令行客户端、GitHub Desktop等图形客户端或Visual Studio等IDE中内置的Git支持来访问仓库。可能会令人惊讶的是，GitHub的仓库存储层DGit是使用相同的技术构建的。为什么不使用SAN<a href="#note3" id="note3ref"><sup>3</sup></a>，一个分布式文件系统？或者其他的能够将持久存储数据的问题抽象化的神奇的云技术？</p>
<p>答案很简单：它速度快，而且很健壮。</p>
<p>Git对延迟非常敏感。一个简单的<code>git log</code>或者<code>git blame</code>命令可能需要顺序加载和遍历数千个Git对象。如果这些低级磁盘访问存在任何延迟，则性能会受到严重影响。因此，将仓库存储在分布式文件系统中是不可行的。Git是为访问高速磁盘而优化的，因此DGit文件服务器将仓库存储在本地高速SSD上。</p>
<p>在更高的层次上，Git还经过优化，可以在通过协议在Git仓库之间之间高效更新（例如，推送和提取）。因此，我们使用这些协议来保持DGit副本同步。</p>
<p>Git是一种成熟且经过良好测试的技术。为什么有一级方程式赛车可用时要重新发明轮子？</p>
<p>GitHub的理念始终是，通过尽可能接近用户使用Git的方式，在我们的服务器上使用Git<a href="#note4" id="note4ref"><sup>4</sup></a>。DGit延续了这一传统。如果我们发现性能瓶颈或其他问题，我们有几个核心的Git和libgit2贡献者会解决这些问题，并将补丁提交到人人可用的开源项目。我们在Git方面的经验和专业知识使其成为用于DGit复制操作的的最优选择。</p>
<h2 id="使用dgit前后的github架构"><a class="markdownIt-Anchor" href="#使用dgit前后的github架构"></a> 使用DGit前后的GitHub架构</h2>
<p>之前，我们使用现有的磁盘层复制技术（即RAID和<a href="https://docs.linbit.com/" target="_blank" rel="noopener">DRBD</a><a href="#note5" id="note5ref"><sup>5</sup></a>）保存了仓库数据的副本。我们将文件服务器成对组织起来，每个活动文件服务器都有一个通过交叉电缆连接的专用在线备份服务器。每个磁盘有四个副本：主文件服务器上通过RAID保存两个副本，另外两个副本使用DRBD保存在该文件服务器的热备份上。如果文件服务器出现任何问题——例如，硬件故障，软件崩溃或过载情况——一名人类将确认故障并命令备用服务器接管。因此，冗余级别是良好的，但故障转移过程需要手动干预，并且不可避免地导致故障服务器上的仓库在一段时间内不可用。为了尽量减少此类事件，我们始终将仓库存储在专用且高度可靠的服务器上。</p>
<p>现在改为使用DGit，每个仓库都存储在三个服务器上，这三个服务器独立地分布在我们的大群文件服务器中。DGit自动选择托管每个仓库的服务器，使这些副本保持同步，并选择处理每个传入的读取请求最的佳服务器。写操作会同时被导入到三个副本中，仅仅当至少两个副本确认写入成功时才会提交。</p>
<p><img src="fileservers.png" alt="文件服务器复制"></p>
<p>现在GitHub把仓库存储在一个名为<code>github-dfs</code>的集群中——<code>dfs</code>是“DGit file server”的缩写。这些仓库存储在这些文件服务器上的本地磁盘中，并通过Git和<a href="https://libgit2.github.com/" target="_blank" rel="noopener">libgit2</a>进行服务。此集群的客户端包括Web前端和与用户的Git客户端通信的代理。</p>
<p><img src="architecture.png" alt="GitHub架构"></p>
<h2 id="dgit的优势"><a class="markdownIt-Anchor" href="#dgit的优势"></a> DGit的优势</h2>
<p>DGit为GitHub用户和内部GitHub基础架构团队都提供了许多优势。它也是实现更多即将到来的创新的关键基础。</p>
<ul>
<li>文件服务器不再必须作为成对的相同服务器部署，彼此靠近，并通过交叉电缆一对一连接。我们现在可以在任何空间配置中使用异构的文件服务器池。</li>
<li>在开始使用DGit之前，当整个服务器发生故障时，需要尽快将其替换，因为其备份服务器运行时没有备用服务器。两个服务器一起中断可能会使数十万个仓库无法访问。现在，当服务器出现故障时，DGit会快速制作其托管的仓库的新副本，并在整个集群中自动分发它们。</li>
<li>路由故障的破坏性大大减小了。我们不必重新启动并重新同步整个服务器，只需停止到服务器的路由流量，直到它恢复。现在可以安全地重启生产服务器，没有过渡期。由于服务器中断对DGit的破坏性较小，我们不再需要等待人类确认中断; 我们可以立即绕过它。</li>
<li>我们不再需要保留大多数时间都在闲置的热备用文件服务器。在DGit中，每个CPU和所有内存都可用于处理用户流量。虽然像push这样的写操作必须转到仓库的每个副本，但是任何副本都可以提供读操作。由于读操作的数量远远超过写操作，因此每个仓库现在可以处理的流量几乎是以前的三倍。下图显示了<code>git</code>处理在旧文件服务器（蓝色）和DGit服务器（绿色）上分别引起的CPU负载。蓝线标识活动服务器的平均值; 它们的热备件不包括在内。DGit服务器上的负载较低：峰值时大约低三倍，而低谷时大约低两倍。由于所有文件服务器都有无法在副本之间分配的后台维护任务，因此低谷性能的改进没有三倍那么多。</li>
</ul>
<p><img src="cpu-load.png" alt="DGit减少了CPU负载"></p>
<ul>
<li>DGit可以自动平衡磁盘和CPU热点。添加服务器根本不需要计划：DGit只是随机地将现有仓库移动到新服务器，直到磁盘空间和CPU负载恢复平衡。随着现有仓库的扩展或缩小，DGit会移动它们以保持磁盘空间平衡。随着仓库受欢迎程度的增加或降低，DGit会转移负载以缓解CPU和内存热点。在下图中，一个DGit服务器集群（以红色显示）大部分已满，直到我们添加了一个新的服务器集群（以蓝色显示），其中包含更大的磁盘，以减轻磁盘空间压力。第三个集群（绿色）有两个服务器接收仓库，一个服务器放弃它们。继续移动存储库，直到所有服务器的磁盘空闲空间比例相近。</li>
</ul>
<p><img src="disk-balancing.png" alt="磁盘平衡图"></p>
<ul>
<li>DGit减少了存储库之间的命运共享（fate sharing）<a href="#note6" id="note6ref"><sup>6</sup></a>。在使用DGit之前，一组固定的仓库一起存储在单个服务器上和该服务器的备用服务器上。如果一个存储库太大，代价太昂贵或太受欢迎，那么该文件服务器上的其他仓库可能会变慢。在使用DGit之后，可以通过其他副本服务其他的仓库，这些副本不太可能与繁忙仓库的其他副本位于相同的服务器上。</li>
<li>副本的分离意味着我们可以将存储库的副本放在不同的可用区域中，甚至可以放在不同的数据中心中。可用性得到改善，我们（终于）可以通过在地理上靠近用户的服务器为用户提供内容。</li>
</ul>
<h2 id="dgit的试运行"><a class="markdownIt-Anchor" href="#dgit的试运行"></a> DGit的试运行</h2>
<p>DGit带来的变化是巨大的，所以我们一直在逐步推广它。DGit最复杂的特性是，复制不再是透明的：现在，每个存储库都显式存储在三台服务器上，而不是一台有自动同步热备份的服务器上。因此，DGit不能再依靠DRBD和RAID控制器来保持副本同步，必须实现自己的序列化处理（serializability）<a href="#note7" id="note7ref"><sup>7</sup></a>，锁定（locking），故障检测（failure detection）和二次同步（resynchronization）<a href="#note8" id="note8ref"><sup>8</sup></a>。我们将在以后的帖子中探讨这些内容丰富的主题。这些足以说明，在依赖DGit存储客户数据之前，我们需要彻底测试这些功能。我们的部署经过多个步骤：</p>
<ul>
<li>我们首先移动了DGit开发人员的个人仓库。</li>
<li>我们移动了一些私人的，GitHub拥有的仓库，这些仓库不属于运行网站的一部分。我们首先在每个存储库中打开一个issue，请求我们的同事的允许。这既是一个礼貌的预先通知，也是一种开始向GitHub其余部分解释DGit的方法。</li>
<li>我们移动了GitHub的其余大部分私有仓库。</li>
<li>我们停止移动存仓库大约三个月，同时我们进行了大量测试，对DGit相关流程进行自动化，为DGit撰写了操作级别的文档，并且（咳咳）修复了偶尔发生的错误。</li>
<li>经过三个月的稳定运行后，我们移动了大多数GitHub拥有的公共存储库，以及外部用户拥有的那些存储库的fork。例如，<a href="https://github.com/github/linguist" target="_blank" rel="noopener">Linguist</a>的拥有者是GitHub，但其大约1,500个fork属于外部用户。托管公共仓库测试了DGit处理大型仓库的网络和更高流量负载的能力。</li>
<li>我们开始移动不属于GitHub的公共仓库。我们立即从GitHub的<a href="https://github.com/explore" target="_blank" rel="noopener">showcases</a>和<a href="https://github.com/trending" target="_blank" rel="noopener">流行仓库</a>中找出一些有很多分支的繁忙的仓库：包括<a href="https://github.com/ruby/ruby" target="_blank" rel="noopener">Ruby</a>、<a href="https://github.com/rails/rails" target="_blank" rel="noopener">Rails</a>、<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">Bootstrap</a>和<a href="https://github.com/mbostock/d3" target="_blank" rel="noopener">D3</a>等等，并且搬运了它们。我们的目标是在DGit中尽可能多地获取流量和不同的使用模式，同时仍然手工采集一小部分仓库的数据。</li>
<li>距离我们第一次移动自己的仓库六个月后，令人满意的是，DGit能够很好地托管网站，于是我们开始批量移动仓库。</li>
</ul>
<p><img src="growth.png" alt="DGit中存储库的百分比"></p>
<p>在试运行阶段，我们不断尝试关闭服务器，有时会同时关闭几个服务器，此时它们正在提供实时生产流量。用户操作并没有受到影响。</p>
<p>在撰写本文时，58％的存储库和96％的Gists（占Git操作的67％）都迁移到了DGit中。我们正在尽快将剩余的文件服务器对转换为DGit服务器。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>GitHub始终致力于快速可靠地获取，推送和查看仓库。在未来几年内，我们将使用DGit作为我们的仓库存储层以实现这些目标，同时进行横向扩展并提高容错能力。</p>
<p>在接下来的一个月里，我们将发布更多对DGit背后的技术进行深入研究的帖子。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>我之前曾经在网上看到一篇相关的评论帖子，但是现在找不到了，我明天再找……</p>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a>这个服务器的数量比我想象的要少。（或者谷歌翻译错了，应该是成百上千台。）</p>
<p><a id="note2" href="#note2ref"><sup>2</sup></a>大概是因为源可以有多个，目标也可以有多个。不过这个吞吐量可能翻译错了，我也不懂“N-by-N”具体是什么意思。</p>
<p><a id="note3" href="#note3ref"><sup>3</sup></a>关于SAN（摘自维基百科）：</p>
<blockquote>
<p>存储区域网络（英语：storage area network，缩写作 SAN）是一种连接外接存储设备和服务器的架构。人们采用包括光纤通道技术、磁盘阵列、磁带柜、光盘柜的各种技术进行实现。该架构的特点是，连接到服务器的存储设备，将被操作系统视为直接连接的存储设备。除针对大型企业的企业级存储方案外，随着在2000年后价格和复杂度的降低，越来越多的中小型企业也在逐步采用该项技术。</p>
</blockquote>
<p>它访问的是磁盘设备，而不是文件。<br>
<a id="note4" href="#note4ref"><sup>4</sup></a>虽然我现在并不理解这个传统的存在意义和价值。</p>
<p><a id="note5" href="#note5ref"><sup>5</sup></a>DRBD=Distributed Replicated Block Device，一个基于软件在不同宿主之间创建块设备（硬盘、翻去、逻辑分区等）的镜像的存储复制服务。功能特性包括：</p>
<ul>
<li>实时</li>
<li>透明</li>
<li>同步或异步</li>
</ul>
<p>（<a href="https://docs.linbit.com/docs/users-guide-9.0/#p-intro" target="_blank" rel="noopener">https://docs.linbit.com/docs/users-guide-9.0/#p-intro</a>）</p>
<p><a id="note6" href="#note6ref"><sup>6</sup></a>关于命运共享：</p>
<blockquote>
<p>命运共享（Fate Sharing）建议将所有必要的状态放在通信端点，这些状态用于维护一个互动的通信关联（例如虚拟连接）。由于这个原因，导致通信失效的情况也会导致一个或更多端点失效，这样显然会导致整个通信的失败。命运共享是一种通过虚拟连接（例如，由TCP实现的连接）维持活动的设计理念，即便网络在一段时间内失效。命运共享也支持一种“带智能终端主机的哑网络”模型。</p>
</blockquote>
<p>（<a href="https://blog.csdn.net/qq_37653144/article/details/80297681" target="_blank" rel="noopener">端到端原则与命运共享原则</a>；还是没太看懂）</p>
<p><a id="note7" href="#note7ref"><sup>7</sup></a>可串行化（<a href="https://csruiliu.github.io/blog/2018/02/15/db-serialization/" target="_blank" rel="noopener">Database Conflict Serializability [数据库冲突可串行化]</a>）：</p>
<blockquote>
<p>多个事务[Transaction]的并发执行是正确的，当且仅当其结果与按某一次串行地执行这些事务时的结果相同，称这种调度策略为可串行化的调度。–数据库系统概论第四版</p>
</blockquote>
<p><a id="note8" href="#note8ref"><sup>8</sup></a>查了之后，发现一堆心脏病疗法，仍然无法很好地认识什么是resynchronization。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Translation/"><i class="fas fa-hashtag fa-fw"></i>Translation</a>
                
                    <a href="/tags/Github/"><i class="fas fa-hashtag fa-fw"></i>Github</a>
                
                    <a href="/tags/Spokes/"><i class="fas fa-hashtag fa-fw"></i>Spokes</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-04-summary-the-abstraction-the-process/">
              
                  OSTEP第04章总结：The Abstraction: The Process
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a>。</p>
<hr>
<p>这一章主要讲了OS的一种基本抽象模型：进程（Process）。</p>
<ul>
<li>进程的定义</li>
<li>与进程相关的API</li>
<li>进程的创建过程和状态（生命周期）</li>
<li>进程的数据结构（进程控制块和进程状态队列）</li>
</ul>
<h2 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h2>
<p>我们首先给出一个进程的非正式定义：进程是一个正在运行的程序。</p>
<p>我们通常希望同时运行多个（甚至成百上千个）程序。这样用起来很方便，但是我们遇到的挑战是：如何创造这样由很多个虚拟CPU的假象？</p>
<p>OS通过对CPU进行虚拟化创造这一假象。它不断地运行一个程序，暂停，然后再运行下一个。这被称作CPU的分时共享（time sharing），这种技术允许程序的并发，同时也会牺牲一定的性能，因为一个程序的运行时间肯定会慢得多。</p>
<p>我们可以把实现CPU的虚拟化的过程拆分成两个步骤：</p>
<ul>
<li>机制（mechanism）：这是实现一种功能的底层方法或协议；如上下文切换（context switch），这是一种分时机制（time-sharing mechanism），用于帮助OS实现暂停一个程序后切换到下一个的功能</li>
<li>策略（policy）：这是利用底层机制，在OS内进行决策的算法；如调度（scheduling）算法会利用历史信息、程序信息和性能评价方式进行决策</li>
</ul>
<p>这是一种模块化的程序设计思路。不过，本节中我们似乎既没有讲机制也没有讲策略，而是讲了一些抽象内容（进程）的基本概念。</p>
<h2 id="进程的正式定义"><a class="markdownIt-Anchor" href="#进程的正式定义"></a> 进程的正式定义</h2>
<p>上面给出的那个定义是正确的，然而并不全面。如何更具体地描述一个进程？一般来说，我们可以通过记录进程在运行过程中访问或影响的系统部分来描述一个进程。于是我们可以定义进程的机器状态（machine state）：</p>
<ul>
<li>内存（地址空间）：包含指令和程序读写的数据</li>
<li>寄存器：通用寄存器和一些特殊寄存器，如PC（program counter）和栈指针、帧指针</li>
<li>I/O信息：进程开启的文件列表</li>
</ul>
<h2 id="与进程相关的api"><a class="markdownIt-Anchor" href="#与进程相关的api"></a> 与进程相关的API</h2>
<p>既然进程是OS为我们提供的一种抽象，那么显然需要一些使用它的方法。因此下面介绍了一些与进程相关的API，一般来说，任何现代OS都提供了这些API：</p>
<ul>
<li>创建（create）：创建新进程</li>
<li>销毁（destroy）：强制终止进程，对于失控的进程来说是很必要的</li>
<li>等待（wait）：等待其他进程结束运行</li>
<li>其他控制（miscellaneous control）：除了杀死或等待进程以外的控制方式，如将进程挂起后恢复运行的机制</li>
<li>状态（status）：通常会提供一些能够获得进程状态信息的接口，包括运行时间和状态</li>
</ul>
<h2 id="进程的生命周期"><a class="markdownIt-Anchor" href="#进程的生命周期"></a> 进程的生命周期</h2>
<h3 id="进程的创建过程"><a class="markdownIt-Anchor" href="#进程的创建过程"></a> 进程的创建过程</h3>
<p>为了启动一个进程，OS需要做以下事情：</p>
<ol>
<li>将程序的代码和静态数据（初始化了的变量）加载到进程地址空间中。通常程序以某种可执行文件格式存储在磁盘（或者SSD）中，所以OS需要从磁盘读取数据。</li>
</ol>
<ul>
<li>此时有一个加载策略的选择问题：积极加载（eager load）还是懒惰加载（lazy load）</li>
<li>积极加载：将所有代码和数据在运行之前就全部装入内存中，是早期和简单OS的做法</li>
<li>懒惰加载：用到对应的代码和数据时才加载，是现代OS的做法。</li>
<li>这个问题与分页（paging）和交换（swapping）有关，之后还会谈到。</li>
</ul>
<ol start="2">
<li>为程序的运行栈分配内存；对栈进行初始化（比如把<code>main</code>函数的<code>argc</code>和<code>argv</code>放进去）</li>
<li>为程序的堆分配内存。堆用于在程序运行中动态分配内存，程序调用<code>malloc()</code>请求内存，调用<code>free()</code>释放内存。</li>
<li>对I/O进行初始化：对于类UNIX系统，每个进程默认有三个打开的文件描述符（file descriptor），用于标准输入、标准输出和标准错误输出，这使得进程能够从终端读入输入并打印到屏幕。我们将在本书的第三部分（持久化）中更多的谈到这个问题。</li>
<li>跳转到<code>main()</code>函数的起始点，将CPU的控制权交给新创建的进程。</li>
</ol>
<h3 id="进程的状态模型"><a class="markdownIt-Anchor" href="#进程的状态模型"></a> 进程的状态模型</h3>
<p>创建了一个进程之后，它的状态（state）会不断变化。一个简化的进程三状态模型如下：</p>
<ul>
<li>运行态（running）：进程正在处理器上运行，正在执行指令。</li>
<li>就绪态（ready）：进程已经准备好执行了，但由于某些原因，OS现在并没有运行它。</li>
<li>等待态（blocked）：进程执行了一些操作，使得它不能继续运行，直到发生某些其他事件为止。例如，进程启动对磁盘的I/O请求时，它就被阻塞了，此时其他的进程可以使用处理器。</li>
</ul>
<p><img src="fig4-2_process-state-transitins.png" alt="进程在状态之间的迁移"></p>
<p>上图说明了这个简化模型中进程如何在状态间迁移：</p>
<ul>
<li>OS可以通过调度使进程在运行态和就绪态之间转换</li>
<li>如果进程进入了等待态，则只有对应的事件发生时才会进入就绪态</li>
</ul>
<p>下面举两个例子进行说明。在第一个例子中，两个进程只使用CPU而不进行I/O；调度策略是进程0执行完之后进程1才能开始执行。</p>
<p><img src="fig4-3_tracing-process-state-cpu-only.png" alt="只使用CPU的两个进程的状态变化"></p>
<p>在第二个例子中，进程会进行I/O操作。当进程0进行I/O之后，它进入阻塞状态。于是进程1开始运行。进程0的I/O完成之后，它进入就绪态，等待进程1执行结束之后继续执行。</p>
<p><img src="fig4-4_tracing-process-state-cpu-and-io.png" alt="使用CPU并进行I/O的两个进程的状态变化"></p>
<p>事实上，在上述过程中，OS采用了以下两种策略：</p>
<ul>
<li>在进程0进行I/O时切换到进程1：这个决策看起来是明智的，因为可以增加CPU使用率</li>
<li>在进程0的I/O操作结束之后，没有立即切换回切换0：这个策略的好坏很难说</li>
</ul>
<p>（上述内容将出现在作业中）</p>
<h2 id="进程的数据结构"><a class="markdownIt-Anchor" href="#进程的数据结构"></a> 进程的数据结构</h2>
<p>上面的内容可以说是非常抽象了。所以下面会讲到，这些抽象的内容如何用OS中具体的数据结构来表示。</p>
<h3 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h3>
<p>我们把进程信息对应的数据结构称为进程控制块（Process Control Block，PCB）。下面是xv6教学OS中一个实际的进程控制块的定义（也就是说，会涉及大量<strong>底层机制</strong>内容）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// the registers xv6 will save and restore</span><br><span class="line">// to stop and subsequently restart a process</span><br><span class="line">struct context &#123;</span><br><span class="line">    int eip;</span><br><span class="line">    int esp;</span><br><span class="line">    int ebx;</span><br><span class="line">    int ecx;</span><br><span class="line">    int edx;</span><br><span class="line">    int esi;</span><br><span class="line">    int edi;</span><br><span class="line">    int ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// the different states a process can be in</span><br><span class="line">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line">// the information xv6 tracks about each process</span><br><span class="line">// including its register context and state</span><br><span class="line">struct proc &#123;</span><br><span class="line">    char *mem;                  // Start of process memory</span><br><span class="line">    uint sz;                    // Size of process memory</span><br><span class="line">    char *kstack;               // Bottom of kernel stack</span><br><span class="line">                                // for this process</span><br><span class="line">    enum proc_state state;      // Process state</span><br><span class="line">    int pid;                    // Process ID</span><br><span class="line">    struct proc *parent;        // Parent process</span><br><span class="line">    void *chan;                 // If non-zero, sleeping on chan</span><br><span class="line">    int killed;                 // If non-zero, have been killed</span><br><span class="line">    struct file *ofile[NOFILE]; // Open files</span><br><span class="line">    struct inode *cwd;          // Current directory</span><br><span class="line">    struct context context;     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;       // Trap frame for the</span><br><span class="line">                                // current interrupt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面对其中一些比较重要的内容给出说明。首先可以看到，<code>context</code>中存储了通用寄存器的内容，用于上下文切换（保存一个暂停的进程的寄存器的值；在进程恢复运行时，这些值将被重新加载到寄存器中），这是之前讲到的。其次可以发现，这里定义了6种状态，和之前讲到的三状态模型不完全相符（这可能也体现了抽象策略和底层机制的区别）。除了运行态、就绪态和等待态以外，此处还定义了其他的状态，如初始（initial）态（进程刚被创建时的状态，对应的大概是上述代码中的EMBRYO态）和终止（final）态（进程已经退出，但尚未被完全清理，在类UNIX系统中，这一状态被称为僵尸（zombie）态）。进入终止态的进程允许其他进程（通常是创建这个进程的父进程）检查进程的返回值，查看它是否成功结束。父进程在自己结束之前会执行最后一个调用（<code>wait()</code>），等待子进程执行完成（进入终止态），此时OS可以清理子进程相关的数据结构。</p>
<p>（我不知道我有没有理解清楚关于僵尸态的内容）</p>
<h3 id="进程状态队列"><a class="markdownIt-Anchor" href="#进程状态队列"></a> 进程状态队列</h3>
<p>为了管理进程的状态，OS会维护一些进程状态队列，用来跟踪就绪进程、正在运行的进程和阻塞进程，并且在发生事件的时候唤醒正确的进程。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-03-summary-a-dialogue-on-virtualization/">
              
                  OSTEP第03章总结：A Dialogue on Virtualization
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-03
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这篇对话是本书第一部分——虚拟化（Virtualization）——的开头，简单叙述了一下虚拟化的概念。</p>
<p>Professor教授（我今后就这样叫他了，毕竟这位教授的名字就是“Professor”）举了一个这样的例子：假设我们有一个物理的桃子，有很多人都想吃桃子，但桃子只有一个，不能满足所有人的需求。于是我们通过某种神奇的技术，在物理桃子的基础上创造出许多虚拟桃子，仿佛每个人都拥有自己的桃子一般，但事实上只有一个桃子。</p>
<p>这时Student学生（同理）提了一个很好的问题：如果很多人同时共享一个桃子，他们应该会注意到这一点。Professor教授指出，这些人大部分时间都在干别的，所以把桃子直接拿走是完全可行的。</p>
<p>Student学生要求Professor教授举一个具体的例子——那就PCU吧。假定系统里有一个物理CPU，虚拟化技术使得系统里好像有很多虚拟CPU在同时运行。每个进程都认为它独占了一个虚拟CPU，而实际上只有一个物理CPU。OS的工作就是将实际的CPU进行虚拟化。</p>
<p>最后Professor教授表示，今后不会再有这么多桃子的例子，因为他自己也不是很喜欢吃桃子。（但是作者很喜欢吧？）</p>
<hr>
<p>我很想探讨一下这个故事中的比喻到底指代的什么。桃子当然指的是被虚拟化后共享的资源——除了物理CPU之外，物理内存也被进程这样共享。不过桃子和CPU相比有一个小问题：桃子是会被吃完的，也就是说，这是一种不可再生资源，和CPU可以不断重复利用的性质不同。那我们就当这些食客只是在舔桃子好啦……</p>
<p>所谓“很多人同时共享一个桃子会被注意到”也许只是Student学生随口一说的结果，但我觉得这一点说的更像是同步互斥问题。毕竟进程没有思想和感受，它们之间一般是相互隔离的，所谓“注意到”必然是进程通信或共享资源的结果，而这种时候是一定会出现同步互斥问题的。但是，如果这样认为，Professor教授给出的解决方案就有点儿怪了——这些人大部分时间都在干别的？我想这说的是CPU运行进程和设备I/O的并行化——I/O需要的时间很多，所以在需要进行I/O时，进程就主动放弃控制权，切换别的进程来继续占用CPU。这一点当然很好，不过好像并不能解决同步互斥问题。</p>
<p>不过这也并没有那么重要，希望Professor教授和Student在书里过得开心，吃点自己想吃的水果好啦。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-02-summary-introduction-to-operating-systems/">
              
                  OSTEP第02章总结：Introduction to Operating Systems
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf</a>。</p>
<hr>
<p>这一章对全书内容做了一些简单的概括：</p>
<ul>
<li>用三个程序概括了本书将讲到的三个基本概念（虚拟化、并发、持久化）</li>
<li>讲了一些OS的设计目标和OS的历史</li>
</ul>
<h2 id="基本概念概述"><a class="markdownIt-Anchor" href="#基本概念概述"></a> 基本概念概述</h2>
<h3 id="虚拟化"><a class="markdownIt-Anchor" href="#虚拟化"></a> 虚拟化</h3>
<p>虚拟化是本书第一部分的主题。</p>
<h4 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: cpu &lt;string&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char *str = argv[1];</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">        Spin(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中调用的<code>Spin()</code>函数（具体程序见本章附带的<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Code/code.intro.tgz" target="_blank" rel="noopener">代码</a>）会在运行1秒后返回。这个程序会不断运行，每秒输出一个<code>A</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o cpu cpu.c -Wall</span><br><span class="line">prompt&gt; ./cpu &quot;A&quot;</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">ˆC</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>如果同时运行不同的程序实例，CPU会不断在程序之间切换，使得每个程序都认为自己独占了CPU，这被称为CPU的<strong>虚拟化</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./cpu A &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D &amp;</span><br><span class="line">[1] 7353</span><br><span class="line">[2] 7354</span><br><span class="line">[3] 7355</span><br><span class="line">[4] 7356</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而OS选择什么程序来运行是一种<strong>策略</strong>，之后我们会学到相关内容（进程调度）。</p>
<h4 id="内存的虚拟化"><a class="markdownIt-Anchor" href="#内存的虚拟化"></a> 内存的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: mem &lt;value&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int *p;                   // memory for pointer is on &quot;stack&quot;</span><br><span class="line">    p = malloc(sizeof(int));  // malloc&apos;d memory is on &quot;heap&quot;</span><br><span class="line">    assert(p != NULL);</span><br><span class="line">    printf(&quot;(pid:%d) addr of p:        %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) &amp;p);</span><br><span class="line">    printf(&quot;(pid:%d) addr stored in p: %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) p);</span><br><span class="line">    *p = atoi(argv[1]);       // assign value to addr stored in p</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        Spin(1);</span><br><span class="line">        *p = *p + 1;</span><br><span class="line">        printf(&quot;(pid:%d) value of p: %d\n&quot;, getpid(), *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代机器的内存模型就是一个数组，读写都需要给出地址。</p>
<p>上述程序所做的事很简单：</p>
<ul>
<li>分配一些内存</li>
<li>打印内存的地址，以及程序的PID</li>
<li>将数0放入新分配的内存的第一个位置（4字节的int）中</li>
<li>循环，将p中存储的值+1</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem</span><br><span class="line">(2134) address pointed to by p: 0x200000</span><br><span class="line">(2134) p: 1</span><br><span class="line">(2134) p: 2</span><br><span class="line">(2134) p: 3</span><br><span class="line">(2134) p: 4</span><br><span class="line">(2134) p: 5</span><br><span class="line">ˆC</span><br></pre></td></tr></table></figure>
<p>如果仍然同时运行几个程序的实例，则会发现，每个程序都在同一地址处分配内存，而且对这一内存处存储的值的更新是相互独立的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem &amp;; ./mem &amp;</span><br><span class="line">[1] 24113</span><br><span class="line">[2] 24114</span><br><span class="line">(24113) address pointed to by p: 0x200000</span><br><span class="line">(24114) address pointed to by p: 0x200000</span><br><span class="line">(24113) p: 1</span><br><span class="line">(24114) p: 1</span><br><span class="line">(24114) p: 2</span><br><span class="line">(24113) p: 2</span><br><span class="line">(24113) p: 3</span><br><span class="line">(24114) p: 3</span><br><span class="line">(24113) p: 4</span><br><span class="line">(24114) p: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这说明OS对内存进行了虚拟化，每个进程访问的是自己的虚拟地址空间。</p>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common_threads.h&quot;</span><br><span class="line"></span><br><span class="line">volatile int counter = 0;</span><br><span class="line">int loops;</span><br><span class="line"></span><br><span class="line">void *worker(void *arg) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">        counter = counter + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: threads &lt;loops&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    loops = atoi(argv[1]);</span><br><span class="line">    pthread_t p1, p2;</span><br><span class="line">    printf(&quot;Initial value : %d\n&quot;, counter);</span><br><span class="line">    Pthread_create(&amp;p1, NULL, worker, NULL);</span><br><span class="line">    Pthread_create(&amp;p2, NULL, worker, NULL);</span><br><span class="line">    Pthread_join(p1, NULL);</span><br><span class="line">    Pthread_join(p2, NULL);</span><br><span class="line">    printf(&quot;Final value   : %d\n&quot;, counter);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一程序通过调用<code>Pthread_create</code>创建了两个线程，分别将一个计数器自增N次，然后将计数器的结果输出。显然，正常情况下程序输出应该为2N。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o thread thread.c -Wall -pthread</span><br><span class="line">prompt&gt; ./thread 1000</span><br><span class="line">Initial value : 0</span><br><span class="line">inal value : 2000</span><br></pre></td></tr></table></figure>
<p>但如果两个线程执行的次数N比较大，则程序的输出可能不再会为2N，而且会不太稳定。这是由于+1的操作不是原子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 143012 // huh??</span><br><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 137298 // what the??</span><br></pre></td></tr></table></figure>
<p>这体现了并发中可能出现的一些问题，我们将要在本书的第二部分讲到这些问题。</p>
<h3 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void do_work() &#123;</span><br><span class="line">    int fd = open(&quot;/tmp/file&quot;, O_WRONLY | O_CREAT | O_TRUNC,</span><br><span class="line">		  S_IRUSR | S_IWUSR);</span><br><span class="line">    assert(fd &gt;= 0);</span><br><span class="line">    char buffer[20];</span><br><span class="line">    sprintf(buffer, &quot;hello world\n&quot;);</span><br><span class="line">    int rc = write(fd, buffer, strlen(buffer));</span><br><span class="line">    assert(rc == strlen(buffer));</span><br><span class="line">    printf(&quot;wrote %d bytes\n&quot;, rc);</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    do_work();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会创建文件<code>/tmp/file</code>，并在里面写入字符串<code>hello world</code>。</p>
<p>内存是一种易失性存储，所以需要能够持续性地存储程序的硬件和软件，也就是硬盘（SSD）和文件系统。</p>
<p>和虚拟化的内存地址空间相比，因为用户通常会使用文件来共享信息，所以OS并不会为每个应用进程创建虚拟化的磁盘。OS向硬盘写数据的过程是十分复杂的，但OS对此进行了抽象，可以通过系统调用来访问设备。因此OS可以被看成是一个标准库。</p>
<h2 id="os的设计目标"><a class="markdownIt-Anchor" href="#os的设计目标"></a> OS的设计目标</h2>
<ul>
<li>抽象：使系统更易用</li>
<li>高性能</li>
<li>保护：在应用程序之间，以及应用程序和系统之间提供保护和隔离</li>
<li>可靠性</li>
<li>节能、安全性、可移动性……</li>
</ul>
<h2 id="os的历史"><a class="markdownIt-Anchor" href="#os的历史"></a> OS的历史</h2>
<ul>
<li>早期操作系统（大型机批处理系统）：基本只是标准库，需要操作员参与管理</li>
<li>中期操作系统：提供了文件系统和保护机制，系统调用和硬件特权级的概念出现了</li>
<li>多道程序系统：内存保护和并发的概念</li>
<li>现代操作系统：……</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-01-summary-a-dialogue-on-the-book/">
              
                  OSTEP第01章总结：A Dialogue on the Book
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这是全书开头的第一章，奠定了全书逗比的基调（雾）。这一章主要只是用来扯皮的，真正的介绍性内容在下一章。</p>
<p>本章讲述了一位叫“Professor”的教授和一位叫“Student”的学生的故事。</p>
<p>Professor指出，“Three Easy Pieces”这个题目是为了致敬费曼的“Six Easy Pieces”这本书。因为操作系统只有物理学的一半那么难，所以核心概念也只有物理学的一半那么多。（真的吗？）</p>
<p>我们将要讲授的3个核心概念是：虚拟化（virtualization），并发（concurrency）和持久化（persistence）。</p>
<p>我们将要学到OS如何工作，具体内容包括：</p>
<ul>
<li>OS如何决定下一个将在CPU上运行的是什么程序</li>
<li>如何在虚拟内存系统中处理内存过载</li>
<li>如何管理磁盘上的信息</li>
<li>如何建立一个可靠的分布式系统</li>
<li>等等</li>
</ul>
<p>Professor对学习者的建议：</p>
<ul>
<li>上课，听讲</li>
<li>每周结束时读这本书</li>
<li>考试之前再读一遍书（虽然可能我没有那么多的时间，我就没有）</li>
<li>做教授留的作业和项目</li>
</ul>
<p>Professor：“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣。”（荀子《儒效篇》）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/archives/2018/07/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  2 / 2
              </p>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->




        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
