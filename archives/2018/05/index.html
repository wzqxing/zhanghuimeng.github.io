<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2018/5 | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
	
    <script>
        window.subData= { title:'year : 2018.5'}
    </script>




  <section class="post-list">
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/like-as-the-waves-make-towards-the-pebbled-shore-by-w-shakespeare/">
              
                  《英诗金库》I-30：Like as the waves make towards the pebbled shore, by W. Shakespeare
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Revolutions（循环）<br>
作者：William Shakespeare（威廉·莎士比亚）<br>
出版年代：1609<br>
编注：此诗系莎氏十四行诗第六〇首。</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Like as the waves make towards the pebbled shore,<br>
So do our minutes hasten to their end;<br>
Each changing place with that which goes before,<br>
In sequent<a href="#note1" id="note1ref"><sup>1</sup></a> toil all forwars do contend.</p>
<p>Nativity, once in the main of light,<br>
Crawls to maturity, wherewith being crown’d,<br>
Crooked eclipses 'gainst his glory fight,<br>
And Time that gave doth now his gift confound.</p>
<p>Time doth transfix the flourish<a href="#note2" id="note2ref"><sup>2</sup></a> set on youth,<br>
And delves the parellels in beauty’s brow;<br>
Feeds on the rarities of nature’s truth,<br>
And nothing stands but for his scythe to mow:</p>
<p>And yet, to times in hope<a href="#note3" id="note3ref"><sup>3</sup></a>, my verse shall stand<br>
Praising thy worth, despite his cruel hand.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="梁宗岱-译"><a class="markdownIt-Anchor" href="#梁宗岱-译"></a> 梁宗岱 译</h3>
<p>象波浪滔滔不息地滚向沙滩：<br>
我们的光阴息息奔赴着终点；<br>
后浪和前浪不断地循环替换，<br>
前推后拥，一个个在奋勇争先。</p>
<p>生辰，一度涌现于光明的金海，<br>
爬行到壮年，然后，既登上极顶，<br>
凶冥的日蚀便遮没它的光彩，<br>
时光又撕毁了它从前的赠品。</p>
<p>时光戳破了青春颊上的光艳，<br>
在美的前额挖下深陷的战壕，<br>
自然的至珍都被它肆意狂啖，<br>
一切挺立的都难逃它的镰刀：</p>
<p>可是我的诗未来将屹立千古，<br>
歌颂你的美德，不管它多残酷！</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>这又是莎士比亚的常见题材了。人生匆匆流逝，一切美好的事物都会被带走，所以不知道人生的意义在何处。但是歌颂美好事物的诗是永存的。这句话听起来很像陈词滥调，但我现在觉得莎士比亚可能真是这么想的了。</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>sequent</em>: ‘following one another.’ （接连发生的。）<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>transfix the flourish</em>: ‘pierce through the gloss.’（戳穿了光彩。）<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>times in hope</em>: ‘ages yet to come.’（尚未来临的日子。）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/W-Shakespeare/"><i class="fas fa-hashtag fa-fw"></i>W.Shakespeare</a>
                
                    <a href="/tags/Sonnet/"><i class="fas fa-hashtag fa-fw"></i>Sonnet</a>
                
                    <a href="/tags/梁宗岱/"><i class="fas fa-hashtag fa-fw"></i>梁宗岱</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/farewell-thou-art-too-dear-for-my-possessing-by-w-shakespeare/">
              
                  《英诗金库》I-31：Farewell! thou art too dear for my possessing, by W. Shakespeare
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-31
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="作品基本信息"><a class="markdownIt-Anchor" href="#作品基本信息"></a> 作品基本信息</h2>
<p>作品名称：Farewell! thou art too dear for my possessing<br>
作者：William Shakespeare（威廉·莎士比亚）<br>
出版年代：1609<br>
编注：此诗系莎氏十四行诗第八七首。译者原有这样的译解：“诗人向爱友告别，并且撤销了他们以前因错误而订的盟约，但诗人似乎仍希望能从这种完全的解约而引起爱友的回心转意。”</p>
<h2 id="作品原文"><a class="markdownIt-Anchor" href="#作品原文"></a> 作品原文</h2>
<p>Farewell! thou art too dear for my possessing,<br>
And like enough thou know’st thy estimate:<br>
The charter<a href="#note1" id="note1ref"><sup>1</sup></a> of thy worth gives thee releasing;<br>
My bonds in thee are all determinate.</p>
<p>For how do I hold thee but thy granting?<br>
And for that riches where is my deserving?<br>
The cause of this fair gift in me is wanting,<br>
And so my patent<a href="#note2" id="note2ref"><sup>2</sup></a> back again is swerving.</p>
<p>Thyself thou gav’st, thy own worth then not knowing,<br>
Or me, to whom thou gav’st it, else mistaking;<br>
So thy great gift, upon misprision growing<a href="#note3" id="note3ref"><sup>3</sup></a>,<br>
Comes home again, on better judgement making.</p>
<p>Thus have I had thee as a dream doth flatter;<br>
In sleep, a king; but waking, no such matter.</p>
<h2 id="译文"><a class="markdownIt-Anchor" href="#译文"></a> 译文</h2>
<h3 id="屠岸-译"><a class="markdownIt-Anchor" href="#屠岸-译"></a> 屠岸 译</h3>
<p>再会！你太贵重了，我没法保有你，<br>
你也多半明白你自己的价值：<br>
你的才德给予你自由的权利；<br>
我跟你订的盟约就到此为止。</p>
<p>你不答应，我怎能把你占有？<br>
对于这样的福气，我哪儿相配？<br>
我没有接受这美好礼物的理由，<br>
给我的特许证因而就掉头而归。</p>
<p>你当时不知道自己的身价有多大，<br>
或者是把我看错了，才给我深情；<br>
所以，你这份厚礼，送错了人家，<br>
终于回家了，算得是明智的决定。</p>
<p>我曾经有过你，象一场阿谀的迷梦，<br>
我在那梦里称了王，醒来一场空。</p>
<h2 id="我的感想"><a class="markdownIt-Anchor" href="#我的感想"></a> 我的感想</h2>
<p>真的好惨。就现代的想法来看，那就是恋爱双方中一方前进得太快了，另一方跟不上；或者说，一方本来是年轻貌美，善解人意的，另一方配不上，却因为种种原因还是在一起了。不相配的人是不可能长久下去的。当然，这样也实在是太自卑了。</p>
<p>当然曾经也是很感动的。把这么优秀的自己送给了我，真是一份重礼啊。总之这首诗苦乐参半，其实也没有想象中那么惨。</p>
<p>最后两句写得很顺耳，节奏很棒。</p>
<p>刚才阅读了一些其他的解读。不过恕我直言，这里的爱人恐怕还是那位可爱的年轻男性。</p>
<p>TODO（我以前写的都是什么破烂解析？）</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2>
<p><a id="note1" href="#note1ref"><sup>1</sup></a><em>charter</em>: properly a written grant of rights by the Sovereign; here his lady’s worth had given her such rights. （实际上是统治者对权利作出的书面保证；此处，这位夫人的价值给了她这样的权力。其实我也没看懂这个注解。）<br>
<a id="note2" href="#note2ref"><sup>2</sup></a><em>patent</em>: a right similarly granted to the exclusive enjoyment of some privilege.<br>
<a id="note3" href="#note3ref"><sup>3</sup></a><em>upon misprision growing</em>: ‘being based upon a misconception of your own value.’ The word is derived from the verb to misprize, and must not be confounded with the legal term misprision (akin to the French méprendre), meaning a wrongful act or omission.</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/GoldenTreasury/"><i class="fas fa-hashtag fa-fw"></i>GoldenTreasury</a>
                
                    <a href="/tags/W-Shakespeare/"><i class="fas fa-hashtag fa-fw"></i>W.Shakespeare</a>
                
                    <a href="/tags/屠岸/"><i class="fas fa-hashtag fa-fw"></i>屠岸</a>
                
                    <a href="/tags/Sonnet/"><i class="fas fa-hashtag fa-fw"></i>Sonnet</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/wir-sind-helden-song-translation-1-guten-tag-die-konkurrenz/">
              
                  Wir Sind Helden歌词翻译（1）：Guten Tag &amp; Die Konkurrenz
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-26
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>好不容易熬过了操作系统期末考试（虽然考得真的很糟，因为忙于维护博客而忽略了一些重要的知识点，比如RAID之类的，不过毕竟这是自己选择的结果，也没有啥好说的），决定干点轻松愉快的事情——翻译德语歌词！</p>
<p><a href="https://en.wikipedia.org/wiki/Wir_sind_Helden" target="_blank" rel="noopener">Wir Sind Helden</a>是一支我相当喜欢的德国乐队。他们已经在2012年宣布无限期停止活动了，但是这并不影响我继续听他们的歌。他们的<a href="https://en.wikipedia.org/wiki/Judith_Holofernes" target="_blank" rel="noopener">主唱</a>声音很萌（特别像小姑娘，好萌……），歌曲风格轻快活泼，歌词内容经常令人莫名其妙，和曲风形成了鲜明的对比。</p>
<p>我的德语水平并不怎么样，所以这些歌词都是对着德语原文和英语翻译转译过来的。虽然我希望自己未来还能有时间好好学习德语，但我觉得制约我的翻译的瓶颈实际上是中文水平。</p>
<h2 id="die-konkurrenz"><a class="markdownIt-Anchor" href="#die-konkurrenz"></a> Die Konkurrenz</h2>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=19824455&auto=1&height=66"></iframe>
<p>这首歌的歌词是2017年3月翻译的，稍微有点久远了。谷歌了一下，当时似乎参考了<a href="http://lyrics.wikia.com/wiki/Wir_Sind_Helden:Die_Konkurrenz/en" target="_blank" rel="noopener">Wir Sind Helden:Die Konkurrenz/en Lyrics</a>的歌词和翻译。</p>
<table>
<thead>
<tr>
<th>歌词</th>
<th>翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>Du fährst dein Rad am Straßenrand</td>
<td>你在大马路上骑着自行车</td>
</tr>
<tr>
<td>begehrst nicht andrer Weib noch Land</td>
<td>你既不要别人的女人也不要土地</td>
</tr>
<tr>
<td>Begehren ist dir einerlei</td>
<td>欲望对你来说毫无意义</td>
</tr>
<tr>
<td>Du pfeifst und singst und fühlst dich frei</td>
<td>你吹着口哨唱着歌，感到无比自由</td>
</tr>
<tr>
<td>Du pfeifst und singst und fühlst dich frei</td>
<td>你吹着口哨唱着歌，感到无比自由</td>
</tr>
<tr>
<td>da zieht wer links an dir vorbei!</td>
<td>突然有人从左边超了你的车</td>
</tr>
<tr>
<td>Vorbeiziehen ist mir einerlei</td>
<td>“我才不在乎是不是被人超车！”</td>
</tr>
<tr>
<td>sagst du und wirst ganz blass dabei</td>
<td>你这样说的时候脸色却变白了</td>
</tr>
<tr>
<td>Die Konkurrenz schläft nicht (×4)</td>
<td>竞争永不息！(×4)</td>
</tr>
<tr>
<td>Sag’s mir, Hippiekind!</td>
<td>告诉我，嬉皮小孩</td>
</tr>
<tr>
<td>Jetzt stehst du auf dem Dach der Welt</td>
<td>现在你正站在世界之巅</td>
</tr>
<tr>
<td>Die Welt hält still und dir gefällt sie</td>
<td>你喜欢这世界停滞不前</td>
</tr>
<tr>
<td>Du atmest tief und fühlst dich hier</td>
<td>你深吸一口气，感觉在此处</td>
</tr>
<tr>
<td>Du fühlst dich eins mit Welt und dir</td>
<td>你自己和世界合为一体</td>
</tr>
<tr>
<td>Du fühlst dich eins mit Welt und hier</td>
<td>你感到和此处的世界合为一体</td>
</tr>
<tr>
<td>Steht plötzlich einer neben dir!</td>
<td>突然有人站到了你旁边</td>
</tr>
<tr>
<td>Bist eins mit dir und mit der Welt</td>
<td>你本来认为你和世界合为一体</td>
</tr>
<tr>
<td>Bis einer sich für einser hält</td>
<td>直到有人硬塞到你们中间</td>
</tr>
<tr>
<td>Die Konkurrenz schläft nicht (×4)</td>
<td>竞争永不息！(×4)</td>
</tr>
<tr>
<td>Sag’s mir, kleiner Punk!</td>
<td>告诉我，小朋克</td>
</tr>
<tr>
<td>Da zieht wer links an dir vorbei</td>
<td>有人从左边超了你的车</td>
</tr>
<tr>
<td>Sag, was macht das mit dir?</td>
<td>（告诉我，你感觉怎么样？）</td>
</tr>
<tr>
<td>Dem ist dein Pfeifen einerlei</td>
<td>没人真在乎你吹的口哨</td>
</tr>
<tr>
<td>Sag was macht das mit dir?</td>
<td>（告诉我，你感觉怎么样？）</td>
</tr>
<tr>
<td>Da steht ein andrer neben dir und fühlt sich eins</td>
<td>有人站到了你旁边，他感到和世界合为一体</td>
</tr>
<tr>
<td>Mit dem was deins war</td>
<td>可世界曾是我的</td>
</tr>
<tr>
<td>Nicht seins</td>
<td>不是他的</td>
</tr>
<tr>
<td>Sag, was macht die Konkurrenz?</td>
<td>告诉我，竞争都做了些什么</td>
</tr>
<tr>
<td>Du tust die Arbeit Hand in Hand</td>
<td>你们手拉手地干着活</td>
</tr>
<tr>
<td>Seit’ an Seite bestellst das Land</td>
<td>你们肩并肩地犁着地</td>
</tr>
<tr>
<td>Am Morgen geht’s einig und früh aus der Falle</td>
<td>你们早晨起床起得又快又早</td>
</tr>
<tr>
<td>Und ihr singt: Alle für einen! Einer für Alle</td>
<td>你们唱道：“人人为我，我为人人！”</td>
</tr>
<tr>
<td>Ihr singt: Alle für einen! Einer für Alle</td>
<td>你们唱道：“人人为我，我为人人！”</td>
</tr>
<tr>
<td>und dann kommt einer und macht alle Anderen alle</td>
<td>然后有人夺去所有收获，其他人空手而归</td>
</tr>
<tr>
<td>Am morgen geht’s eilig und früh aus der Falle</td>
<td>你早晨起床起得又快又早</td>
</tr>
<tr>
<td>Und du singst: jetzt bin ich der eine und ihr Anderen seid Alle</td>
<td>你唱道：“人人为的是我，我却不必为人人！”</td>
</tr>
<tr>
<td>Die Konkurrenz, sie schläft nicht</td>
<td>竞争永不息！</td>
</tr>
<tr>
<td>Die Konkurrenz schläft nicht</td>
<td>竞争永不息！</td>
</tr>
<tr>
<td>Die Konkurrenz, sie schläft nicht</td>
<td>竞争它永不停息！</td>
</tr>
</tbody>
</table>
<p>说实话，我对这个翻译还挺满意的，唯一觉得自己傻的一点是，在网易云音乐里上传的版本里，把那些德语歌词中没有体现出来的语气词也给照样翻译出来了，这确实有点尴尬。</p>
<p>一年过去了，现在看到歌词里的“人人为我，我为人人！”，以及“从左边”超车，总觉得有点什么政治隐喻在里面。</p>
<h2 id="guten-tag"><a class="markdownIt-Anchor" href="#guten-tag"></a> Guten Tag</h2>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=19824269&auto=1&height=66"></iframe>
<p>下面这个歌词只是预览版，还没有最后上传，还需要一些修改。</p>
<table>
<thead>
<tr>
<th>歌词</th>
<th>翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>Meine Stimme gegen Dein Mobiltelefon</td>
<td>用我的声音换你们的移动电话</td>
</tr>
<tr>
<td>Meine Fäuste gegen Eure Nagelpflegelotion</td>
<td>用我的拳头换你们的美甲乳液</td>
</tr>
<tr>
<td>Meine Zähne gegen die von Doktor Best und seinem Sohn</td>
<td>用我的牙齿换贝斯特博士的牙齿护理产品</td>
</tr>
<tr>
<td>Meine Seele gegen Eure sanfte Epilation</td>
<td>用我的灵魂换你们的无痛脱毛药水</td>
</tr>
<tr>
<td>Es war im Ausverkauf im Angebot die Sonderaktion</td>
<td>当时所有的产品都在促销</td>
</tr>
<tr>
<td>Tausche blödes altes Leben gegen neue Version</td>
<td>我把愚蠢的旧生活升级成了新版本</td>
</tr>
<tr>
<td>Ich hatte es kaum zu Hause ausprobiert da wusste ich schon</td>
<td>结果在家试了几种东西之后我就发现</td>
</tr>
<tr>
<td>an dem Produkt ist was kaputt - das ist die Reklamation</td>
<td>你们的产品全都是坏的！我要投诉！</td>
</tr>
<tr>
<td>Ich will</td>
<td>我想</td>
</tr>
<tr>
<td>Ich tausch nicht mehr ich will mein Leben zurück (×3)</td>
<td>我不要再交换了！我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag, ich will mein Leben zurück</td>
<td>你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag ich gebe zu ich war am Anfang entzückt</td>
<td>你好，我承认我开始时被吸引了</td>
</tr>
<tr>
<td>aber euer Leben zwickt und drückt nur dann nicht wenn man sich bückt -</td>
<td>可这种扭曲的生活不断逼迫着我屈服于它！</td>
</tr>
<tr>
<td>Guten Tag</td>
<td>你好</td>
</tr>
<tr>
<td>Meine Stimme gegen die der ganzen Talkshownation</td>
<td>用我的声音换整个国家的脱口秀</td>
</tr>
<tr>
<td>Meine Fäuste für ein müdes Halleluja und Bohnen</td>
<td>用我的拳头换疲惫的哈利路亚与豆子</td>
</tr>
<tr>
<td>Meine Zähne gegen Eure zahme Revolution</td>
<td>用我的牙齿换你们的“驯服革命”</td>
</tr>
<tr>
<td>Visionen gegen die totale Television</td>
<td>用我的眼睛换一台电视机</td>
</tr>
<tr>
<td>Es war im Ausverkauf im Angebot die Sonderaktion</td>
<td>当时所有的产品都在促销</td>
</tr>
<tr>
<td>Tausche blödes altes Leben gegen neue Version</td>
<td>我把愚蠢的旧生活升级成了新版本</td>
</tr>
<tr>
<td>Ich hatte es kaum zu Hause ausprobiert da wusste ich schon</td>
<td>结果在家试了几种东西之后我就发现</td>
</tr>
<tr>
<td>an dem Produkt ist was kaputt - das ist die Reklamation</td>
<td>你们的产品全都是坏的！我要投诉！</td>
</tr>
<tr>
<td>Ich will</td>
<td>我想</td>
</tr>
<tr>
<td>Ich tausch nicht mehr ich will mein Leben zurück (×3)</td>
<td>我不要再交换了！我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag, ich will mein Leben zurück</td>
<td>你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag ich gebe zu ich war am Anfang entzückt</td>
<td>你好，我承认我开始时被吸引了</td>
</tr>
<tr>
<td>aber euer Leben zwickt und drückt nur dann nicht wenn man sich bückt -</td>
<td>可这种扭曲的生活不断逼迫着我屈服于它！</td>
</tr>
<tr>
<td>Guten Tag</td>
<td>你好</td>
</tr>
<tr>
<td>Mobiltelefon</td>
<td>移动电话</td>
</tr>
<tr>
<td>Von Doktor Best und seinem Sohn</td>
<td>贝斯特博士的牙齿护理套装</td>
</tr>
<tr>
<td>Sonderaktion</td>
<td>促销</td>
</tr>
<tr>
<td>Das ist die Reklamation</td>
<td>这是投诉！</td>
</tr>
<tr>
<td>Der ganzen Talkshownation</td>
<td>充满脱口秀的国家</td>
</tr>
<tr>
<td>Revolution</td>
<td>革命</td>
</tr>
<tr>
<td>Visionen gegen die totale Television</td>
<td>用眼睛换一台电视机</td>
</tr>
<tr>
<td>Es war im Ausverkauf im Angebot die Sonderaktion</td>
<td>当时所有的产品都在促销</td>
</tr>
<tr>
<td>Tausche blödes altes Leben gegen neue Version</td>
<td>我把愚蠢的旧生活升级成了新版本</td>
</tr>
<tr>
<td>Ich hatte es kaum zu Hause ausprobiert da wusste ich schon</td>
<td>结果在家试了几种东西之后我就发现</td>
</tr>
<tr>
<td>an dem Produkt ist was kaputt - das ist die Reklamation</td>
<td>你们的产品全都是坏的！我要投诉！</td>
</tr>
<tr>
<td>Ich will</td>
<td>我想</td>
</tr>
<tr>
<td>Ich tausch nicht mehr ich will mein Leben zurück (×7)</td>
<td>我不要再交换了！我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag, ich will mein Leben zurück</td>
<td>你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>(Ich tausch nicht mehr)Guten Tag, guten Tag, ich will mein Leben zurück</td>
<td>你好，你好，我要回到原来的生活！</td>
</tr>
<tr>
<td>Guten Tag ich gebe zu ich war am Anfang entzückt</td>
<td>你好，我承认我开始时被吸引了</td>
</tr>
<tr>
<td>aber euer Leben zwickt und drückt nur dann nicht wenn man sich bückt -</td>
<td>可这种扭曲的生活不断逼迫着我屈服于它！</td>
</tr>
<tr>
<td>Guten Tag (×4)</td>
<td>你好</td>
</tr>
<tr>
<td>Guten</td>
<td>你</td>
</tr>
<tr>
<td>Tag</td>
<td>好</td>
</tr>
</tbody>
</table>
<p>一些说明：</p>
<ol>
<li><a href="https://de.wikipedia.org/wiki/Dr._Best" target="_blank" rel="noopener">Doktor Best und seinem Sohn</a>似乎是德国一个有名的牙齿护理产品，现在下属于葛兰素史克。于是我翻译成“贝斯特博士”了。</li>
<li>我也不太清楚“Halleluja und Bohnen”到底应该是什么意思。可能和<a href="https://de.wikipedia.org/wiki/Blaue_Bohnen_f%C3%BCr_ein_Halleluja" target="_blank" rel="noopener">这部电影</a>有关。</li>
<li><a href="https://www.amazon.com/Die-zahme-Revolution-davon-German/dp/3800036797" target="_blank" rel="noopener">zahme Revolution</a>是一本书，作者是<a href="https://de.wikipedia.org/wiki/Paulus_Ebner" target="_blank" rel="noopener">Paulus Ebner</a>，但我不太明白这本书说的是什么，以及在这里引用它的意义……</li>
</ol>
<p>总的来说，这首歌的语气好像一个人在给某家“公司”打电话投诉，声称现代消费主义带来的生活虽然开始时令人眼花缭乱，但实质上是令人痛苦而迷茫的，因此他要求退货，换回到原来的旧生活。想到这首歌是2003年发布的，不由得有种恍如隔世之感。</p>
<p>可是，还是回不去了啊。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/Translation/"><i class="fas fa-hashtag fa-fw"></i>Translation</a>
                
                    <a href="/tags/Lyric/"><i class="fas fa-hashtag fa-fw"></i>Lyric</a>
                
                    <a href="/tags/artist-Wir-Sind-Helden/"><i class="fas fa-hashtag fa-fw"></i>artist:Wir Sind Helden</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-14-summary/">
              
                  《操作系统》第14讲：“实验5-用户线程管理”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-25
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>TODO</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-quiz.md" target="_blank" rel="noopener">lab5 用户进程 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-spoc-discussion.md" target="_blank" rel="noopener">lab5 spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>下列叙述中正确的是()</strong></p>
<ul>
<li>lab5建立了用户进程，且0~3GB都是用户可访问空间，用户进程可进行正常读写</li>
<li>lab5建立了用户进程，且3GB~4GB都是内核可访问空间，内核可进行正常读写</li>
<li><strong>lab5中的第一个用户进程是内核创建的。</strong></li>
<li><strong>lab5中的用户进程可通过fork创建新的用户进程。</strong></li>
</ul>
<p>lab5中建立了用户进程这一点没啥问题。用户和内核可访问的空间这点有问题。简单来说，内核虚拟内存空间处于0xC0000000<sub>0xF8000000位置（KERNBASE</sub>KERNTOP），用户进程可访问的虚拟内存空间位于0x0080000<sub>-0xB0000000位置（UTEXT</sub>USERTOP）。</p>
<blockquote>
<p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（ 即应用程序的执行代码） 和数据（ 即应用程序的全局变量等） 放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p>
</blockquote>
<hr>
<p><strong>lab5通过<code>do_execve</code>函数执行新的程序，为此需要完成（）</strong></p>
<ul>
<li><strong>更新用户进程的context</strong></li>
<li><strong>更新用户进程的代码内容</strong></li>
<li><strong>更新用户进程的数据内容</strong></li>
<li><strong>更新用户进程的页表基址</strong></li>
</ul>
<p>Lab5中的<code>do_execve</code>函数的主要功能就是，放弃当前程序的一切内存空间等资源，将新的程序填充到自己里面。所以显然上述内容都要更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// do_execve - call exit_mmap(mm)&amp;put_pgdir(mm) to reclaim memory space of current process</span><br><span class="line">//           - call load_icode to setup new memory space accroding binary prog.</span><br><span class="line">int</span><br><span class="line">do_execve(const char *name, size_t len, unsigned char *binary, size_t size) &#123;</span><br><span class="line">    struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char local_name[PROC_NAME_LEN + 1];</span><br><span class="line">    memset(local_name, 0, sizeof(local_name));</span><br><span class="line">    memcpy(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    if (mm != NULL) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        if (mm_count_dec(mm) == 0) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int ret;</span><br><span class="line">    if ((ret = load_icode(binary, size)) != 0) &#123;</span><br><span class="line">        goto execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(&quot;already exit: %e.\n&quot;, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ucore docs中指出，此函数的主要工作流程如下：</p>
<blockquote>
<p>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。<br>
接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</p>
</blockquote>
<hr>
<p><strong>lab5通过<code>do_icode</code>函数执行新的程序，为此需要完成（）</strong></p>
<ul>
<li><strong>设置用户堆栈</strong></li>
<li><strong>修改页表</strong></li>
<li><strong>根据ELF执行文件的格式描述分配内存并填写内容</strong></li>
<li><strong>设置用户态的EFLAG寄存器不可屏蔽中断</strong></li>
</ul>
<p>ucore docs中给出的函数工作流程：</p>
<blockquote>
<ol>
<li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
</ol>
</blockquote>
<ol start="2">
<li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（ boot_pgdir所指） 的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等） 的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li>
</ol>
<p>其中设置中断帧这一步是Lab5的练习1。</p>
<hr>
<p><strong>关于进程管理的COW(Copy On Write)机制叙述正确的是（）</strong></p>
<ul>
<li>父进程创建子进程需要复制父进程的内存空间</li>
<li>父进程创建子进程需要给子进程分配内核堆栈</li>
<li>父进程创建子进程需要给子进程分配用户堆栈</li>
<li><strong>父进程创建子进程需要创建子进程的页表,但不复制父进程内存空间</strong></li>
</ul>
<p>总之不需要复制也不需要分配，只是创建一个新的页表，然后和父进程页表指向相同位置。需要进行写时就新创建一页。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>第一个用户进程创建有什么特殊的？</strong></p>
<blockquote>
<p>用户态代码段的初始化</p>
</blockquote>
<p>好吧，答案是这么说的，但是我并不认同……总之，本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行<br>
码覆盖到initproc的用户虚拟内存空间来创建的。具体的大概方法是调用<code>kernel_execve()</code>函数，触发<code>SYS_exec</code>系统中断，然后继续调用<code>do_execve()</code>和<code>load_icode()</code>函数完成这一过程。其他用户进程是用户进程通过<code>SYS_fork</code>系统调用创建的（大概）。</p>
<hr>
<p><strong>系统调用的参数传递过程？</strong></p>
<p>参见：用户态函数syscall()中的汇编代码。下面的代码摘自<code>user/libs/syscall.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">syscall(<span class="keyword">int</span> num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %1;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"a"</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"d"</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"c"</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"b"</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"D"</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"S"</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，参数是这样传递的：</p>
<ul>
<li>触发INT 0x80中断（T_SYSCALL）</li>
<li>eax中存放系统调用号</li>
<li>edx、ecx、ebx、edi、esi中按照顺序存放前五个参数</li>
<li>返回值存放在eax中</li>
</ul>
<p>令人感到奇怪的是，这与Linux系统在x86架构下一般的习惯并不相符。（<a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6" target="_blank" rel="noopener">https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6</a>，其中给出的顺序是ebx、ecx、edx、esi、edi）。不过这并不是很重要，总之这个顺序与<code>kern/syscall/syscall.c</code>中对应的代码是相符的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void) &#123;</span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    uint32_t arg[5];</span><br><span class="line">    int num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        if (syscalls[num] != NULL) &#123;</span><br><span class="line">            arg[0] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[1] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[2] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[3] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[4] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ref: <a href="https://www.ibm.com/developerworks/library/l-ia/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/l-ia/index.html</a></p>
<hr>
<p><strong>getpid的返回值放在什么地方了？</strong></p>
<blockquote>
<p>参见：用户态函数syscall()中的汇编代码</p>
</blockquote>
<p>这个问题很平凡，只是放在eax里面了而已。（又不是fork……）</p>
<hr>
<p><strong>ucore的内存布局中，页表、用户栈、内核栈在逻辑地址空间中的位置？</strong></p>
<p>参见<code>kern/mm/memlayout.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define VPT 0xFAC00000</span><br><span class="line"></span><br><span class="line">#define KSTACKPAGE 2 // # of pages in kernel stack</span><br><span class="line"></span><br><span class="line">#define KSTACKSIZE (KSTACKPAGE * PGSIZE) // sizeof kernel stack</span><br><span class="line"></span><br><span class="line">#define USERTOP 0xB0000000</span><br><span class="line"></span><br><span class="line">#define USTACKTOP USERTOP</span><br><span class="line"></span><br><span class="line">#define USTACKPAGE 256 // # of pages in user stack</span><br><span class="line"></span><br><span class="line">#define USTACKSIZE (USTACKPAGE * PGSIZE) // sizeof user stack</span><br></pre></td></tr></table></figure>
<p>事实上，页表位于内核虚拟空间0xFAC00000<sub>0xFB000000位置，用户栈位于用户虚拟空间?</sub>0xB0000000位置（因为栈是向下增长的），内核栈位于内核虚拟空间……诶怎么没说内核栈在什么位置？我猜是在~0xF8000000位置吧。</p>
<p>这个字符画的水平十分高超：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * Virtual memory map:                                          Permissions</span><br><span class="line"> *                                                              kernel/user</span><br><span class="line"> *</span><br><span class="line"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |         Empty Memory (*)        |</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            +---------------------------------+ 0xFB000000</span><br><span class="line"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="line"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="line"> *                            |           User stack            |</span><br><span class="line"> *                            +---------------------------------+</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            :                                 :</span><br><span class="line"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line"> *                            :                                 :</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                            |       User Program &amp; Heap       |</span><br><span class="line"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="line"> *                            |    User STAB Data (optional)    |</span><br><span class="line"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.</span><br><span class="line"> *</span><br><span class="line"> * */</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>在do_execve中的的当前进程如何清空地址空间内容的？在什么时候开始使用新加载进程的地址空间？</strong></p>
<blockquote>
<p>清空进程地址空间是在initproc所在进程地址空间<br>
CR3设置成新建好的页表地址后，开始使用新的地址空间</p>
</blockquote>
<p>这个答案简直语无伦次……总之上面已经说过<code>do_execve()</code>函数的流程了。清空地址空间是通过释放<code>mm_struct</code>结构完成的（虽然initproc并不会这么做，因为它直接用的是内核的<code>mm_struct</code>）。至于页表，<code>do_execve()</code>在释放<code>mm_struct</code>之前会先换成内核自己的页表；<code>load_icode()</code>中，设置进程的新<code>mm_struct</code>时会加载新页表（第5步）。</p>
<hr>
<p><strong>新加载进程的第一级页表的建立代码在哪？</strong></p>
<p>在<code>load_icode()</code>的第2步中，调用了<code>setup_pgdir(mm)</code>。</p>
<hr>
<p><strong>do_execve在处理中是如何正确区分出用户进程和线程的？并为此采取了哪些不同的处理？</strong></p>
<p>我猜这道题说的是内核线程吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lcr3(boot_cr3);</span><br><span class="line">    <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">        exit_mmap(mm);</span><br><span class="line">        put_pgdir(mm);</span><br><span class="line">        mm_destroy(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核线程的<code>mm</code>直接借用了内核自己的<code>mm</code>，所以这里处理了这一点。</p>
<hr>
<p><strong>第一个内核线程和第一个用户进程的创建有什么不同？</strong></p>
<ul>
<li>相应线程的内核栈创建时，多了SS和ESP的设置；</li>
<li>用户进程需要创建用户地址空间，并把用户代码复制到用户地址空间；</li>
</ul>
<p>设置ss和esp对应lab5的练习1：在用户进程的内核栈中存放的<code>trapframe</code>中填写对应的寄存器。其次就是要<code>load_icode</code>了，不能直接调用内核中的函数。而且不能和内核共用页表，要新建自己的页表。</p>
<hr>
<p><strong>尝试跟踪分析新创建的用户进程的开始执行过程？</strong></p>
<p>……反正我写的实验报告中是这么说的：</p>
<p><code>load_icode</code>函数成功结束运行后，系统中断返回到<code>exit</code>的第一行代码。<code>exit</code>本身的执行过程在此暂时忽略。</p>
<p><code>exit</code>线程执行结束之后，系统切换到<code>initproc</code>线程，它进行检查并退出。</p>
<p>差不多吧。</p>
<hr>
<p><strong>为什么新进程的内核堆栈可以先于进程地址空间复制进行创建？</strong></p>
<p>内核栈在进程的内核地址空间，而各进程的内核地址空间是共享的。</p>
<hr>
<p><strong>进程复制的代码在哪？复制了哪些内容？</strong></p>
<p>以下代码来自<code>lab5/kern/process/proc.c</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) &#123;</span><br><span class="line">    int ret = -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    //    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">	proc = alloc_proc();</span><br><span class="line">	if (proc == NULL) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto fork_out;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;parent = current;  // 参考了答案</span><br><span class="line">	//    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">	if (setup_kstack(proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto bad_fork_cleanup_proc;</span><br><span class="line">	&#125;</span><br><span class="line">	//    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">	// CLONE_VM表示分享；实际上因为都在内核态所以什么都没做，只是assert NULL了</span><br><span class="line">	if (copy_mm(clone_flags, proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto bad_fork_cleanup_kstack;</span><br><span class="line">	&#125;</span><br><span class="line">	//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">	copy_thread(proc, stack, tf);</span><br><span class="line">	//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">	// 参考了答案：关中断的原因是，进程号要求唯一性，此操作需要为原子操作，防止被打断而重复添加</span><br><span class="line">	// 所以参考答案是很有必要的。但是我认为在实验指导书中也应该说明一下。</span><br><span class="line">	bool intr_flag;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">		proc-&gt;pid = get_pid();</span><br><span class="line">		hash_proc(proc);</span><br><span class="line">		// list_add_before(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">		set_links(proc);</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">	//    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">	wakeup_proc(proc);</span><br><span class="line">	//    7. set ret vaule using child proc&apos;s pid</span><br><span class="line">	ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，以上代码中复制的主要内容是<code>mm_struct</code>内存管理结构（相当于复制了一份虚拟内存及其中的内容）。</p>
<hr>
<p><strong>进程复制过程中有哪些修改？为什么要修改？</strong></p>
<p>参见上一题的代码，需要修改的内容包括：</p>
<ul>
<li>为新进程分配一个新的进程控制块</li>
<li>分配一个新的内核栈</li>
<li>修改内核栈中存储的<code>trapframe</code>的内容</li>
<li>分配一个新的PID</li>
</ul>
<hr>
<p><strong>分析第一个用户进程的创建流程，说明进程切换后执行的第一条是什么。</strong></p>
<p>以下内容摘自ucore docs Lab5：</p>
<blockquote>
<p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的。<br>
initproc的执行主体是<code>init_main</code>函数，这个函数在缺省情况下是执行宏<code>KERNEL_EXECVE(hello)</code>，而这个宏最终会调用<code>kernel_execve</code>函数来执行SYS_exec系统调用。<br>
ucore收到此系统调用后，最终通过<code>do_execve</code>函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
</blockquote>
<ol>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。<br>
load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</li>
<li>调用<code>mm_create</code>函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
<li>调用<code>setup_pgdir</code>来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（<code>boot_pgdir</code>所指）的内容拷贝到此新目录表中，最后让<code>mm-&gt;pgdir</code>指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用<code>mm_map</code>函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等） 的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；<br>
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。</li>
</ol>
<hr>
<p><strong>什么是写时复制？</strong></p>
<blockquote>
<p>写时复制（Copy-on-Write，也缩写为COW），顾名思义，就是在写入时才真正复制一份内存进行修改。COW最早应用在*nix系统中对线程与内存使用的优化，后面广泛的被使用在各种编程语言中，如C++的STL等。在PHP内核中，COW也是主要的内存优化手段。在前面关于变量和内存的讨论中，引用计数对变量的销毁与回收中起着至关重要的标识作用。引用计数存在的意义，就是为了使得COW可以正常运作，从而实现对内存的优化使用。（<a href="https://blog.csdn.net/ghostlv/article/details/51249494" target="_blank" rel="noopener">50-写时复制COW机制</a>）</p>
</blockquote>
<hr>
<p><strong>写时复制的页表在什么时候进行复制？共享地址空间和写时复制有什么不同？</strong></p>
<p>在发生写操作时进行复制。共享地址空间并不在意是否发生写操作……</p>
<hr>
<p><strong>存在有多个（n&gt;2）进程具有父子关系，且采用了COW机制的情况。这个情况与只有父子两个进程的情况相比，在设计COW时，需要注意的新问题是什么？有何解决方案？</strong></p>
<p>大概发生一次写操作可能有多个页表发生修改。</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息和函数调用参数信息，然后在你希望的地方人为触发panic函数，并输出上述信息。</strong></p>
<p>没写。</p>
<hr>
<p><strong>尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围，然后在你希望的地方人为触发panic函数，并输出上述信息。</strong></p>
<p>没写。</p>
<hr>
<p><strong>尝试在进程运行过程中获取内核空间中各进程相同的页表项（代码段）和不同的页表项（内核堆栈）？</strong></p>
<p>没写。。。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-18-summary/">
              
                  《操作系统》第18讲：“信号量与管程”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-25
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<ul>
<li>信号量
<ul>
<li>信号量简介</li>
<li>信号量使用
<ul>
<li>互斥访问</li>
<li>条件同步</li>
</ul>
</li>
</ul>
</li>
<li>管程
<ul>
<li>条件变量</li>
<li>管程的语义</li>
</ul>
</li>
<li>经典问题
<ul>
<li>生产者-消费者问题
<ul>
<li>信号量实现</li>
<li>管程实现</li>
</ul>
</li>
<li>哲学家就餐问题</li>
<li>读者-写者问题</li>
</ul>
</li>
</ul>
<h3 id="信号量semaphore"><a class="markdownIt-Anchor" href="#信号量semaphore"></a> 信号量（Semaphore）</h3>
<p>信号量是操作系统提供的一种协调共享资源访问的方法。它和软件同步的区别是：</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>信号量是由操作系统进行管理的，它的地位高于进程（而非平等协商）</li>
</ul>
<p>信号量由Dijkstra在20世纪60年代提出，目前仍然在OS中被使用。</p>
<h4 id="信号量简介"><a class="markdownIt-Anchor" href="#信号量简介"></a> 信号量简介</h4>
<p>信号是一种抽象数据类型：</p>
<ul>
<li>由一个整型变量（<code>sem</code>）和两个原子操作组成</li>
<li><code>sem</code>：要共享的资源的数目</li>
<li><code>P()</code>操作（Prolaag，尝试减少，请求资源时进行）
<ul>
<li><code>sem-1</code></li>
<li>若<code>sem&lt;0</code>，进入等待，否则继续运行</li>
</ul>
</li>
<li><code>V()</code>操作（Verhoog，增加，释放资源时进行）
<ul>
<li><code>sem+1</code></li>
<li>若<code>sem&lt;=0</code>，则唤醒一个等待进程</li>
</ul>
</li>
</ul>
<p>信号量的一些特点：</p>
<ul>
<li>信号量可以被认为是被保护的整数变量
<ul>
<li>初始化完成后，只能通过P()和V()操作修改</li>
<li>由操作系统保证，PV操作是原子操作</li>
<li>可以保证不受应用进程的干扰</li>
</ul>
</li>
<li>P()操作可能阻塞，但V()操作不会阻塞</li>
<li>通常假定信号量是“公平的”
<ul>
<li>线程不会被无限期阻塞在P()操作（实际系统中有一个最长时限的参数，超时之后错误返回）</li>
<li>假定信号量等待按先进先出排队（但是在实际系统中公平有所偏差）</li>
</ul>
</li>
</ul>
<p>下面给出信号量在原理上的一个实现（之所以是原理上的实现，是因为实际实现时要考虑很多问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">    int sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P() &#123;</span><br><span class="line">    sem--;</span><br><span class="line">    if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    if (sem &gt;= 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量使用"><a class="markdownIt-Anchor" href="#信号量使用"></a> 信号量使用</h4>
<p>信号量一般可分为两类：</p>
<ul>
<li>二进制信号量：资源数目为0或1</li>
<li>资源信号量：资源数目为任何非负值</li>
</ul>
<p>下面讨论两个信号量的使用场景：</p>
<ul>
<li>互斥访问：临界区的互斥访问控制</li>
<li>条件同步：线程间的事件等待</li>
</ul>
<h5 id="互斥访问"><a class="markdownIt-Anchor" href="#互斥访问"></a> 互斥访问</h5>
<p>互斥访问的实现方法非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 每类资源设置一个信号量，其初值为1</span><br><span class="line">mutex = new Semaphore(1);</span><br><span class="line">// 临界区的控制代码如下：</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section;</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure>
<p>在这种情况下，信号量的使用和锁相同。需要注意以下几点：</p>
<ul>
<li>必须成对使用P()操作和V()操作</li>
<li>P()操作保证互斥访问临界资源</li>
<li>V()操作在使用后释放临界资源</li>
<li>PV操作不能次序颠倒、重复或遗漏</li>
</ul>
<h5 id="条件同步"><a class="markdownIt-Anchor" href="#条件同步"></a> 条件同步</h5>
<p>举例：线程A执行完X模块之后，线程B才能执行Y模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 设置一个初值为0的信号量</span><br><span class="line">condition = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">// Thread A</span><br><span class="line">Module X &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">condition.V();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Thread B</span><br><span class="line">...</span><br><span class="line">condition.P();</span><br><span class="line">Module Y &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管程monitor"><a class="markdownIt-Anchor" href="#管程monitor"></a> 管程（Monitor）</h3>
<p>管程是一种用于多线程互斥访问共享资源的程序结构</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复（这是最大的特点）</li>
</ul>
<p>管程的组成：</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>入口队列：每次只能有一个线程进入</li>
<li>0或多个条件变量：管理共享数据的并发访问</li>
</ul>
<p>下面需要介绍一下条件变量了。</p>
<h4 id="条件变量condition-variable"><a class="markdownIt-Anchor" href="#条件变量condition-variable"></a> 条件变量（Condition Variable）</h4>
<p>条件变量是管程内的等待机制</p>
<ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
<li><code>Wait()</code>操作：
<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互斥访问（即允许另外一个线程进入管程）</li>
</ul>
</li>
<li><code>Signal()</code>操作：
<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空，这就相当于是一个空操作</li>
</ul>
</li>
</ul>
<p>条件变量在原理上的实现和信号量有些类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Condition &#123;</span><br><span class="line">    int numWaiting = 0;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Wait(Lock lock) &#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    Add this thread t to q;</span><br><span class="line">    release(lock);</span><br><span class="line">    schedule(); // need mutex</span><br><span class="line">    acquire(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Signal() &#123;</span><br><span class="line">    if (numWaiting &gt; 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t); // need mutex</span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有很多不同的地方，如：</p>
<ul>
<li>对管程的互斥锁的释放和获得</li>
<li>signal和P语义的不同：PV操作必须是成对的，但signal/wait操作完全不需要保证这一点</li>
<li>wait和V语义的不同：V操作后线程可能会继续执行，但wait操作后，线程必然进入等待队列并阻塞</li>
<li>执行signal/wait时，都默认已经获得了互斥锁</li>
</ul>
<h4 id="管程的语义"><a class="markdownIt-Anchor" href="#管程的语义"></a> 管程的语义</h4>
<p>事实上管程一共有三种语义：</p>
<ul>
<li>Mesa语义</li>
<li>Hoare语义</li>
<li>Hansen语义</li>
</ul>
<p>以下内容参考了<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=894" target="_blank" rel="noopener">Piazza上的讨论</a>和<a href="https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html" target="_blank" rel="noopener">CMU的课件</a>。</p>
<p>考虑如下情况：线程A在条件变量的等待队列中等待资源，此时线程B在该资源（或者说该条件变量）上执行signal操作。</p>
<h5 id="mesa语义"><a class="markdownIt-Anchor" href="#mesa语义"></a> Mesa语义</h5>
<ul>
<li>线程B执行signal之后，不会立刻退出管程，而是执行到lock.release()之后才进入就绪态</li>
<li>线程A会被移动到入口等待队列中</li>
<li>在wait后被唤醒的进程不一定会被立刻调度，因此需要用<code>while</code>来检查条件</li>
<li>大部分实际实现的管程采用的是这一语义</li>
</ul>
<p><img src="monitor_mesa.jpg" alt="Mesa语义下管程的执行过程"></p>
<h5 id="hoare语义"><a class="markdownIt-Anchor" href="#hoare语义"></a> Hoare语义</h5>
<ul>
<li>线程B执行signal之后，迅速唤醒等待中的线程A，自己进入signal队列中（这个队列是此语义特有的）</li>
<li>每次有线程退出时，先到signal队列中调度线程，如果signal队列空，才到入口等待队列调度线程</li>
<li>实际实现中一般不采用，因为需要多一个队列，代价增大了</li>
</ul>
<p><img src="monitor_hoare.jpg" alt="Hoare语义下管程的执行过程"></p>
<h5 id="brinch-hanson语义"><a class="markdownIt-Anchor" href="#brinch-hanson语义"></a> Brinch Hanson语义</h5>
<ul>
<li>线程B退出的同时才执行signal操作</li>
</ul>
<p><img src="monitor_bh.jpg" alt="Brinch Hanson语义下管程的执行过程"></p>
<h3 id="经典问题"><a class="markdownIt-Anchor" href="#经典问题"></a> 经典问题</h3>
<h4 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h4>
<p>有界缓冲区的生产者-消费者问题描述：</p>
<ul>
<li>一个或多个生产者在生成数据后放在一个缓冲区里</li>
<li>单个消费者从缓冲区取出数据处理</li>
<li>任何时候只能有一个生产者或消费者可访问缓冲区</li>
</ul>
<h5 id="信号量实现"><a class="markdownIt-Anchor" href="#信号量实现"></a> 信号量实现</h5>
<p>问题分析：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区，这是临界区（互斥访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<p>用信号量描述每个约束：</p>
<ul>
<li>二进制信号量<code>mutex</code>：互斥</li>
<li>资源信号量<code>fullBuffers</code>：缓冲区为满（信号量的值表示缓冲区中数据的个数）</li>
<li>资源信号量<code>emptyBuffers</code>：缓冲区为空（信号量的值表示缓冲区中空位的个数）</li>
<li>其中<code>fullBuffers+emptyBuffers=缓冲区大小</code></li>
</ul>
<p>（事实上，OSTEP中讨论了如果只使用一个资源信号量会导致死锁的问题，在此不再赘述了）</p>
<p>下面给出（原理上的）代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">    mutex = new Semaphore(1);</span><br><span class="line">    fullBuffers = new Semaphore(0);</span><br><span class="line">    emptyBuffers = new Semaphore(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">    emptyBuffers-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    fullBuffers-&gt;V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    fullBuffers-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    emptyBuffers-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意P操作之间不能颠倒顺序。V操作不会阻塞，就无所谓了。</p>
<h5 id="管程实现"><a class="markdownIt-Anchor" href="#管程实现"></a> 管程实现</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    int count = 0;</span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    while (count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    while (count == 0)</span><br><span class="line">        notEmpty.Wait(&amp;lock);</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号量和管程实现的对比"><a class="markdownIt-Anchor" href="#信号量和管程实现的对比"></a> 信号量和管程实现的对比</h5>
<p>（以下内容摘自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">Piazza</a>，修正了一些typo）</p>
<p><img src="sem-vs-monitor.png" alt="生产者-消费者问题的两种实现的对比"></p>
<p>如图，信号量中存有<code>int</code>变量<code>sem</code>以及<code>WaitQueue</code>变量<code>q</code>，根据信号量的实现代码（左下角ppt），我们可以得出<code>sem</code>和<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>sem</code>代表【到目前为止，若所有请求该资源的线程都能够获取该资源，那么资源还剩下多少（这里我们假设资源个数可以为负）】；</li>
<li>对<code>sem</code>也可以有另一种理解：当<code>sem</code>非负时，<code>sem</code>代表剩余资源的个数；当<code>sem</code>为负数时，<code>sem</code>的绝对值代表等待队列<code>q</code>的长度。</li>
</ul>
<p>而当我们使用条件变量解决有限资源问题时，我们通常会在条件变量之外，管程之中加入整型变量<code>count</code>（右上角ppt），来帮助条件变量记录当前剩余多少资源（非负）。查看条件变量的实现代码（右下角ppt），我们可以得出条件变量中整型变量<code>numWaiting</code>以及<code>WaitQueue</code>变量<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>numWaiting</code>代表等待队列<code>q</code>的长度（非负）。</li>
</ul>
<p>结合使用信号量以及条件变量解决有限资源问题的实例（左上及右上ppt），以及以上我们对信号量和条件变量的分析，我们可以得出以下结论：</p>
<ul>
<li>在任一状态，信号量中的<code>q</code>和条件变量中的<code>q</code>完全相同；</li>
<li>当<code>sem</code>非负时，含义与管程中的<code>count</code>相同，此时<code>numWaiting</code>为0；</li>
<li>当<code>sem</code>为负数时，<code>sem</code>的绝对值等于<code>numWaiting</code>，此时<code>count</code>为0。</li>
</ul>
<p>在生产者-消费者这个问题实例中：</p>
<ul>
<li>信号量<code>emptyBuffers</code>与条件变量<code>notFull</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>n - count</code>的形式出现；</li>
<li>信号量<code>fullBuffers</code>与条件变量<code>notEmpty</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>count</code>的形式出现；</li>
</ul>
<p>综上所述，两种解决方法是完全等价的，至于为什么用管程实现更加安全方便，个人认为老师在视频中并没有解释得很清楚，和老师讨论后得出结论如下：</p>
<ul>
<li>用信号量的时候（左上角ppt），所有信号量都要自己维护，并配对好PV；</li>
<li>用管程的时候，我们可以理解为<code>BoundedBuffer</code>继承了一个管程类，因此操作系统会给<code>BoundedBuffer</code>中每一个方法自动加上锁（即右上角ppt中的<code>lock-&gt;Acquire()</code>和<code>lock-&gt;Release()</code>函数并不用自己写，是系统加上的），因此更加安全可控，容易查错。</li>
</ul>
<p>但是个人认为使用条件变量也要根据条件配对好Wait和Signal函数，因此不比使用信号量更容易安全，这个问题见仁见智吧，但如果考试时候问到怎么回答大家懂的~</p>
<p>更新：ucore lab7中实现信号量的<code>sem</code>值非负，这样看来ucore中信号量的<code>sem</code>值和条件变量中的<code>count</code>值应该是完全相等的。</p>
<h4 id="哲学家就餐问题"><a class="markdownIt-Anchor" href="#哲学家就餐问题"></a> 哲学家就餐问题</h4>
<p>问题描述：</p>
<ul>
<li>
<p>5个哲学家围绕在一张圆桌周围</p>
</li>
<li>
<p>桌子上有5根筷子（或者说叉子……随便啦）</p>
</li>
<li>
<p>哲学家的动作包括思考和进餐</p>
</li>
<li>
<p>进餐时一个哲学家需要自己两边的两根筷子</p>
</li>
<li>
<p>如何保证哲学家们的动作有序进行，既不发生饥饿也不发生死锁？</p>
</li>
<li>
<p>方案1：</p>
<ul>
<li>每个筷子用一个信号量表示，sem=1</li>
<li>哲学家先拿第一根筷子，再拿第二根筷子，然后吃，最后放回两根筷子</li>
<li>多数情况下这一算法可行；但极端情况下会出现死锁，比如所有哲学家同时拿左边的筷子</li>
</ul>
</li>
<li>
<p>方案2：</p>
<ul>
<li>除了每根筷子的信号量之外，再加上一个互斥信号量，同时只能有一个哲学家就餐</li>
<li>能够保证顺序吃饭，但是浪费了资源和时间</li>
</ul>
</li>
<li>
<p>方案3：</p>
<ul>
<li>和方案1一样，使用5个信号量表示筷子</li>
<li>哲学家根据编号不同，拿取筷子的顺序不同</li>
<li>此时没有死锁，且允许两个人同时就餐</li>
</ul>
</li>
</ul>
<h5 id="信号量实现-2"><a class="markdownIt-Anchor" href="#信号量实现-2"></a> 信号量实现</h5>
<p>这一实现和ucore lab中给出的使用信号量的实现不太一样，而是参考了OSTEP中的做法（更准确地说是Dijkstra本人的做法）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialization</span></span><br><span class="line">Semaphore forks[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    forks[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper functions</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> (p + <span class="number">1</span>) % <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Philosopher</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch between thinking and eating</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="comment">// get forks</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">4</span>) &#123;  <span class="comment">// break dependency</span></span><br><span class="line">            forks[right(x)].P();</span><br><span class="line">            forks[left(x)].P();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            forks[left(x)].P();</span><br><span class="line">            forks[right(x)].P();</span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line">        <span class="comment">// put forks</span></span><br><span class="line">        forks[left(x)].V();</span><br><span class="line">        forks[right(x)].V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<p>问题描述：对于一个共享数据，有两类使用者</p>
<ul>
<li>读者：只读取数据，不修改（可以同时读）</li>
<li>写者：读取和修改数据（不可以同时写）</li>
<li>读写是互斥的</li>
</ul>
<p>事实上，也需要考虑到，至少有两种可能的策略（而且还会有更多）：</p>
<ul>
<li>读者优先策略：
<ul>
<li>只要有读者正在读状态，后来的读者就能直接进入</li>
<li>如果读者不断进入，则写者就处于饥饿</li>
</ul>
</li>
<li>写者优先策略
<ul>
<li>只要有写者就绪，写者应尽快执行写操作（后来的读者需要阻塞）</li>
<li>如果写者持续不断就绪，则读者就处于饥饿</li>
</ul>
</li>
</ul>
<h5 id="信号量实现-3"><a class="markdownIt-Anchor" href="#信号量实现-3"></a> 信号量实现</h5>
<p>用信号量描述每个约束：</p>
<ul>
<li>信号量<code>WriteMutex</code>
<ul>
<li>控制读写操作的互斥</li>
<li>初始化为1</li>
</ul>
</li>
<li>读者计数<code>Rcount</code>
<ul>
<li>正在进行读操作的读者数目</li>
<li>初始化为0</li>
</ul>
</li>
<li>信号量<code>CountMutex</code>
<ul>
<li>保护对读者计数的互斥修改</li>
<li>初始化为1</li>
</ul>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>读者的互斥锁只针对于第一个读者，之后不再判断</li>
<li>因为Rcount也需要保护，所以外面也加上互斥锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WriteMutex.P();</span><br><span class="line">    write;</span><br><span class="line">    WriteMutex.V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountMutex.P();</span><br><span class="line">    <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">        WriteMutex.P();</span><br><span class="line">    Rcount++;</span><br><span class="line">    CountMutex.V();</span><br><span class="line"></span><br><span class="line">    read;</span><br><span class="line"></span><br><span class="line">    CountMutex.P();</span><br><span class="line">    Rcount--;</span><br><span class="line">    <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">        WriteMutex.V();</span><br><span class="line">    CountMutex.V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一实现中，只要有读者开始阅读，就必须等到全部读者都离开才能进行写操作。即使有写操作在等待，读者仍然先于写者，说明这是一种读者优先策略。</p>
<h5 id="管程实现-2"><a class="markdownIt-Anchor" href="#管程实现-2"></a> 管程实现</h5>
<p>管程中包括以下内容：</p>
<ul>
<li>一个互斥锁</li>
<li>4个状态变量</li>
<li>2个条件变量：可读/可写</li>
</ul>
<p>从判断条件可以看出，这一实现采用的是写者优先策略。不过其实我还没想明白能否把对<code>AW</code>和<code>WW</code>变量的修改移动到<code>while</code>循环外面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Database &#123;</span><br><span class="line">    Lock lock;  // 管程的互斥锁</span><br><span class="line">    int AR = 0;  // Active Readers</span><br><span class="line">    int AW = 0;  // Active Writers</span><br><span class="line">    int WR = 0;  // Waiting Readers</span><br><span class="line">    int WW = 0;  // Waiting Writers</span><br><span class="line">    Condition okToRead, okToWrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两个基本操作</span><br><span class="line">Database::Read() &#123;</span><br><span class="line">    StartRead();  // Wait until no writers</span><br><span class="line">    read database;</span><br><span class="line">    DoneRead();  // Exit &amp; wake up waiting writers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Database::Write() &#123;</span><br><span class="line">    StartWrite();  // Waite until no readers/writers;</span><br><span class="line">    write database;</span><br><span class="line">    DoneWrite();  // Exit &amp; wake up waiting readers/writers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    while (AW + WW &gt; 0) &#123;</span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.wait(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AR--;</span><br><span class="line">    if (AR == 0 &amp;&amp; WW &gt; 0)</span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    while (AW + AR &gt; 0) &#123;</span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.wait(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AW--;</span><br><span class="line">    if (WW &gt; 0)</span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    else if (AW &gt; 0)</span><br><span class="line">        okToRead.broadcast();</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-quiz.md" target="_blank" rel="noopener">lec18 信号量与管程 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-spoc-discussion.md" target="_blank" rel="noopener">同步互斥(lec 18) spoc 思考题</a>。</p>
<h3 id="选择题"><a class="markdownIt-Anchor" href="#选择题"></a> 选择题</h3>
<p><strong>如果有5个进程共享同一程序段，每次允许3个进程进入该程序段，若用PV操作作为同步机制，则信号量S为-1时表示什么（）</strong></p>
<ul>
<li>有四个进程进入了该程序段</li>
<li>有一个进程在等待</li>
<li><strong>有三个进程进入了程序段，有一个进程在等待</strong></li>
<li>有一个进程进入了该程序段，其余四个进程在等待</li>
</ul>
<p>一般来说，信号量实现中会满足，它的整数值如果为负数，则负数的绝对值表示等待中的线程数量。当然似乎也有些实现不是这么做的。</p>
<hr>
<p><strong>2元信号量可以初始化为（）</strong></p>
<ul>
<li><strong>0或1</strong></li>
<li>0或-1</li>
<li>只能为1</li>
<li>任意值</li>
</ul>
<p>之所以可以初始化为0或1，是因为二元信号量至少有两种不同的使用场景：</p>
<ul>
<li>资源数目为1，如只能互斥访问的代码关键区</li>
<li>代码条件等待，这种情况下有可能会先执行V操作，再执行P操作</li>
</ul>
<hr>
<p><strong>多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（）</strong></p>
<ul>
<li>1个</li>
<li>2个</li>
<li><strong>3个</strong></li>
<li>4个</li>
</ul>
<p>等待进程的数量就是信号量的值的负数。不过这样可以推导出，请求过信号量资源的进程为6个，得到资源的为2个，现在仍在等待的进程为3个，说明信号量的初值为6-2-3=1。</p>
<hr>
<p><strong>(2011年全国统考)有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示；两个操作完成后，x的值（）。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加一操作    		减一操作</span><br><span class="line">Load R1,x  		load R2,x</span><br><span class="line">inc R1     		dec R2</span><br><span class="line">store x,R1 		store x,R2</span><br></pre></td></tr></table></figure>
<ul>
<li>可能为-1或3</li>
<li>只能为1</li>
<li><strong>可能为0、1或2</strong></li>
<li>可能为-1、0、1、1或2</li>
</ul>
<p>分成以下几种情况讨论：</p>
<ul>
<li>P1和P2的执行完全错开（即加载了不同的x的值）：结果正确，x=1</li>
<li>P1和P2加载了相同的x的值：结果依赖于P1先写还是P2先写，如果P1先写则x=2，否则x=0</li>
</ul>
<hr>
<p><strong>管程的主要特点有（）</strong></p>
<ul>
<li><strong>局部数据变量只能被管程的过程访问</strong></li>
<li><strong>一个进程通过调用管程的一个过程进入管程</strong></li>
<li>不会出现死锁</li>
<li><strong>在任何时候，只能有一个进程在管程中执行</strong></li>
</ul>
<p>课上好像没有讲这么多管程的特点……</p>
<hr>
<p><strong>关于管程的叙述正确的是（）</strong></p>
<ul>
<li>管程中的局部数据变量可以被外部直接访问</li>
<li>当一个进程在管程中执行时，调用管程的其他进程都不会被阻塞</li>
<li>在管程中的signal()与信号量中的signal()操作实现及意义完全相同</li>
<li><strong>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有管程才能访问</strong></li>
</ul>
<p>管程中的局部变量只能通过管程的过程访问。一个进程在管程中执行时，调用管程的其他过程都会被阻塞。管程中的signal是通过条件变量实现的，而不是信号量，所以意义有微妙的不同。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>什么是信号量？它与软件同步方法的区别在什么地方？</strong></p>
<p>信号量是由操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象数据类，由一个被保护的整形变量（sem）和P()、V()两个原子操作组成，表示系统资源的数量。</p>
<p>区别：</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制；</li>
<li>信号量是由地位高于进程的管理者OS协调的同步机制。</li>
</ul>
<hr>
<p><strong>自旋锁为什么无法按先来先服务方式使用资源？</strong></p>
<p>原因：自旋锁是由TS指令实现的临界区申请操作，第一个检测到临界区空闲的申请者而不是第一个开始检测的申请者进入。也就是说，访问顺序是由硬件随机决定的。如果要实现FIFO方式，一般都需要一个队列。</p>
<hr>
<p><strong>下面是一种P操作的实现伪码。它能按FIFO顺序进行信号量申请吗？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (s.count == 0) &#123;  //没有可用资源时，进入挂起状态；</span><br><span class="line">        调用进程进入等待队列s.queue;</span><br><span class="line">        阻塞调用进程;</span><br><span class="line">&#125;</span><br><span class="line">s.count--;              //有可用资源，占用该资源；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考回答： 它的问题是，不能按FIFO进行信号量申请。<br>
它的一种出错的情况如下：</p>
</blockquote>
<ul>
<li>一个线程A调用P()原语时，由于线程B正在使用该信号量而进入阻塞状态；注意，这时value的值为0。</li>
<li>线程B放弃信号量的使用，线程A被唤醒而进入就绪状态，但没有立即进入运行状态；注意，这里value为1。</li>
<li>在线程A处于就绪状态时，处理机正在执行线程C的代码；线程C这时也正好调用P()原语访问同一个信号量，并得到使用权。注意，这时value又变回0。</li>
<li>线程A进入运行状态后，重新检查value的值，条件不成立，又一次进入阻塞状态。</li>
<li>至此，线程C比线程A后调用P原语，但线程C比线程A先得到信号量。</li>
</ul>
<p>虽然参考答案是这么说的，但我觉得这有些牵强：事实上这种错误情况取决于V操作的语义。如果V操作能够保证使唤醒的进程立刻抢占处理机，就不会发生以上问题了。这就类似于管程的Hoare语义和Mesa语义的区别。</p>
<p><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1219" target="_blank" rel="noopener">Piazza</a>上有一个类似的讨论。事实上，在一般的Mesa语义下，使用<code>if</code>进行检查根本就是不正确的，需要用<code>while</code>。改用<code>while</code>之后，确实能保证正确性，但是FIFO无法保证了。</p>
<hr>
<p><strong>什么是条件同步？如何使用信号量来实现条件同步？</strong></p>
<p>条件同步是指线程间的事件等待。</p>
<p>条件同步的实现方法：定义初始值为<strong>0</strong>的信号量，事件触发进程使用V()操作表示事件出现，事件等待进程使用P()操作表示开始等待事件。</p>
<p>也就是说，此处P和V操作的顺序是颠倒的。</p>
<hr>
<p><strong>什么是生产者-消费者问题？</strong></p>
<ul>
<li>生产者生成数据，并放入缓冲区</li>
<li>消费者从缓冲区取出数据，进行处理</li>
<li>任何时间只有一个进程访问缓冲区</li>
</ul>
<hr>
<p><strong>为什么在生产者-消费者问题中先申请互斥信号量会导致死锁？</strong></p>
<p>如果先申请互斥信号量，后申请资源信号量，则在两种情况下可能会出现循环等待：</p>
<ul>
<li>生产者获得互斥信号量后检查<code>emptyBuffers</code>资源信号量，发现缓冲区满了，于是进入睡眠状态；此时消费者无法获得互斥信号量，于是无法消耗缓冲区内的资源</li>
<li>消费者获得互斥信号量后检查<code>fullBuffers</code>资源信号量，发现缓冲区空了，于是进入睡眠状态；此时生产者无法获得互斥信号量，于是无法将资源放入缓冲区内</li>
</ul>
<p>按答案中更抽象的说法就是这样：</p>
<blockquote></blockquote>
<ul>
<li>缓冲区空时，生产者等待缓冲区的互斥访问，以便放入数据；消费者占有缓冲区访问权，等待生产者放入的数据</li>
<li>缓冲区满时，生产者占有缓冲区访问权，等待空的缓冲块；消费者等待缓冲区的互斥访问，以便取出数据</li>
</ul>
<hr>
<p><strong>为什么互斥信号量的实现比资源信号量的实现要简单？请说明．</strong></p>
<blockquote>
<p>信号量中的整形变量的取值不同，互斥信号量的最大取值为1；而资源信号量的最大取值为资源总数。</p>
</blockquote>
<p>事实上，互斥信号量和互斥锁是等价的。（如果不考虑sem值和等待进程数量关系的问题）。</p>
<hr>
<p><strong>管程的组成包括哪几部分？入口队列和条件变量等待队列的作用是什么？</strong></p>
<blockquote>
<p>管程是一种并发程序的编程方法，由一个与入口队列对应的锁和若干个与共享数据访问的等待队列对应的条件变量组成，从而实现在任一时刻最多只有一个线程执行管程代码。</p>
</blockquote>
<p>管程的组成部分：</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>入口队列：每次只能有一个线程进入</li>
<li>0或多个条件变量（及其对应的等待队列）：管理共享数据的并发访问</li>
</ul>
<p>入口的等待队列和锁保证任一时刻最多只有一个线程执行管程代码；每个条件变量等待队列表示一种等待的资源。</p>
<hr>
<p><strong>管程与临界区有什么异同？</strong></p>
<ul>
<li>相同点：在任一时刻最多只有一个线程执行管程代码或临界区代码</li>
<li>不同点：正在管程中的线程可临时放弃管程的互斥访问（进入条件变量的等待队列），等待事件出现时恢复；而临界区不支持临时退出</li>
</ul>
<p>（所以其实在管程的概念里面我们已经不谈临界区了？）</p>
<hr>
<p><strong>为什么用管程实现的生产者-消费者问题中，可以在进入管程后才判断缓冲区的状态？</strong></p>
<p>因为管程允许临时放弃管程的互斥访问，而信号量并不支持临时放弃互斥访问权。在具体实现上，在管程内部的条件变量上进行等待时，会将管程的锁作为<code>wait()</code>操作的参数传递过去，此操作会同时放弃锁（返回时又会重新获得锁），因此不会导致死锁。</p>
<hr>
<p><strong>请描述管程条件变量的三种释放处理方式的区别是什么？条件判断中的while和if是如何影响释放处理中的顺序的？</strong></p>
<ul>
<li>Mesa管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程继续执行，被唤醒进程放回入口等待队列队首等待当前进程释放管程访问权</li>
<li>Hoare管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程进入唤醒队列等待，被唤醒进程继续执行直到释放管程访问权；管程空闲时，优先查看唤醒队列中的等待进程，唤醒队列中没有等待进程时再查看入口队列</li>
<li>Hansen管程：占用管程的当前进程只在退出管程时释放占用资源并唤醒相应的等待进程，被唤醒进程继续执行直到释放管程访问权</li>
</ul>
<p>条件判断中while和if对释放处理中的执行顺序影响：</p>
<ul>
<li>在Hansen和Mesa管程中，由于条件变量释放操作signal时并没有立即放弃管程访问权，资源的可用状态可能变化，需使用while()进行重新检查；</li>
<li>在Hoare管程中，由于条件变量释放操作signal同时表示立即放弃管程访问权，资源的可用状态保持不变，可使用if判断，不需要再次检查。</li>
</ul>
<p>Ref: <a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=894" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=894</a></p>
<p>Ref: <a href="https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html" target="_blank" rel="noopener">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>
<p>（不过在上述Piazza帖子中也有人提出了这样的问题：Hansen管程似乎是直接把访问权转移给了等待进程，这样还需要使用if来判断吗？）</p>
<hr>
<p><strong>哲学家就餐问题的方案2和方案3的性能有什么区别？</strong></p>
<ul>
<li>方案2中，最多只有一个哲学家在吃饭</li>
<li>方案3中，最多可以有两个哲学家在同时吃饭</li>
</ul>
<hr>
<p><strong>在读者-写者问题的读者优先和写者优先在行为上有什么不同？</strong></p>
<ul>
<li>读者优先策略：
<ul>
<li>只要有读者正在读状态，后来的读者就能直接进入</li>
<li>如果读者不断进入，则写者就处于饥饿</li>
</ul>
</li>
<li>写者优先策略
<ul>
<li>只要有写者就绪，写者应尽快执行写操作（后来的读者需要阻塞）</li>
<li>如果写者持续不断就绪，则读者就处于饥饿</li>
</ul>
</li>
</ul>
<hr>
<p><strong>在读者-写者问题的读者优先实现中优先于读者到达的写者在什么地方等待？</strong></p>
<p>互斥信号<code>WriteMutex</code>。因为这是控制读写互斥访问的锁。</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>请用管程with条件变量来实现信号量。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">    Lock lock;  // 管程的锁</span><br><span class="line">    int count;  // 剩余可用资源个数</span><br><span class="line">    Condition isEmpty;  // 表示是否有可用资源的事件的条件变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::Semaphore(int numRes) &#123;</span><br><span class="line">    count = numRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P() &#123;</span><br><span class="line">    lock.acquire();</span><br><span class="line">    while (count == 0)</span><br><span class="line">        isEmpty.wait(&amp;lock);</span><br><span class="line">    count--;</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    lock.acquire();</span><br><span class="line">    count++;</span><br><span class="line">    isEmpty.signal();</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到可能是Mesa语义的管程，因此进行了<code>while</code>检查。参考了这个<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">Piazza</a>帖子，我认为上述实现可以满足：</p>
<ul>
<li>在任一状态，条件变量的等待队列与信号量的等待队列完全相同</li>
<li>当<code>count != 0</code>时，其含义与信号量中的<code>sem</code>相同，此时条件变量的<code>numWaiting = 0</code></li>
<li>当<code>count = 0</code>时，条件变量的<code>numWaiting</code>等于信号量的<code>sem</code>的相反数（实现保证了count不会为负数）</li>
</ul>
<hr>
<p><strong>请用信号量来实现管程with条件变量。</strong></p>
<p>这个就有一定的难度了。当然，管程的核心是条件变量，其实实现条件变量就可以了。以下内容参考了<a href="https://birrell.org/andrew/papers/ImplementingCVs.pdf" target="_blank" rel="noopener">Implementing Condition Variables with Semaphores</a>这篇文章。</p>
<p>首先用信号量实现一个锁，这是非常容易的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">    Semaphore sm;</span><br><span class="line">    public Lock() &#123; // constructor</span><br><span class="line">        sm = new Semaphore(); sm.count =1; sm.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Acquire() &#123; sm.P(); &#125;</span><br><span class="line">    public void Release() &#123; sm.V(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出一种非常简单但是也非常错误的实现。该实现的显而易见的问题是，wait操作中对锁的释放和当前线程的睡眠不是原子的。然后好像会出现一个叫做“wake-up waiting race”的问题，不过此处好像并不会发生错误。以及，即使在没有线程正在等待时，signal操作也会使得信号量的值增加，这样，下一个等待进程就不会阻塞了，这是不正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        s = new Semaphore();</span><br><span class="line">        s.count = 0;</span><br><span class="line">        s.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        s.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我们用信号量x作为互斥锁来保护wait操作，同时统计等待进程的个数。但这个实现也有两个问题：</p>
<ul>
<li>由于s信号量的资源个数为1，因此最多只有一个调用wait的进程能够从s.P中返回，其余的都阻塞在s.P上；解决方法是把s的资源个数调到无限大</li>
<li>没有保证先进先出的语义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s, x;</span><br><span class="line">    int waiters = 0;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        s = new Semaphore(); s.count = 0; s.limit = 1;</span><br><span class="line">        x = new Semaphore(); x.count = 1; x.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        x.P();</span><br><span class="line">        waiters++;</span><br><span class="line">        x.V();</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        if (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Broadcast() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        while (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一种实现中，加入了信号量h，它会使发出信号的线程在等待线程离开等待队列之前也阻塞。这个实现是正确的，但是似乎太麻烦了。论文最后表示，他们决定还是在OS中用硬件指令来实现条件变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s, x;</span><br><span class="line">    int waiters = 0;</span><br><span class="line">    Semaphore h;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        this.m = m;</span><br><span class="line">        s = new Semaphore(); s.count = 0; s.limit = 999999;</span><br><span class="line">        x = new Semaphore(); x.count = 1; x.limit = 1;</span><br><span class="line">        h = new Semaphore(); h.count = 0; h.limit = 999999;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        x.P();</span><br><span class="line">        waiters++;</span><br><span class="line">        x.V();</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        h.V();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        if (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">            h.P();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Broadcast() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        for (int i = 0; i &lt; waiters; i++)</span><br><span class="line">            s.V();</span><br><span class="line">        while (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            h.P();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>请评价如下的实现(用信号量来实现管程with条件变量)是否合理？简要说明理由。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Implementing a Monitor</span><br><span class="line"></span><br><span class="line">CONTROL VARIABLES:</span><br><span class="line"></span><br><span class="line">	mutex: semaphore, initial value 1 (FREE)</span><br><span class="line">	next: record, with 2 fields:</span><br><span class="line">		next.sem: semaphore, initial value 0</span><br><span class="line">		next.count: counter, initial value 0</span><br><span class="line"></span><br><span class="line">	FOR EACH CONDITION x:</span><br><span class="line"></span><br><span class="line">	x: record, with 2 fields:</span><br><span class="line">		x.sem: semaphore, initial value 0</span><br><span class="line">		x.count: counter, initial value 0</span><br><span class="line">ENTRY PROTOCOL (at the beginning of each monitor function):</span><br><span class="line"></span><br><span class="line">	/* wait for exclusive access to the monitor */</span><br><span class="line">	P(mutex);</span><br><span class="line">EXIT PROTOCOL (at the end of each monitor function):</span><br><span class="line"></span><br><span class="line">	/* if there are processes in the &quot;next&quot; queue, release one */</span><br><span class="line">	if (next.count &gt; 0) V(next.sem);</span><br><span class="line"></span><br><span class="line">	/* otherwise, release the monitor */</span><br><span class="line">	else V(mutex);</span><br><span class="line">WAIT ON CONDITION x (x.wait):</span><br><span class="line"></span><br><span class="line">	/* first perform the exit protocol */</span><br><span class="line">	if (next.count &gt; 0) V(next.sem);</span><br><span class="line">	else V(mutex);</span><br><span class="line"></span><br><span class="line">	/* now wait on the condition queue */</span><br><span class="line">	x.count++;</span><br><span class="line">	P(x.sem);</span><br><span class="line">	x.count--;</span><br><span class="line">SIGNAL CONDITION x (x.signal):</span><br><span class="line"></span><br><span class="line">	/* do nothing unless a process is waiting */</span><br><span class="line">	if (x.count &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">		/* release the next waiting process */</span><br><span class="line">		V(x.sem);</span><br><span class="line"></span><br><span class="line">		/* wait on the &quot;next&quot; queue */</span><br><span class="line">		next.count++;</span><br><span class="line">		P(next.sem);</span><br><span class="line">		next.count--;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>每人使用C++或python语言用信号量和条件变量两种手段分别实现<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-spoc-pv-problems.md" target="_blank" rel="noopener">40个同步互斥问题</a>中的一题。请先理解<a href="https://github.com/chyyuu/ucore_os_lab/tree/master/related_info/lab7/semaphore_condition" target="_blank" rel="noopener">python threading 机制的介绍和实例</a></strong></p>
<p>参考：<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=391" target="_blank" rel="noopener">2015年操作系统课的信号量问题回答</a></p>
<p>建议参考梁锡豪同学的输出信息显示方式，这种方式的可读性很好。</p>
<p>建议重视测试用例的设计，以检查自己的实现是否有错。</p>
<hr>
<p><strong>设计某个方法，能够动态检查出对于两个或多个进程的同步互斥问题执行中，没有互斥问题，能够同步等，以说明实现的正确性。</strong></p>
<hr>
<p><strong>管程和信号量在解决同步互斥问题上是否等价？请证明/说明你的结论．</strong></p>
<p>Piazza上有两个非常优秀的讨论：</p>
<ul>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=845</a>：阐述了信号量和条件变量在具体实现和操作层面的异同</li>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=839" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=839</a>：对信号量和条件变量抽象的理解</li>
</ul>
<p>简单来说，就是：信号量可以实现管程，管程可以实现信号量，所以在这个层面，二者等价。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-22-summary/">
              
                  《操作系统》第22讲：“实验8-文件系统”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-24
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>本讲介绍了ucore中的文件系统。</p>
<p>TODO</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-quiz.md" target="_blank" rel="noopener">lec22 lab8 文件系统 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-spoc-discussion.md" target="_blank" rel="noopener">lab8 文件系统 (lec 22) spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>ucore实现的文件系统抽象包括（）</strong></p>
<ul>
<li><strong>文件</strong></li>
<li><strong>目录项</strong></li>
<li><strong>索引节点</strong></li>
<li><strong>安装点</strong></li>
</ul>
<p>我猜这里主要说的是VFS文件系统中的内容。</p>
<ul>
<li><code>struct file</code>：应用程序能够看到的各种文件信息</li>
<li><code>struct inode</code>：映射到特定文件系统的inode</li>
<li><code>struct fs</code>：保存了具体文件系统的结构、类型和信息</li>
</ul>
<p>然后安装点是个啥我也不知道。</p>
<blockquote>
<p>安装点是一个目录或文件，可在该处访问新文件系统、目录或文件。要安装文件系统或目录，安装点必须为一个目录；要安装文件，那么安装点必须为文件。（<a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.osdevice/mountpoint.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.osdevice/mountpoint.htm</a>）</p>
</blockquote>
<hr>
<p><strong>ucore实现的simple FS（简称SFS）采用的文件分配机制是（）</strong></p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li><strong>索引分配</strong></li>
<li>位图分配</li>
</ul>
<p>SFS使用的是一级索引。</p>
<p>索引分配的定义：为每个文件创建一个索引数据块，指向文件数据块的指针列表；文件头包含了索引数据块指针。</p>
<hr>
<p><strong>关于ucore实现的SFS阐述正确的是（）</strong></p>
<ul>
<li><strong>SFS的超级块保存在硬盘上，在加载simple FS时会读入内存中</strong></li>
<li><strong>SFS的free map结构保存在硬盘上，表示硬盘可用的数据块（扇区）</strong></li>
<li><strong>SFS的root-dir inode结构保存在硬盘上，表示SFS的根目录的元数据信息</strong></li>
<li>硬盘上的SFS ，除保存上述三种结构外，剩下的都用于保存文件的数据内容</li>
</ul>
<p>除了前三种结构，剩下的用于保存文件的inode, dir/file的data。</p>
<hr>
<p><strong>关于ucore实现的Virtual FS（简称VFS）阐述正确的是()</strong></p>
<ul>
<li><strong>已支持磁盘文件系统</strong></li>
<li><strong>已支持设备文件系统</strong></li>
<li>已支持网络文件系统</li>
<li>已支持系统状态文件系统</li>
</ul>
<blockquote>
<p>后两种可实现，但现在还没实现</p>
</blockquote>
<p>哈哈哈哈哈哈……</p>
<hr>
<p><strong>关于ucore文件系统支持的I/O设备包括()</strong></p>
<ul>
<li><strong>串口设备</strong></li>
<li><strong>并口设备</strong></li>
<li><strong>CGA设备</strong></li>
<li><strong>键盘设备</strong></li>
</ul>
<p>总之这些都支持。不过好像从Lab1就有了。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>与文件系统相关的系统调用接口、虚拟文件系统VFS、简单文件系统SFS和设备I/O等四个部分各实现什么功能？</strong></p>
<ul>
<li>系统调用接口：向应用进程提供文件访问的系统调用</li>
<li>虚拟文件系统VFS：屏蔽具体文件系统差异，对上提供一个统一的文件系统访问接口</li>
<li>简单文件系统SFS：解析和读写磁盘数据块中具体的SFS文件系统存储结构</li>
<li>设备I/O：完成实际磁盘设备上数据块的访问</li>
</ul>
<hr>
<p><strong>文件系统中的文件、目录、索引节点(inode)和安装点(挂载点)这几种数据结构分别支持些什么操作？</strong></p>
<ul>
<li>文件：open/close, read/write</li>
<li>目录：open/close, read</li>
<li>索引节点：lookup, read/write</li>
<li>挂载点：mount/unmount</li>
</ul>
<hr>
<p><strong>请简要阐述ucore文件系统架构的四个组成部分。</strong></p>
<ul>
<li>系统调用接口：用户应用使用封装后的libc库函数，文件访问的libc库函数利用文件访问系统调用来实现</li>
<li>VFS：内核的系统调用（文件、目录接口）会转换成对VFS抽象的文件访问接口（索引节点、文件卷、设备等接口）的调用，VFS再把抽象的VFS接口转换成具体的文件系统SFS的访问接口</li>
<li>SFS：对具体文件系统存储结构进行解析，把SFS对接口（索引节点、文件卷、设备等接口）的访问请求转换成设备数据块的访问</li>
<li>I/O接口：不同具体设备上的数据块访问控制</li>
</ul>
<hr>
<p><strong>请简要说明进程proc_struct、文件file、inode之间的关系。</strong></p>
<ul>
<li>进程控制块数据结构<code>proc_struct</code>中，<code>struct files_struct *filesp</code>指向进程的打开文件表</li>
<li>进程打开文件表中<code>struct file *file</code>指向系统打开文件中的相应文件状态数据</li>
<li>VFS中的系统打开文件表中<code>struct inode *inode</code>维护打开文件的状态信息，并最终对应到磁盘上的存储数据块</li>
</ul>
<hr>
<p><strong>ucore中的进程打开文件表和系统打开文件表对应到具体的哪个数据结构上？</strong></p>
<ul>
<li>进程打开文件表：<code>proc_struct</code>中的<code>struct files_struct *filesp</code></li>
<li>系统打开文件表：不知道</li>
</ul>
<hr>
<p><strong>SFS在硬盘上的四大部分主要是什么，有何作用？</strong></p>
<ul>
<li>superblock：数据块大小、文件卷名字等文件卷信息</li>
<li>root-dir inode：根目录的inode信息（存储位置等）</li>
<li>freemap：数据块占用状态信息</li>
<li>data block：inode/文件数据/目录数据</li>
</ul>
<hr>
<p><strong>硬盘上的SFS是如何加载到ucore中并初始化的？</strong></p>
<p>ucore docs Lab8：</p>
<blockquote>
<p>在<code>sfs_fs.c</code>文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p>
</blockquote>
<hr>
<p><strong>硬盘上的inode和内存中的inode的关系和区别是什么？</strong></p>
<p>内存中的inode数据结构sfs_inode中有一个字段sfs_disk_inode，它对应磁盘上的inode。</p>
<p>ucore docs Lab8：</p>
<blockquote>
<p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。<br>
……<br>
可以看到SFS中的内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
</blockquote>
<hr>
<p><strong>描述file, dir, inode在内存和磁盘上的格式和相关操作。</strong></p>
<p>每一种类型的数据块都在SFS层中有对应的操作函数指针和数据结构定义。</p>
<p>事实上，file、dir和inode在内存和磁盘上都以inode形式存储：</p>
<ul>
<li>内存：<code>struct sfs_disk_inode</code></li>
<li>磁盘：inode</li>
</ul>
<blockquote>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。<br>
对于普通文件，索引值指向的block中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。</p>
</blockquote>
<hr>
<p><strong>file数据结构的主要内容是什么？与进程的关系是什么？</strong></p>
<p><code>struct file</code>数据结构定义在<code>lab8/kern/fs/file.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    bool readable;</span><br><span class="line">    bool writable;</span><br><span class="line">    int fd;</span><br><span class="line">    off_t pos;</span><br><span class="line">    struct inode *node;</span><br><span class="line">    int open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct file</code>数据结构的内容包括：</p>
<ul>
<li><code>status</code>：文件状态</li>
<li><code>bool readable &amp; writable</code>：文件操作类型</li>
<li><code>int fd</code>：文件描述符</li>
<li><code>off_t pos</code>：文件指针</li>
<li><code>struct inode *node</code>：对应系统打开文件表项指针</li>
<li><code>int open_count</code>：文件打开计数</li>
</ul>
<p><code>struct file</code>就是进程打开文件表对应的数据结构。</p>
<hr>
<p><strong>inode数据结构的主要内容是什么？与file的数据结构的关系是什么？</strong></p>
<p><code>struct inode</code>数据结构定义在<code>lab8/kern/fs/vfs/inode.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct device __device_info;</span><br><span class="line">        struct sfs_inode __sfs_inode_info;</span><br><span class="line">    &#125; in_info;</span><br><span class="line">    enum &#123;</span><br><span class="line">        inode_type_device_info = 0x1234,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    int ref_count;</span><br><span class="line">    int open_count;</span><br><span class="line">    struct fs *in_fs;</span><br><span class="line">    const struct inode_ops *in_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct inode</code>数据结构的内容：</p>
<ul>
<li><code>in_info &amp; in_type</code>：文件类型</li>
<li><code>ref_count &amp; open_count</code>：引用计数</li>
<li><code>struct fs *in_fs</code>：对下具体文件操作函数指针</li>
<li><code>const struct inode_ops *in_ops</code>：对上inode操作函数指针</li>
</ul>
<p><code>struct inode</code>就是系统打开文件表对应的数据结构。</p>
<hr>
<p><strong>inode_ops包含哪些与文件相关的操作？</strong></p>
<p><code>struct inode_ops</code>数据结构定义在<code>lab8/kern/fs/vfs/inode.h</code>中，它是上层使用的inode操作函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct inode_ops &#123;</span><br><span class="line">    unsigned long vop_magic;</span><br><span class="line">    int (*vop_open)(struct inode *node, uint32_t open_flags);</span><br><span class="line">    int (*vop_close)(struct inode *node);</span><br><span class="line">    int (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    int (*vop_fsync)(struct inode *node);</span><br><span class="line">    int (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_reclaim)(struct inode *node);</span><br><span class="line">    int (*vop_gettype)(struct inode *node, uint32_t *type_store);</span><br><span class="line">    int (*vop_tryseek)(struct inode *node, off_t pos);</span><br><span class="line">    int (*vop_truncate)(struct inode *node, off_t len);</span><br><span class="line">    int (*vop_create)(struct inode *node, const char *name, bool excl, struct inode **node_store);</span><br><span class="line">    int (*vop_lookup)(struct inode *node, char *path, struct inode **node_store);</span><br><span class="line">    int (*vop_ioctl)(struct inode *node, int op, void *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件中有每个操作的详细注释</p>
<ul>
<li>open：打开文件</li>
<li>close：关闭文件</li>
<li>read：读文件</li>
<li>write：写文件</li>
<li>fstat：读文件信息</li>
<li>fsync：将脏缓存写回持久化存储介质</li>
<li>namefile：计算文件相对于文件系统根目录的路径</li>
<li>getdirentry：从目录中读一个文件名</li>
<li>reclaim：回收inode</li>
<li>gettype：文件种类</li>
<li>tryseek：检查移动文件指针是否合法</li>
<li>truncate：重设文件大小，丢弃多余的数据</li>
<li>create：在目录中新建文件</li>
<li>lookup：在给定目录中按文件名查找文件</li>
<li>ioctl：管理I/O通道（？？）</li>
</ul>
<hr>
<p><strong>VFS是如何把键盘、显示输出和磁盘文件统一到一个系统调用访问框架下的？</strong></p>
<ul>
<li>VFS把键盘、显示和磁盘文件都视为文件，VFS对上提供的访问接口都是文件访问接口</li>
<li>VFS通过区别文件类型、文件操作类型、设备类型等来区别同类操作在不同设备的不同实现</li>
</ul>
<hr>
<p><strong>device数据结构的主要内容是什么？与fs的关系是什么？与inode的关系是什么？</strong></p>
<p>这里的<code>device</code>指的应该是<code>lab8/kern/fs/devs/dev.h</code>中定义的<code>struct device</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Filesystem-namespace-accessible device.</span><br><span class="line"> * d_io is for both reads and writes; the iobuf will indicates the direction.</span><br><span class="line"> */</span><br><span class="line">struct device &#123;</span><br><span class="line">    size_t d_blocks;</span><br><span class="line">    size_t d_blocksize;</span><br><span class="line">    int (*d_open)(struct device *dev, uint32_t open_flags);</span><br><span class="line">    int (*d_close)(struct device *dev);</span><br><span class="line">    int (*d_io)(struct device *dev, struct iobuf *iob, bool write);</span><br><span class="line">    int (*d_ioctl)(struct device *dev, int op, void *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct device</code>数据结构的内容：</p>
<ul>
<li><code>size_t d_blocks</code>：数据块个数</li>
<li><code>size_t d_blocksize</code>：数据块大小</li>
<li>设备操作函数指针（<code>d_open</code>, <code>d_close</code>, <code>d_io</code>, <code>d_ioctl</code>）</li>
</ul>
<p>fs和inode通过device数据结构中的设备操作函数指针实现对设备数据块的访问。</p>
<hr>
<p><strong>比较ucore中I/O接口、SFS文件系统接口和文件系统的系统调用接口的操作函数有什么异同？</strong></p>
<ul>
<li>文件系统的系统调用接口（<code>lab8/kern/syscall/syscall.c</code>）：sys_open, sys_close, sys_read, sys_write, sys_seek, sys_fstat, sys_fsync, sys_chdir, sys_getcwd, sys_mkdir, sys_link, sys_rename, sys_unlink, sys_getdirentry, sys_dup, sys_pipe, sys_mkfifo, sys_mount, sys_umount, sys_ioctl</li>
<li>VFS文件系统接口（<code>lab8/kern/vfs/vfs.h</code>）：vfs_open, vfs_close, vfs_link, vfs_symlink, vfs_readlink, vfs_mkdir, vfs_unlink, vfs_rename, vfs_chdir, vfs_getcwd</li>
<li>SFS文件系统接口（<code>lab8/kern/sfs/sfs.h</code>）：sfs_rblock, sfs_wblock, sfs_rbuf, sfs_wbuf, sfs_sync_super, sfs_sync_freemap, sfs_clear_block, sfs_load_inode</li>
<li>I/O接口（<code>lab8/kern/devs/dev.h</code>）：d_open, d_close, d_io, d_ioctl</li>
</ul>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>理解文件访问的执行过程，即在ucore运行过程中通过<code>cprintf</code>函数来完整地展现出来读一个文件在ucore中的整个执行过程，(越全面细致越好) 完成代码填写，并形成spoc练习报告，需写练习报告和简单编码，完成后放到git server 对应的git repo中。</strong></p>
<p>啊，这个完全没有时间去写了……</p>
<hr>
<p><strong>在下面的实验代码的基础上，实现基于文件系统的pipe IPC机制。练习用的<a href="https://github.com/chyyuu/ucore_lab/tree/master/labcodes_answer/lab8_result" target="_blank" rel="noopener">lab8 spoc exercise project source code</a></strong></p>
<p>呃，这是lab8的附加题……</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-23-summary/">
              
                  《操作系统》第23讲：“I/O子系统”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-24
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<ul>
<li>常见设备I/O接口</li>
<li>进程的I/O方法</li>
<li>CPU与设备之间的I/O方法
<ul>
<li>连接方法</li>
<li>传输方法</li>
<li>通知方法</li>
</ul>
</li>
<li>I/O请求生存周期</li>
<li>一类具体的I/O设备：磁盘
<ul>
<li>磁盘的工作机制和传输时间</li>
<li>磁盘调度算法</li>
<li>磁盘缓存</li>
</ul>
</li>
</ul>
<h3 id="常见设备io接口"><a class="markdownIt-Anchor" href="#常见设备io接口"></a> 常见设备I/O接口</h3>
<p>常见的接口分为三类。</p>
<table>
<thead>
<tr>
<th>设备接口类型</th>
<th>例子</th>
<th>访问特征</th>
<th>I/O命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符设备</td>
<td>键盘、鼠标、串口</td>
<td>以字节为单位顺序访问</td>
<td>文件访问接口</td>
</tr>
<tr>
<td>块设备</td>
<td>磁盘驱动器、磁带驱动器、光驱</td>
<td>均匀的数据块访问</td>
<td>文件系统接口、内存映射</td>
</tr>
<tr>
<td>网络设备</td>
<td>以太网、无线、蓝牙</td>
<td>格式化报文交换</td>
<td>网络报文、网络协议</td>
</tr>
</tbody>
</table>
<h3 id="进程的io方法"><a class="markdownIt-Anchor" href="#进程的io方法"></a> 进程的I/O方法</h3>
<p>从进程的角度来看，I/O方法分为三种类型。</p>
<table>
<thead>
<tr>
<th>I/O类型</th>
<th>特点</th>
<th>读写方法</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞I/O</td>
<td>Wait</td>
<td>读写时，进程将进入等待状态，直到设备完成数据处理</td>
<td><img src="block-io.png" alt></td>
</tr>
<tr>
<td>非阻塞I/O</td>
<td>Don’t Wait</td>
<td>读写时立即从read或write系统调用返回，返回值为成功传输字节数；可能不成功</td>
<td><img src="unblock-io.png" alt></td>
</tr>
<tr>
<td>异步I/O</td>
<td>Tell Me Later</td>
<td>读写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区/处理数据并通知用户</td>
<td><img src="async-io.png" alt></td>
</tr>
</tbody>
</table>
<h3 id="cpu与设备之间的io方法"><a class="markdownIt-Anchor" href="#cpu与设备之间的io方法"></a> CPU与设备之间的I/O方法</h3>
<p><img src="kernel-io-structure.png" alt="内核I/O结构"></p>
<p>内核通过I/O子系统控制各种硬件。</p>
<h4 id="连接方法"><a class="markdownIt-Anchor" href="#连接方法"></a> 连接方法</h4>
<p>一般来说，北桥芯片连接的是高速I/O设备，如内存和显卡；南桥芯片连接的是普通I/O设备，如磁盘和网络。</p>
<p>设备上的设备控制器是CPU和I/O设备间的接口，它向CPU提供特殊指令和寄存器，也就是CPU用来控制I/O设备的I/O地址，分为两种：</p>
<ul>
<li>I/O指令：通过I/O端口号访问设备寄存器</li>
<li>内存映射I/O：设备的寄存器/存储空间被映射到内存物理地址空间中，通过内存load/store指令完成I/O操作</li>
</ul>
<h4 id="传输方法"><a class="markdownIt-Anchor" href="#传输方法"></a> 传输方法</h4>
<p>CPU与设备控制器之间的数据传输分为两种方式：</p>
<ul>
<li>程序控制I/O（PIO，Programmed I/O）
<ul>
<li>通过CPU的in/out或者load/store传输所有数据（内存映射）
<ul>
<li>特点：</li>
<li>硬件简单，编程容易</li>
<li>消耗的CPU时间和数据量成正比</li>
</ul>
</li>
<li>适用于简单的、小型的设备I/O</li>
</ul>
</li>
<li>直接内存访问（DMA）
<ul>
<li>设备控制器可直接访问系统总线</li>
<li>控制器直接与内存互相传输数据</li>
<li>特点：
<ul>
<li>设备传输数据不影响CPU</li>
<li>需要CPU参与设置（这是必然的）</li>
<li>适用于高吞吐量I/O</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="通过dma读取磁盘数据的例子"><a class="markdownIt-Anchor" href="#通过dma读取磁盘数据的例子"></a> 通过DMA读取磁盘数据的例子</h5>
<p><img src="dma-read-disk-data.png" alt></p>
<p>具体步骤如下：</p>
<ol>
<li>设备驱动收到读取磁盘数据到内存地址X的请求</li>
<li>设备驱动控制磁盘控制器从磁盘读取数据</li>
<li>磁盘控制器初始化DMA传送</li>
<li>磁盘控制器传送数据到DMA控制器</li>
<li>DMA控制器传送C字节数据到内存地址X</li>
<li>DMA控制器完成数据传送后，产生中断请求，通知CPU传送完成</li>
</ol>
<h4 id="通知方法"><a class="markdownIt-Anchor" href="#通知方法"></a> 通知方法</h4>
<p>设备通知CPU（I/O操作完成时间、I/O操作是否发生错误、设备状态等）主要分为两种方式：</p>
<ul>
<li>CPU主动轮询</li>
<li>设备中断</li>
</ul>
<h5 id="轮询"><a class="markdownIt-Anchor" href="#轮询"></a> 轮询</h5>
<p>处理流程：</p>
<ul>
<li>I/O设备在特定的状态寄存器中放置状态和错误信息</li>
<li>操作系统定期检测状态寄存器</li>
</ul>
<p>特点：</p>
<ul>
<li>简单</li>
<li>I/O操作频繁或不可预测时，开销大和延时长</li>
</ul>
<h5 id="设备中断"><a class="markdownIt-Anchor" href="#设备中断"></a> 设备中断</h5>
<p>处理流程：</p>
<ul>
<li>CPU在I/O之前设置任务参数</li>
<li>CPU在发出I/O请求后，继续执行其他任务</li>
<li>I/O设备处理I/O请求</li>
<li>I/O设备处理完成时，触发CPU中断请求</li>
<li>CPU接收中断，分发到相应中断处理例程</li>
</ul>
<p><img src="device-interrupt-io.png" alt="设备中断I/O处理流程图示"></p>
<p>特点：</p>
<ul>
<li>处理不可预测事件效果好（CPU在每两条指令中间处理一次中断请求）</li>
<li>开销相对较高</li>
</ul>
<h3 id="io请求生存周期"><a class="markdownIt-Anchor" href="#io请求生存周期"></a> I/O请求生存周期</h3>
<p><img src="io-request-life-cycle.png" alt="I/O请求生存周期"></p>
<p>显然，这是异步I/O请求。</p>
<h3 id="一类具体的io设备磁盘"><a class="markdownIt-Anchor" href="#一类具体的io设备磁盘"></a> 一类具体的I/O设备：磁盘</h3>
<h4 id="磁盘的工作机制和传输时间"><a class="markdownIt-Anchor" href="#磁盘的工作机制和传输时间"></a> 磁盘的工作机制和传输时间</h4>
<p><img src="disk-structure.png" alt="磁盘的组成"></p>
<p>磁盘的主要组成部分包括：</p>
<ul>
<li>磁盘轴</li>
<li>若干个盘片（围绕磁盘轴旋转）
<ul>
<li>磁道</li>
<li>扇区</li>
</ul>
</li>
<li>磁头（上面有读写头）</li>
</ul>
<p>在读取或写入时，磁头必须被定位在期望的磁道，并从所期望的柱面和扇区开始读写。在这一过程中，花时间最长的是磁头的移动。我们称<strong>寻道时间</strong>为定位到期望的磁道所花费的时间，<strong>旋转延迟</strong>为从0扇区开始处到达目的地花费的时间。一般来说，<strong>平均旋转延迟时间</strong> 是磁盘旋转一周时间的一半。</p>
<p>磁盘I/O传输一般分为以下5个步骤：</p>
<ol>
<li>等待设备可用</li>
<li>等待通道（PIO或DMA通道）可用</li>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ol>
<p>后四个步骤被称为“设备忙”状态，所占用的时间一般认为是传输时间，公式为</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a = T_s+ \frac{1}{2r} + \frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>公式各个部分的含义：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：传输时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：寻道时间（和磁头移动距离有关，花费的时间最多）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>：旋转延迟（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>=旋转一周的时间）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>：传输时间
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>：传输的比特数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>：磁道上的比特数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>：磁盘转速</li>
</ul>
</li>
</ul>
<p>显然，最需要优化的是寻道时间。磁盘调度算法解决的就是这一问题。</p>
<h4 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h4>
<p>磁盘调度算法的目的：通过优化磁盘访问请求顺序来提高磁盘访问性能</p>
<p>进行磁盘调度的原因：</p>
<ul>
<li>寻道时间是磁盘访问最耗时的部分</li>
<li>同时会有多个在同一磁盘上的I/O请求（所以可以调整顺序）</li>
<li>随机处理磁盘访问请求的性能表现很差</li>
</ul>
<p>下列算法中使用的例子：</p>
<ul>
<li>磁盘访问序列：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li>
<li>初始磁头位置：<code>53</code></li>
</ul>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>做法</th>
<th>特征</th>
<th>例子</th>
<th>移动距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>先进先出（FIFO）算法</td>
<td>按顺序处理请求</td>
<td>能够保证公平；性能较差</td>
<td><code>53-&gt;98-&gt;183-&gt;37-&gt;122-&gt;14-&gt;124-&gt;65-&gt;67</code></td>
<td>640</td>
</tr>
<tr>
<td>最短服务时间优先（SSTF）算法</td>
<td>选择从磁臂当前位置需要移动最少的I/O请求</td>
<td>很不公平</td>
<td><code>53-&gt;65-&gt;67-&gt;14-&gt;98-&gt;122-&gt;124-&gt;183</code></td>
<td>236</td>
</tr>
<tr>
<td>扫描（SCAN）算法</td>
<td>磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的<strong>磁道</strong>；然后调换方向</td>
<td>判断简单；不公平，偏好中间位置磁道</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;65-&gt;67-&gt;98-&gt;122-&gt;124-&gt;183-&gt;199</code></td>
<td>236</td>
</tr>
<tr>
<td>循环扫描（C-SCAN）算法</td>
<td>对SCAN算法的改进：限制仅在一个方向上扫描；当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</td>
<td>比SCAN算法更公平</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;199-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>386</td>
</tr>
<tr>
<td>C-LOOK算法</td>
<td>对C-SCAN算法的改进：不走到磁盘的头，而是只走到最远的请求</td>
<td>同样能保证公平性</td>
<td><code>53-&gt;37-&gt;14-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>326</td>
</tr>
<tr>
<td>N步扫描（N-step-SCAN）算法</td>
<td>将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列；再用扫描算法处理每个队列</td>
<td>防止磁头粘着现象</td>
<td><code>53-&gt;37-&gt;183-&gt;98-&gt;14-&gt;124-&gt;122-&gt;67-&gt;65</code></td>
<td>500</td>
</tr>
<tr>
<td>双队列扫描（FSCAN）算法</td>
<td>将磁盘请求队列分成两个子队列，交替使用扫描算法处理每一个队列；处理一个队列时，所有新生成的磁盘I/O请求都被放入另一队列中</td>
<td>比N步扫描更简单</td>
<td><code>53-&gt;37-&gt;183-&gt;122-&gt;98-&gt;67-&gt;65-&gt;14-&gt;124</code></td>
<td>441</td>
</tr>
</tbody>
</table>
<p>一些细节：</p>
<ul>
<li>认为SCAN、C-SCAN、C-LOOK和N步扫描算法都是先向低编号移动</li>
<li>N步扫描算法的N为3，使用的是C-LOOK扫描方法</li>
<li>FSCAN算法中假设后四个请求位于下一个队列，使用的也是C-LOOK扫描算法</li>
<li>课件上没有指出C-SCAN算法返回时到底是返回到另外一端还是“另外一端最靠边的请求”。鉴于有C-LOOK的改进，我就认为C-SCAN傻得直接走到另一端了。类似地，我也认为C-LOOK算法反转时只会走到另一端最远的请求，而不是另一端。</li>
</ul>
<h4 id="磁盘缓存"><a class="markdownIt-Anchor" href="#磁盘缓存"></a> 磁盘缓存</h4>
<p><strong>缓存</strong>是数据传输双方访问速度差异较大时，引入的速度匹配中间层。<strong>磁盘缓存</strong> 是磁盘扇区在内存中的缓冲区。磁盘缓存的调度算法很类似虚拟存储调度算法（不过倒了过来，虚拟存储是把内存缓存到磁盘，磁盘缓存是把磁盘缓存到内存==）。</p>
<h5 id="单缓存与双缓存"><a class="markdownIt-Anchor" href="#单缓存与双缓存"></a> 单缓存与双缓存</h5>
<p>根据缓冲区个数分类：</p>
<ul>
<li>单缓存（Single Buffer Cache）：I/O设备写入时，CPU不能进行读操作（类似生产者-消费者问题）</li>
<li>双缓存（Double Buffer Cache）：有两个缓冲区，可以同时分别读写；结束之后可以交换</li>
</ul>
<h5 id="访问频率置换frequency-based-replacement算法"><a class="markdownIt-Anchor" href="#访问频率置换frequency-based-replacement算法"></a> 访问频率置换（Frequency-based Replacement）算法</h5>
<p>问题：在一段密集磁盘访问后，LFU算法的引用计数变化无法反映当前的引用情况</p>
<p>算法思路：</p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li>
</ul>
<p><img src="fbr-stack.png" alt="访问频率置换算法的特殊栈"></p>
<p>算法具体步骤：</p>
<ul>
<li>把LRU算法中的特殊栈分成3部分，并为每个缓存块增加一个引用计数
<ul>
<li>新区域（New Section）：栈顶</li>
<li>中间区域（Middle Section）</li>
<li>旧区域（Old Section）：栈底</li>
</ul>
</li>
<li>每次访问时：
<ul>
<li>栈中被访问的缓存块移到栈顶（这个是LRU的原始要求）；如果该块原来在新区域，引用计数不变（这个是符合LRU的）；否则引用计数+1
<ul>
<li>在新区域中引用计数不变的目的是避免密集访问对引用计数产生不利影响</li>
<li>在中间区域和旧区域中引用计数+1是为了使用LFU算法</li>
</ul>
</li>
<li>未缓存数据块读入后放在栈顶，引用计数为1</li>
<li>在旧区域中引用计数最小的缓存块被置换（这是LFU的要求；但并不会在整个栈里找计数最小的）
<ul>
<li>中间区域的定义是为了避免新读入的缓存块在第一次离开新区域时马上被置换，有一个过渡期</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：懒得想了，不写了</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/10-1-quiz.md" target="_blank" rel="noopener">lec23 IO设备 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/10-1-spoc-discussion.md" target="_blank" rel="noopener">IO设备(lec 23) spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>字符设备包括（）</strong></p>
<ul>
<li><strong>键盘</strong></li>
<li><strong>鼠标</strong></li>
<li><strong>并口</strong></li>
<li><strong>串口</strong></li>
</ul>
<p>都是。因为它们的访问特征都是以字节为单位顺序访问。</p>
<hr>
<p><strong>块设备包括（）</strong></p>
<ul>
<li><strong>硬盘</strong></li>
<li><strong>软盘</strong></li>
<li><strong>光盘</strong></li>
<li><strong>U盘</strong></li>
</ul>
<p>都是。因为它们的访问特征都是均匀的数据块访问。</p>
<hr>
<p><strong>网络设备包括（）</strong></p>
<ul>
<li><strong>以太网卡</strong></li>
<li><strong>wifi网卡</strong></li>
<li><strong>蓝牙设备</strong></li>
<li>网盘设备</li>
</ul>
<p>网络设备的访问特征是格式化报文交换。而网盘在模拟实现上应该算块设备。</p>
<hr>
<p><strong>关于CPU与设备的通信方式包括（）</strong></p>
<ul>
<li><strong>轮询</strong></li>
<li><strong>设备中断</strong></li>
<li><strong>DMA</strong></li>
<li>PIPE</li>
</ul>
<p>PIPE是用于进程间通信的。虽然DMA听起来是直接把数据写入到内存，不过还是需要CPU参与设置的。</p>
<hr>
<p><strong>关于IO数据传输的阐述正确的是（）</strong></p>
<ul>
<li><strong>程序控制I/O(PIO, Programmed I/O)通过CPU的in/out或者load/store传输所有数据</strong></li>
<li><strong>DMA设备控制器可直接访问系统总线并直接与内存互相传输数据</strong></li>
<li>DMA机制适合字符设备</li>
<li>PIO机制适合块设备</li>
</ul>
<p>DMA机制适合块设备，PIO机制适合简单，低速的字符设备等。最后两个选项反了。</p>
<hr>
<p><strong>常用移臂调度算法包括（）</strong></p>
<ul>
<li><strong>先来先服务（FIFO）算法</strong></li>
<li><strong>最短寻道时间优先（SSTF）算法</strong></li>
<li><strong>电梯调度（SCAN）算法</strong></li>
<li><strong>单向扫描（C-SCAN）算法</strong></li>
</ul>
<p>都对。除此之外还有CLOOK和N-step-SCAN算法。</p>
<hr>
<p><strong>在设备管理子系统中，引入缓冲区的目的主要有()</strong></p>
<ul>
<li><strong>缓和CPU与I/O设备间速度不匹配的矛盾</strong></li>
<li><strong>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</strong></li>
<li><strong>解决基本数据单元大小（即数据粒度）不匹配的问题</strong></li>
<li><strong>提高CPU和I/O设备之间的并行性</strong></li>
</ul>
<p>都对。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>字符设备的特点是什么？</strong></p>
<p>以字节为单位顺序访问。</p>
<hr>
<p><strong>块设备的特点是什么？</strong></p>
<p>以均匀的数据块为单位随机访问。</p>
<hr>
<p><strong>网络设备的特点是什么？</strong></p>
<p>以格式化报文为单位的复杂交互访问。</p>
<hr>
<p><strong>阻塞I/O、非阻塞I/O和异步I/O这三种I/O方式有什么区别？</strong></p>
<ul>
<li>阻塞I/O：数据读写操作后，进程将进入等待状态，直到完成操作时返回；</li>
<li>非阻塞I/O：数据读写操作后，进程将立即返回；</li>
<li>异步I/O：数据读写操作后，进程将立即返回；内核在完成操作时通知进程；</li>
</ul>
<p>区别：</p>
<ul>
<li>进程发出操作命令后，进程是否等待；</li>
<li>操作结果反馈方式</li>
</ul>
<hr>
<p><strong>请描述I/O请求到完成的整个执行过程。</strong></p>
<p>CPU通过总线与设备相连；CPU通过主动的I/O端口和映射内存读写操作与设备进行信息交互；设备通过中断请求来响应CPU的操作；在CPU的控制下，DMA可直接在设备接口与内存间的数据传输。</p>
<ol>
<li>进程通过系统调用发送对设备的抽象操作命令</li>
<li>内核把抽象的设备操作命令转换成具体的设备I/O端口和映射内存读写序列，并在设备驱动中实施读写操作</li>
<li>当这个读写序列较长时，CPU会控制DMA进行内存与设备接口的直接数据传送</li>
<li>设备在收到控制序列后，执行操作动作，并在完成时向CPU发出中断请求</li>
<li>CPU通过中断服务例程响应设备的中断请求，并进行后续处理，直到系统调用返回，从而完成整个I/O操作过程。</li>
</ol>
<hr>
<p><strong>IO数据传输有哪几种？</strong></p>
<ul>
<li>程序控制I/O：
<ul>
<li>CPU通过显式的IO指令，如x86的in, out等传输数据</li>
<li>memory读写方式，即把device的寄存器，内存等映射到物理内存中</li>
</ul>
</li>
<li>直接内存访问（DMA）：在CPU的控制下，DMA控制器直接在内存与设备接口间传输数据</li>
</ul>
<hr>
<p><strong>轮询方式的特点是什么？</strong></p>
<ul>
<li>简单</li>
<li>I/O操作频繁或不可预测时，开销大和延时长</li>
</ul>
<hr>
<p><strong>中断方式的特点是什么？</strong></p>
<ul>
<li>处理不可预测事件效果好</li>
<li>开销相对较高</li>
</ul>
<hr>
<p><strong>DMA方式的特点是什么？</strong></p>
<ul>
<li>直接在内存与设备接口间进行数据传输</li>
<li>适合高速和简单的数据传输</li>
<li>CPU的开销小</li>
</ul>
<hr>
<p><strong>请简要阐述磁盘的工作过程。</strong></p>
<ul>
<li>磁头移动到期望的磁道</li>
<li>盘片旋转定位到期望的柱面和扇区</li>
<li>开始读写</li>
</ul>
<hr>
<p><strong>请描述磁盘I/O操作时间组成。</strong></p>
<p>磁盘I/O操作一般分成五个步骤：</p>
<ul>
<li>等待设备可用</li>
<li>等待通道（PIO或DMA通道）可用</li>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ul>
<p>其中后四个步骤被称为“设备忙”状态，一般认为是传输时间，公式为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a = T_s+ \frac{1}{2r} + \frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<hr>
<p><strong>请说明磁盘调度算法的评价指标。</strong></p>
<ul>
<li>总的I/O时间开销（显然）</li>
<li>公平性</li>
<li>平均等待时间（似乎这对磁盘调度不是很重要）</li>
</ul>
<hr>
<p><strong>请描述FIFO、SSTF、SCAN、CSCAN、LOOK、C-LOOK、N-step-SCAN和FSCAN等磁盘调度算法的工作原理。</strong></p>
<p>磁盘调度算法就是优化磁盘数据块的访问顺序。</p>
<ul>
<li>先进先出（FIFO）算法：按请求顺序访问</li>
<li>最短寻道时间优先（SSTF）算法：从当前位置找当前最近的访问数据块位置</li>
<li>扫描（SCAN）算法：保持磁头移动方向到最远处，并顺序访问需要访问的数据块</li>
<li>循环扫描（C-SCAN）算法：只在一个方向上移动时访问数据的SCAN算法</li>
<li>LOOK算法：保持磁头移动方向到已有的最后一个请求，并顺序访问需要访问的数据块</li>
<li>C-LOOK算法：只在一个方向上移动时访问数据的LOOK算法；</li>
<li>N步扫描（N-step-SCAN）算法：
<ol>
<li>将磁盘请求队列分成长度为N的子队列</li>
<li>按FIFO算法依次处理所有子队列</li>
<li>按扫描算法处理每个队列</li>
</ol>
</li>
<li>双队列扫描（FSCAN）算法：
<ol>
<li>把磁盘I/O请求分成两个队列，交替使用扫描算法处理一个队列</li>
<li>新生成的磁盘I/O请求放入另一队列中</li>
</ol>
</li>
</ul>
<hr>
<p><strong>磁盘缓存的作用是什么？</strong></p>
<p>磁盘缓存是磁盘扇区在内存中的缓存区。作用是通过缓存访问，减少磁盘访问。</p>
<hr>
<p><strong>请描述单缓存(Single Buffer Cache)的工作原理。</strong></p>
<p>只有一个缓存区，用户进程和I/O设备只能交替访问缓存区。</p>
<hr>
<p><strong>请描述双缓存(Double Buffer Cache)的工作原理。</strong></p>
<p>设置两个缓存区，任何时刻用户进程和I/O设备可同时访问不同的缓存区。</p>
<hr>
<p><strong>请描述访问频率置换算法(Frequency-based Replacement)的基本原理。</strong></p>
<p>思路：</p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>短周期内采用LRU，长周期内采用LFU</li>
</ul>
<p>做法：</p>
<ul>
<li>把栈分成三个区域：新区域（栈顶）、中间区域、旧区域（栈底）</li>
<li>新区域中数据块的引用，不计数</li>
<li>中间区域和旧区域中数据块的引用，引用计数加</li>
<li>淘汰只在旧区域中找引用计数最小的数据块</li>
</ul>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>请以键盘输入、到标准输出设备stdout的printf输出、串口输出、磁盘文件复制为例，描述ucore操作系统I/O从请求到完成的整个执行过程，并分析I/O过程的时间开销。</strong></p>
<p>没做，现在还没做完lab8，感觉实在过于麻烦了。</p>
<hr>
<p><strong>完成磁盘访问与磁盘寻道算法的作业，然后实现CSCAN、LOOK、C-LOOK、FSCAN等磁盘调度算法中的一个。具体帮助和要求信息请看<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-disks.pdf" target="_blank" rel="noopener">Chapter 37: Hard Disk Drives</a>、<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.md" target="_blank" rel="noopener">disksim指导信息</a>和<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.py" target="_blank" rel="noopener">disksim参考代码</a></strong></p>
<p>看起来不难，但现在做起来意义不大，所以不做了。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2014-final-exam-analysis/">
              
                  《操作系统》2014年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="一-信号12分"><a class="markdownIt-Anchor" href="#一-信号12分"></a> 一 信号（12分）</h2>
<p>在Linux/Unix中，一个用户从shell中执行了一个运行时间较长且不知何时能够结束的程序，Linux/UNIX可以让用户根据个人需求随时通过敲击Ctrl-C组合键来终止这个程序的执行。请回答如下问题。要求设计应该具有通用性，列出的设计实现不超过6点，每点不超过 4行。问题的执行流程描述不超过8行。</p>
<ol>
<li>如果要在ucore中实现Linux/UNIX同样的功能，请问应该如何修改ucore来支持此功能？</li>
<li>uCore的shell也是一个程序，我们希望避免这个shell在执行中被用户敲入的Ctrl-C所终止，请问在保证1的要求前提下，如何修改ucore和shell来支持此功能？</li>
<li>说明在你的设计下，shell和某一可被终止程序在执行过程中，用户敲击Ctrl-C后，uCore和shell的执行流程。</li>
</ol>
<hr>
<ol>
<li>很显然，应该通过信号机制来实现相应的功能。我觉得可以修改编译器，使得编译时为每个程序自动加入信号处理例程，进程启动时将相应的信号处理函数注册到内核，发生SIGKILL（Ctrl+C组合）时将信号分发给进程，进程执行信号处理例程并退出。</li>
<li>shell可以在程序中屏蔽Ctrl+C信号</li>
<li>ucore和shell的执行流程：</li>
<li>ucore接收到键盘中断</li>
<li>ucore识别出按下的键是Ctrl+C，发送信号</li>
<li>中断返回时检查到进程有未处理的信号，转入信号处理（这一步我们大概没有细讲……总之就是进入了正在执行的程序的信号处理例程）</li>
<li>信号处理例程使进程退出</li>
<li>shell继续wait</li>
</ol>
<h2 id="二-ipc机制"><a class="markdownIt-Anchor" href="#二-ipc机制"></a> 二 IPC机制</h2>
<p>在具备了执行用户态进程的能力之后，uCore要为这些进程提供的一个重要服务，是用户进程之间的消息传递机制（Inter-Process Communication，简写为 IPC）。现在，我们要为uCore实现以下两个系统调用，以实现一种同步的IPC机制（暂不考虑超时等功能）：</p>
<ul>
<li><code>int sys_send_event(int pid, int event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 该消息的目标进程的进程号；</li>
</ul>
</li>
</ul>
</li>
<li>event – 消息内容，用一个整型表示。</li>
<li>返回值：消息成功发送时，返回0；否则，返回相应的错误代码。</li>
<li><code>int sys_recv_event(int *pid, int *event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 函数返回时，<code>*pid</code>保存发出消息的进程的进程号，可以为NULL；</li>
<li>event – 函数返回时，<code>*event</code>保存消息内容，可以为NULL。</li>
</ul>
</li>
<li>返回值：消息成功接收时，返回 0；否则，返回相应的错误代码。</li>
</ul>
</li>
</ul>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>以下是一个基于上述IPC机制求质数的用户程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int total = 1000;</span><br><span class="line"></span><br><span class="line">void primeproc(void)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0, this, num, pid = 0;</span><br><span class="line">top:</span><br><span class="line">    recv_event(NULL, &amp;this);</span><br><span class="line">    cprintf(&quot;%d is a primer.\n&quot;, this);</span><br><span class="line"></span><br><span class="line">    while (recv_event(NULL, &amp;num) == 0) &#123;</span><br><span class="line">        if ((num % this) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            if (index + 1 == total) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((pid = fork()) == 0) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                goto top;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pid &lt; 0) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (send_event(pid, num) != 0) &#123;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    cprintf(&quot;[%04d] %d quit.\n&quot;, getpid(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, pid;</span><br><span class="line">    unsigned int time = gettime_msec();</span><br><span class="line">    if ((pid = fork()) == 0) &#123;</span><br><span class="line">        primeproc();</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pid &gt; 0);</span><br><span class="line"></span><br><span class="line">    for (i = 2;; i++) &#123;</span><br><span class="line">        if (send_event(pid, i) != 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(&quot;use %d msecs.\n&quot;, gettime_msec() - time);</span><br><span class="line">    cprintf(&quot;primer3 pass.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简述这个程序是如何判断并输出前五个质数的。</p>
<hr>
<p>主进程（称为P1）首先fork出一个子进程，子进程开始执行<code>primeproc()</code>函数（称为P2）。主进程从<code>i = 2</code>开始不断向P1发送内容为<code>i</code>的自然数，直到发送不成功为止。</p>
<p>P1进程不断循环：</p>
<ul>
<li>接收P0发送的消息，将这个整数保存下来，作为质数<code>this</code></li>
<li>不断接收P0发送的消息，保存为<code>num</code>；如果接收不成功，退出并打印信息</li>
<li>若<code>num</code>可以被<code>this</code>整除，显然<code>num</code>不是质数，跳出此次循环，继续等待消息</li>
</ul>
<p>。。。不会了</p>
<p>学长答案说：</p>
<blockquote>
<p>每个进程是一个输出一个素数，负责检验传进来的数是否整除这个素数，如果都过了在新建一个进程</p>
</blockquote>
<p>我觉得从理论上来说确实是这样，但是不够详细。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>给出一种基于等待队列的上述IPC机制的实现方案。</p>
<hr>
<p>在我的妄想中这个是这样实现的：</p>
<ul>
<li>建立两个等待队列：发送等待队列和接收等待队列</li>
<li>当进程发送消息时，检查目标进程是否在接收等待队列中，如果不在，则加入发送等待队列；如果在，则将目标进程取出，发送对应的消息</li>
<li>当进程接收消息时，检查发送等待队列中是否有进程发送的目标是它，如果有，则将该进程取出，接收对应的消息；否则加入接收等待队列</li>
</ul>
<h2 id="三-ucore中的信号量实现10分"><a class="markdownIt-Anchor" href="#三-ucore中的信号量实现10分"></a> 三 ucore中的信号量实现（10分）</h2>
<p>在uCore中，信号量的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line"> int value;</span><br><span class="line"> wait_queue_t wait_queue;</span><br><span class="line">&#125; semaphore_t;</span><br><span class="line"></span><br><span class="line">// __up 函数是信号量 V 操作的具体实现函数</span><br><span class="line">static __noinline void __up(semaphore_t *sem, uint32_t wait_state) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        wait_t *wait;</span><br><span class="line">        if ((wait=wait_queue_first(&amp;(sem-&gt;wait_queue)))==NULL) &#123;</span><br><span class="line">            ________;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> （1）</h3>
<p>补全程序中的空行________。</p>
<hr>
<p><code>sem-&gt;value++;</code></p>
<h3 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> （2）</h3>
<p>信号量的value值&gt;0时，表示________的数量；value值&lt;0时，表示________的数量。</p>
<hr>
<ol>
<li>剩余资源</li>
<li>等待队列中进程</li>
</ol>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p><code>local_intr_save</code>和<code>local_intr_restore</code>这两个函数的功能分别是什么？为什么要调用这两个函数？</p>
<hr>
<p>关中断和开中断；为了保证执行过程的原子性。</p>
<h2 id="四-学生看mooc同步问题15分"><a class="markdownIt-Anchor" href="#四-学生看mooc同步问题15分"></a> 四 学生看MOOC同步问题（15分）</h2>
<p>假设一个MOOC网站有1、2、3三种不同的课程视频可由学生选择学习，网站播放课程视频的规则为：</p>
<ol>
<li>任一时刻最多只能播放一种课程视频，正在播放的课程视频是自动循环播放的，最后一个学生主动离开时结束当前课程视频的播放；</li>
<li>选择当前正在播放的课程视频的学生可立即进入播放页面，允许同时有多位选择同一种课程视频的学生观看，同时观看的学生数量不受限制；</li>
<li>等待观看其它课程视频的学生按到达顺序排队，当一种新的课程视频开始放映时，所有等待观看该课程视频的学生可依次序进入播放页面同时观看。</li>
</ol>
<p>用一个进程代表一个学生，要求：用信号量的P、V操作实现上述规则，并给出信号量的<br>
定义和初始值。</p>
<hr>
<p>我认为这个问题有点像读者-写者问题。下面是我的实现方法（虽然我也觉得有一些问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#define COURSE 3</span><br><span class="line"></span><br><span class="line">semaphore mutex; // 保护互斥变量的锁</span><br><span class="line">semaphore wait[COURSE];  // 等待观看视频的学生队列</span><br><span class="line">int count[COURSE];  // 共享变量：等待/正在观看某视频的学生数量</span><br><span class="line">int cur;  // 当前正在播放的视频</span><br><span class="line"></span><br><span class="line">/* INITIALIZATION */</span><br><span class="line">void initialize() &#123;</span><br><span class="line">    mutex = new semaphore(1);</span><br><span class="line">    cur = -1;</span><br><span class="line">    for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">        wait[i] = new semaphore(0);</span><br><span class="line">        count[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Student Thread */</span><br><span class="line">void Student(int choice) &#123;</span><br><span class="line">    // 尝试开始观看</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]++;  // 更新等待人数</span><br><span class="line">    if (cur != choice) &#123;</span><br><span class="line">        if (cur &gt; 0) &#123;  // 当前播放的视频不符合要求，在期望视频的等待队列上睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">            wait[choice].P();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cur = choice;  // 当前未播放视频，直接睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        mutex.V();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Start to watch</span><br><span class="line"></span><br><span class="line">    // End watching</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]--;  // 更新等待人数</span><br><span class="line">    if (count[choice] &gt; 0) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count[choice]; i++) // 唤醒所有准备观看此视频的学生</span><br><span class="line">            wait[choice].V();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cur = -1;  // 寻找下一个播放的视频</span><br><span class="line">        for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">            if (count[i] &gt; 0) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                for (int j = 0; j &lt; count[i]; j++)</span><br><span class="line">                    wait[i].V();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学长的实现是这样的，说实话，我也不是很明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">avaid=1</span><br><span class="line">A=0,B=0,C=0</span><br><span class="line">waitA=waitB=waitC=0;</span><br><span class="line"></span><br><span class="line">观看:</span><br><span class="line">waitA+=1;</span><br><span class="line">P(avaid)</span><br><span class="line">if (countA+countB+countC==0)</span><br><span class="line"> V(A);</span><br><span class="line">V(avaid)</span><br><span class="line">P(A);</span><br><span class="line">waitA-=1;</span><br><span class="line">P(avaid)</span><br><span class="line">countA+=1;</span><br><span class="line">V(avaid)</span><br><span class="line">V(A);</span><br><span class="line"></span><br><span class="line">看完:</span><br><span class="line">P(avaid)</span><br><span class="line">countA-=1;</span><br><span class="line">if (countA==0) &#123;</span><br><span class="line"> V(avaid)</span><br><span class="line"> P(A);</span><br><span class="line"> if (waitB&gt;0) V(B);</span><br><span class="line"> else if (waitC&gt;0)  V(C);</span><br><span class="line">&#125; else</span><br><span class="line">V(avaid)</span><br></pre></td></tr></table></figure>
<h2 id="五-stride调度算法12分"><a class="markdownIt-Anchor" href="#五-stride调度算法12分"></a> 五 Stride调度算法（12分）</h2>
<p>在lab6中，我们实现了Stride Scheduling调度算法，并声称它对“进程的调度次数正比于其优先级”。对于优先级为2、3、5、7的4个进程，选取210为MAX_STRIDE，则：</p>
<ol>
<li>简要描述Stride Scheduling调度算法。</li>
<li>四个进程的步长分别为：<strong><strong><strong><strong>、</strong></strong></strong></strong>、<strong><strong><strong><strong>、</strong></strong></strong></strong>。</li>
<li>假设四个进程的初始stride值均为0，证明：总有一个时刻，四个进程的stride值都是210，且此时四个进程被调度的次数正比于其优先级。</li>
</ol>
<hr>
<p>Stride调度算法：</p>
<ul>
<li>每个进程有一个priority（优先级），pass和stride</li>
<li>stride = BigStride / priority</li>
<li>每次调度时选择pass值最小的进程，更新该进程的pass：pass += stride</li>
</ul>
<p>步长分别为105、70、42和30。</p>
<p>下列模拟过程假设在进程的pass值相等时，选择进程编号最小的执行。</p>
<p><img src="stride-sheet.png" alt="进程执行顺序表"></p>
<p><img src="stride-pass-fig.png" alt="各进程的Pass值变化过程"></p>
<p>此时，A被调度了2次，B被调度了3次，C被调度了5次，D被调度了7次，恰好与优先级成正比。之所以会这么规整，主要还是因为BigStride的值能够正好被各个优先级的值整除。</p>
<h2 id="六-银行家算法12分"><a class="markdownIt-Anchor" href="#六-银行家算法12分"></a> 六 银行家算法（12分）</h2>
<p>死锁是操作系统中资源共享时面临的一个难题。请回答下列与死锁相关的问题。</p>
<h3 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> （1）</h3>
<p>设系统中有下述解决死锁的方法：</p>
<ol>
<li>银行家算法；</li>
<li>检测死锁，终止处于死锁状态的进程，释放该进程占有的资源；</li>
<li>资源预分配。<br>
简述哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进？请按“并发性”从大到小对上述三种办法进行排序。</li>
</ol>
<hr>
<p>排序：2 &gt; 1 &gt; 3</p>
<p>原因：</p>
<ol>
<li>银行家算法每满足一个资源请求时都会进行安全状态检查。因为安全状态中实际上包含了一部分不会发生死锁的状态，所以它会拒绝一些本来可以接受的请求，所以降低了一点并发性。</li>
<li>显然在这种做法下所有进程都可以无等待地推进，直到真的出现了死锁再进行处理。</li>
<li>直觉上来说，资源预分配的并发性比银行家算法更低，因为银行家算法至少保留了一些动态性能，而资源预分配完全牺牲了动态性。</li>
</ol>
<h3 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> （2）</h3>
<p>假设一个使用银行家算法的系统，当前有5个进程P0, P1, P2, P3, P4，系统中有三类资源A、B、C，假设在某时刻有如下状态：</p>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Max矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Available向量：[1, 4, 0]</p>
<p>请问当前系统是否处于安全状态？如果系统中的可利用资源为（0, 6, 2），系统是否安全？如果系统处在安全状态，请给出安全序列；如果系统处在非安全状态，请简要说明原因。</p>
<hr>
<p>首先计算Need矩阵：Need = Max - Allocation</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>然后进行安全状态检测：</p>
<ol>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5] = [2, 7, 5]，Finish[P2] = true</li>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [2, 7, 8]，Finish[P0] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 0, 0] = [3, 7, 8]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [3, 7, 10]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [3, 7, 11]，Finish[P4] = true</li>
<li>发现系统处于安全状态。</li>
</ol>
<p>如果将Available向量修改为[0, 6, 2]，重新进行安全状态检测：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [0, 6, 5]，Finish[P0] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [0, 6, 7]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [0, 6, 5]，Finish[P4] = true</li>
<li>此时找不到满足条件的进程了，因此系统处于不安全状态。</li>
</ol>
<h2 id="七-sfs文件系统12分"><a class="markdownIt-Anchor" href="#七-sfs文件系统12分"></a> 七 SFS文件系统（12分）</h2>
<p>uCore实现了一个简单的文件系统Simple FS，假设该文件系统现已经装载到一个硬盘中（disk0），该硬盘的大小为20M，目前有三个文件A.txt，B.txt和C.txt存放在该硬盘中，三个文件的大小分别是48K，1M和4M。</p>
<h3 id="1-4"><a class="markdownIt-Anchor" href="#1-4"></a> （1）</h3>
<p>简要描述SFS文件系统中文件数据的组织结构（即：SFS文件的数据的存放位置组织方式）。</p>
<hr>
<p>以下答案来自<a href="https://github.com/chyyuu/os_course_exercise_library/blob/master/9/846.md" target="_blank" rel="noopener">os_course_exercise_library</a>，总之这个仓库让我感觉十分惊诧。</p>
<blockquote>
<p>一个superblock维护基本信息（1’），<br>
多个freemap（数量由分区大小确定，1’），<br>
一个根目录inode（1’）；<br>
目录和文件均由一个inode和具体数据块组成，其中inode包含文件的基本属性、12个直接索引和一级/二级索引表的块地址（1’），<br>
目录的数据块中存放（文件名 、inode地址）的数组（1’），<br>
文件的数据块中存放文件的具体内容（1’）。</p>
</blockquote>
<p>呃，有标答了哦。不过，要是我自己来回答，会这样说：</p>
<p><img src="disk-structure.png" alt="硬盘上按顺序排列着4类数据"></p>
<p>……然后就懒得说了，反正我还没做完Lab8，标答比我能总结出来的东西还是要强的。</p>
<h3 id="2-4"><a class="markdownIt-Anchor" href="#2-4"></a> （2）</h3>
<p>请根据Simple FS的设计实现情况，画出该文件系统当前在disk0上的布局情况，需要给出相应结构的名称和起始块号。</p>
<hr>
<p>答案来源同上。</p>
<blockquote>
<p>（除了0、1、2以外，其它块地址均可变，言之有理即可） （2分）<br>
0 superblock<br>
1 根目录inode<br>
2 freemap（640K，只需要1块）<br>
3 根目录的数据块（包含A.txt、B.txt、C.txt的inode的地址） （1分）<br>
4 A.txt的inode（包含12个直接索引块的地址）<br>
5-16 A.txt的数据块 （2分）<br>
17 B.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
18-29 B.txt的直接索引数据<br>
30 B.txt的一级间接索引（包含244个数据块地址）<br>
31-274 B.txt的一级间接索引块 （1分）<br>
275 C.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
276-287 C.txt的一级间接索引块<br>
288 C.txt的一级间接索引（包含1012个数据块地址）<br>
289-1300 C.txt的一级间接索引块</p>
</blockquote>
<p>这个硬盘的块大小是4KB（虽然不知道为什么），因此整个硬盘共有5120块，因此freemap的大小应该为5Kbit。第0块是superblock，第1块是根目录inode，第2块是freemap，用1块就够了。后面就开始链式存储具体的文件和目录内容。</p>
<ul>
<li>3：根目录的数据块</li>
<li>4：A的inode。因为A的大小为48KB，因此12个直接索引块恰好能够装下，不需要一级索引。</li>
<li>5-16：A的数据块</li>
<li>17：B的inode。因为B的大小为1M，所以需要12个直接索引、1个一级索引块和244个间接索引。</li>
<li>18-29：B的直接索引数据块</li>
<li>30：B的一级索引块</li>
<li>31-274：B的间接索引数据块</li>
<li>275：C的inode。因为C的大小为4M，所以需要12个直接索引、1个一级索引块和1012个间接索引。</li>
<li>276-287：C的直接索引数据块</li>
<li>288：C的一级索引块</li>
<li>289-1300：C的间接索引数据块</li>
</ul>
<h2 id="八-vfs文件系统12分"><a class="markdownIt-Anchor" href="#八-vfs文件系统12分"></a> 八 VFS文件系统（12分）</h2>
<p>uCore的文件管理主要由以下四个部分组成：通用文件系统访问接口层，文件系统抽象层(VFS)，具体文件系统层以及外设接口层，其中VFS层的作用是用来管理不同的文件系统并向上提供一致的接口给内核其他部分访问。在ucore中我们已经实现了一个具体的文件系统：Simple FS，并将该文件系统装载到了disk0上，假设ucore又实现了一个文件系统FAT32，并将这个新的文件系统装载到了disk1上。</p>
<h3 id="1-5"><a class="markdownIt-Anchor" href="#1-5"></a> （1）</h3>
<p>请简单描述一下如何修改VFS层的数据结构使其可以有效的管理上述已安装的具体文件系统。涉及VFS层的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;                                                   </span><br><span class="line">    bool readable;                                         </span><br><span class="line">    bool writable;   </span><br><span class="line">    int fd;                                                     </span><br><span class="line">    off_t pos;                                               </span><br><span class="line">    struct inode *node;                             </span><br><span class="line">    atomic_t open_count;                           </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">    union &#123;                                                                 </span><br><span class="line">        struct device __device_info;                   </span><br><span class="line">        struct sfs_inode __sfs_inode_info;       </span><br><span class="line">    &#125; in_info;  /* info */</span><br><span class="line">    enum &#123;</span><br><span class="line">        inode_type_device_info = 0x1234,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;  /* info */                                   </span><br><span class="line">    atomic_t ref_count;</span><br><span class="line">    atomic_t open_count;                               </span><br><span class="line">    struct fs *in_fs;                                     </span><br><span class="line">    const struct inode_ops *in_ops;                     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct fs &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct sfs_fs __sfs_info;                                     </span><br><span class="line">    &#125; fs_info; /* info */</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type; /* info */</span><br><span class="line"></span><br><span class="line">    int (*fs_sync)(struct fs *fs);                                                   </span><br><span class="line">    struct inode *(*fs_get_root)(struct fs *fs);     </span><br><span class="line">    int (*fs_unmount)(struct fs *fs);                                     </span><br><span class="line">    void (*fs_cleanup)(struct fs *fs);                                   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inode_ops &#123;</span><br><span class="line">    unsigned long vop_magic;</span><br><span class="line">    int (*vop_open)(struct inode *node, uint32_t open_flags);</span><br><span class="line">    int (*vop_close)(struct inode *node);</span><br><span class="line">    int (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_create)(struct inode *node, const char *name,</span><br><span class="line">    bool excl, struct inode **node_store);</span><br><span class="line">    int (*vop_lookup)(struct inode *node, char *path,</span><br><span class="line">    struct inode **node_store);</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>对VFS必要的修改并不多，原因很简单：这是<strong>V</strong>FS。需要在以下位置添加必要信息：</p>
<ul>
<li>在<code>inode.in_info</code>对应的匿名union中添加<code>struct fat32_inode __fat32_inode_info;</code></li>
<li>在<code>inode.in_type</code>对应的匿名<code>enum</code>中添加<code>inode_type_fat32_inode_info,</code></li>
<li>在<code>fs.fs_info</code>对应的匿名<code>union</code>中添加<code>struct fat32_fs __fat32_info;</code></li>
<li>在<code>fs.fs_type</code>对应的匿名<code>enum</code>中添加<code>fs_type_fat32_info,</code></li>
</ul>
<h3 id="3-2"><a class="markdownIt-Anchor" href="#3-2"></a> （3）</h3>
<p>两个具体文件系统均已实现了对数据文件的4种基本操作。现在有某个用户态进程执行了一个<code>copy(source_path, dest_path, ...)</code>函数，该函数是把disk1根目录下的一个文件A.txt拷贝到了disk0的根目录下（不用考虑文件的大小），请结合ucore中对数据文件的操作流程描述一下这个函数的执行过程。</p>
<hr>
<p>以下内容来自学长答案。</p>
<ol>
<li>根据源文件目录调用<code>vop_lookup</code>查找文件的inode，这将调用FAT32的查找实现</li>
<li>根据目的文件路径调用<code>vop_lookup</code>查找文件的inode，这将调用SFS的查找实现</li>
<li>判断合法性</li>
<li>可能需要创建文件</li>
<li>open文件</li>
<li>建立buffer，对A调用<code>vop_read</code>，对B调用<code>vop_write</code></li>
<li>关闭文件</li>
</ol>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-ucore-lab-4-report/">
              
                  《操作系统》ucore实验四“内核线程管理”报告
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h2>
<ul>
<li>了解内核线程创建/执行的管理过程</li>
<li>了解内核线程的切换和基本调度过程</li>
</ul>
<h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<p>实验2/3完成了物理和虚拟内存管理，这给创建内核线程（ 内核线程是一种特殊的进程） 打下了提供内存管理的基础。当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（ 这里用线程或进程表示） “感到”它们各自拥有“自己”的CPU。</p>
<p>本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li>内核线程只运行在内核态</li>
<li>用户进程会在在用户态和内核态交替运行</li>
<li>所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间</li>
<li>而用户进程需要维护各自的用户内存空间</li>
</ul>
<p>相关原理介绍可看附录B：【原理】进程/线程的属性与特征解析。</p>
<h3 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h3>
<p>本实验依赖实验1/2/3。请把你做的实验1/2/3的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。</p>
<hr>
<ul>
<li>Lab1：
<ul>
<li><code>kdebug.c:print_stackframe</code></li>
<li><code>trap.c:idt_init</code></li>
<li><code>trap.c:trap_dispatch</code></li>
</ul>
</li>
<li>Lab2：
<ul>
<li><code>default_pmm.c:default_init</code></li>
<li><code>default_pmm.c:default_init_memmap</code></li>
<li><code>default_pmm.c:default_alloc_pages</code></li>
<li><code>default_pmm.c:default_free_pages</code></li>
<li><code>pmm.c:get_pte</code></li>
<li><code>pmm.c:page_remove_pte</code></li>
</ul>
</li>
<li>Lab3：
<ul>
<li><code>vmm.c:do_pgfault</code></li>
<li><code>swap_fifo.c:__fifo_map_swappable</code></li>
<li><code>swap_fifo.c:__fifo_swap_out_victim</code></li>
</ul>
</li>
</ul>
<h3 id="练习1分配并初始化一个进程控制块需要编码"><a class="markdownIt-Anchor" href="#练习1分配并初始化一个进程控制块需要编码"></a> 练习1：分配并初始化一个进程控制块（需要编码）</h3>
<p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p>
<blockquote>
<p>【提示】在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括：state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。</p>
</blockquote>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请说明<code>proc_struct</code>中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</li>
</ul>
<hr>
<h4 id="11-具体实现"><a class="markdownIt-Anchor" href="#11-具体实现"></a> 1.1 具体实现</h4>
<p>注释中给出了以下域的说明，其中有些是不需要在这个函数中进行分配的：</p>
<ul>
<li><code>enum proc_state state</code>：表示进程状态，在此函数中应赋值为<code>PROC_UNINIT</code>，表示该进程的初始化尚未完成（对进程状态的修改在<code>do_fork</code>函数的最后，通过调用<code>sched.c:wakeup_proc</code>函数完成）</li>
<li><code>int pid</code>：初始赋值为-1，表示尚未分配（<code>pid</code>在<code>do_fork</code>函数中通过调用<code>get_pid</code>进行分配）</li>
<li><code>int runs</code>：已运行次数，此处赋值为0</li>
<li><code>uintptr_t kstack</code>：内核堆栈起始地址，此时堆栈尚未分配，因此置为0；实际在<code>do_fork</code>函数中通过调用<code>setup_kstack</code>进行分配</li>
<li><code>volatile bool need_resched</code>：当前进程是否需要调度；初始化为不需要（0）</li>
<li><code>struct proc_struct *parent</code>：当前进程的父进程，初始化为<code>NULL</code>；在<code>do_fork</code>中初始化为调用<code>do_fork</code>的当前进程</li>
<li><code>struct mm_struct *mm</code>：内存管理，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_mm</code>进行初始化（虽然实际上直接使用了内核的mm，因为是内核线程）</li>
<li><code>struct context context</code>：在Lab5中发现context需要清零，但在此处似乎不初始化也能正常运行；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>struct trapframe *tf</code>：当前的中断帧，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>uintptr_t cr3</code>：当前进程的页表基地址；直接初始化为kernel的页表基地址<code>boot_cr3</code></li>
<li><code>uint32_t flags</code>：当前进程属性，因为是初始化，所以置为0了</li>
<li><code>char name[PROC_NAME_LEN + 1]</code>：进程的名称，此处初始化似乎不是很重要，不过还是清零了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="line">static struct proc_struct *</span><br><span class="line">alloc_proc(void) &#123;</span><br><span class="line">    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));</span><br><span class="line">    if (proc != NULL) &#123;</span><br><span class="line">    //LAB4:EXERCISE1 YOUR CODE</span><br><span class="line">    	proc-&gt;state = PROC_UNINIT;  // 正在创建和初始化状态中</span><br><span class="line">    	proc-&gt;pid = -1;  // 参考了答案：未初始化的进程id为-1</span><br><span class="line">    	proc-&gt;runs = 0;  // 还没有运行过</span><br><span class="line">    	proc-&gt;kstack = 0;  // 参考了答案：初始化内核堆栈似乎是在do_fork()中进行的？</span><br><span class="line">    	proc-&gt;need_resched = 0;  // 初始化为不需要调度</span><br><span class="line">    	proc-&gt;parent = NULL;</span><br><span class="line">    	proc-&gt;mm = NULL;  // 之后也不会分配，因为都是内核态线程，所以直接使用内核的mm</span><br><span class="line">    	memset(&amp;(proc-&gt;context), 0, sizeof(struct context));  // 在LAB5中发现，忘了清零context了</span><br><span class="line">    	// proc-&gt;tf = kmalloc(sizeof(struct trapframe));  // tf似乎不需要在此处设置</span><br><span class="line">    	proc-&gt;cr3 = boot_cr3;  // 参考了答案：内核态线程不需要分配新的页表地址；这对于正确执行是必需的</span><br><span class="line">    	proc-&gt;flags = 0;  // 参考了答案：标志位置为0</span><br><span class="line">    	memset(proc-&gt;name, 0, PROC_NAME_LEN);  // 参考了答案：将进程名清零，不过不是必需的</span><br><span class="line">    &#125;</span><br><span class="line">    return proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-context和trapframe的含义和用途"><a class="markdownIt-Anchor" href="#12-context和trapframe的含义和用途"></a> 1.2 <code>context</code>和<code>trapframe</code>的含义和用途</h4>
<p>实验指导书中指出：</p>
<ul>
<li><code>context</code>：进程的上下文，用于进程切换（参见<code>switch.S</code>）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用<code>context</code>保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用<code>context</code>进行上下文切换的函数是<code>kern/process/switch.S:switch_to</code></li>
<li><code>tf</code>：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时<code>tf</code>总是能够指向当前的<code>trapframe</code>，uCore 在内核栈上维护了<code>tf</code>的链，可以参考<code>trap.c::trap</code>函数做进一步的了解。</li>
</ul>
<p>经过阅读代码，我认为，<code>switch_to</code>的主要工作是把被切换的进程的各个通用寄存器（eip、esp、ebx、ecx、edx、esi、edi、ebp，但不包括段寄存器，因为kernel进程使用的段是相同的）保存到进程的<code>context</code>结构中，然后加载即将开始运行的进程的<code>context</code>结构中保存的通用寄存器。而<code>trapframe</code>就是我们在Lab1中已经了解的中断保存现场。对于内核线程，<code>trapframe</code>的意义似乎并不大，因为不需要进行用户空间到内核空间的切换。</p>
<hr>
<p>今天我的某个叫wenj的同学指出了一个很有趣的问题，这使得我重新翻出了实验报告：<code>context</code>和<code>trapframe</code>中为何都存储了EIP？这两种结构的功能是否重复了？翻了翻实验指导书，发现其实这个问题已经有比较明确的解答了：<code>trapframe</code>一般来说是用户态切换到内核态用的，而<code>context</code>是内核态自己切换上下文用的（因为特权级不变，所以不需要存储页表基地址、段寄存器等内容）；不过用户态跳转到内核态的时候也需要保存<code>context</code>中的通用寄存器，因为<code>trapframe</code>不存通用寄存器。</p>
<p>以及，lab4中构建进程的过程是这样的：</p>
<ul>
<li>“硬”构造出第一个内核线程idleproc</li>
<li>调用<code>do_fork</code>函数，fork idleproc，生成initproc</li>
</ul>
<p>事实上initproc返回时会假装自己是通过系统调用<code>do_fork</code>生成的，所以返回过程会比较复杂：</p>
<blockquote>
<p>uCore会执行进程切换，让initproc执行。在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>，这样，当执行<code>switch_to</code>函数并返回后，initproc将执行其实际上的执行入口地址forkret。而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行，具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line"># restore registers from stack</span><br><span class="line">popal</span><br><span class="line"># restore %ds and %es</span><br><span class="line">popl %es</span><br><span class="line">popl %ds</span><br><span class="line"># get rid of the trap number and error code</span><br><span class="line">addl $0x8, %esp</span><br><span class="line">iret</span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line"># set stack to this new process&apos;s trapframe</span><br><span class="line">movl 4(%esp), %esp //把esp指向当前进程的中断帧</span><br><span class="line">jmp __trapret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，forkrets函数首先把esp指向当前进程的中断帧，从_trapret开始执行到iret前，esp指向了current-&gt;tf.tf_eip，而如果此时执行的是initproc，则current-&gt;tf.tf_eip=kernel_thread_entry，initproc-&gt;tf.tf_cs = KERNEL_CS，所以当执行完iret后，就开始在内核中执行kernel_thread_entry函数了，而initproc-&gt;tf.tf_regs.reg_ebx = init_main，所以在kernl_thread_entry中执行“call %ebx”后，就开始执行initproc的主体了。Initprocde的主体函数很简单就是输出一段字符串，然后就返回到kernel_tread_entry函数，并进一步调用do_exit执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。至此，实验四中的主要工作描述完毕。</p>
</blockquote>
<h3 id="练习2为新创建的内核线程分配资源需要编码"><a class="markdownIt-Anchor" href="#练习2为新创建的内核线程分配资源需要编码"></a> 练习2：为新创建的内核线程分配资源（需要编码）</h3>
<p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号<br>
请在实验报告中简要说明你的设计实现过程。请回答如下问题：</li>
<li>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</li>
</ul>
<hr>
<h4 id="21-具体代码实现"><a class="markdownIt-Anchor" href="#21-具体代码实现"></a> 2.1 具体代码实现</h4>
<p>函数的大致执行步骤与题目中列出的相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) &#123;</span><br><span class="line">    int ret = -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    //    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    if (proc == NULL) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;  // 参考了答案</span><br><span class="line">    //    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">    if (setup_kstack(proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    //    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">    // CLONE_VM表示分享；实际上因为都在内核态所以什么都没做，只是assert NULL了</span><br><span class="line">    if (copy_mm(clone_flags, proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    //    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">    copy_thread(proc, stack, tf);</span><br><span class="line">    //    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">    // 参考了答案：关中断的原因是，进程号要求唯一性，此操作需要为原子操作，防止被打断而重复添加</span><br><span class="line">    // 所以参考答案是很有必要的。但是我认为在实验指导书中也应该说明一下。</span><br><span class="line">    bool intr_flag;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">    	proc-&gt;pid = get_pid();</span><br><span class="line">		hash_proc(proc);</span><br><span class="line">		nr_process++;  // 参考答案添加在此处（我本来以为用了get_pid()就不需要这句了</span><br><span class="line">		list_add_before(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">    //    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    //    7. set ret vaule using child proc&apos;s pid</span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-能否为每个新线程赋值唯一id"><a class="markdownIt-Anchor" href="#22-能否为每个新线程赋值唯一id"></a> 2.2 能否为每个新线程赋值唯一ID</h4>
<p>阅读代码可以得知，<code>idleproc</code>的PID是由<code>proc_init</code>函数设置的，但<code>initproc</code>的PID应该怎么设置呢？我的解决方法是把分配PID的过程移到<code>do_fork</code>函数中，这样至少能通过测试了。参考答案的做法也类似，不过在分配PID和将进程插入队列的过程中进行了关中断处理，保证原子操作。</p>
<p>PID的唯一性是通过关中断和<code>get_pid</code>函数保证的，该函数查看当前的全部进程，在不发生中断的情况下，可以保证新分配的PID与之前的PID是不冲突的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// get_pid - alloc a unique pid for process</span><br><span class="line">static int</span><br><span class="line">get_pid(void) &#123;</span><br><span class="line">    static_assert(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    list_entry_t *list = &amp;proc_list, *le;</span><br><span class="line">    static int next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    if (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = 1;</span><br><span class="line">        goto inside;</span><br><span class="line">    &#125;</span><br><span class="line">    if (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = list;</span><br><span class="line">        while ((le = list_next(le)) != list) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            if (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                if (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    if (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    goto repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"><a class="markdownIt-Anchor" href="#练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"></a> 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）</h3>
<p>请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题：</p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用？请说明理由。</li>
</ul>
<p>完成代码编写后，编译并运行代码：<code>make qemu</code></p>
<p>如果可以得到如附录A所示的显示内容（仅供参考，不是标准答案输出），则基本正确。</p>
<hr>
<h4 id="31-内核线程"><a class="markdownIt-Anchor" href="#31-内核线程"></a> 3.1 内核线程</h4>
<p>分析一下<code>proc_init</code>函数的调用过程：</p>
<ul>
<li>初始化<code>proc_list</code>和<code>hash_list</code></li>
<li>调用<code>alloc_proc</code>函数分配<code>idleproc</code>所需的TCB块，检验是否分配成功</li>
<li>对<code>idleproc</code>进行基本设置（所以<code>alloc_proc</code>函数其实不需要干啥？）：
<ul>
<li>PID=0</li>
<li>state=PROC_RUNNABLE</li>
<li>kstack=bootstack</li>
<li>need_resched=1</li>
<li>name=“idle”</li>
</ul>
</li>
<li>将<code>current</code>变量置为<code>idleproc</code></li>
<li>调用<code>kernel_thread</code>函数，用<code>init_main</code>函数创建一个内核线程
<ul>
<li>创建所需的<code>trapframe</code></li>
<li>调用<code>do_fork</code>函数，创建新进程
<ul>
<li>调用<code>alloc_proc</code>，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
</li>
</ul>
</li>
<li>验证创建<code>initproc</code>线程成功（PID不为0）</li>
</ul>
<p><code>proc_init</code>函数是由<code>kern_init</code>函数调用的。在<code>kern_init</code>完成其余初始化之后，它调用<code>cpu_idle</code>函数，使得当前的<code>idle_proc</code>进程让出控制权，交给<code>initproc</code>线程，进行上下文的切换；执行完之后，回到<code>kernel_thread_entry</code>，退出。</p>
<p>由以上分析可知，在本实验的执行过程中，一共只创建了两个内核线程（<code>idleproc</code>和<code>initproc</code>）。</p>
<h4 id="32-关中断的必要性"><a class="markdownIt-Anchor" href="#32-关中断的必要性"></a> 3.2 关中断的必要性</h4>
<p>以下回答来自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=309" target="_blank" rel="noopener">Piazza</a>：</p>
<blockquote>
<p>由于进程号要求唯一性，进程号分配时可能需要查看进程列表中全部进程以避免发生冲突。若进程号已分配而进程尚未添加进进程列表时被中断，则该进程号可能会被重复分配，故进程号分配与进程添加应为原子操作。因而在进行上述操作时需关闭中断。</p>
</blockquote>
<h3 id="33-proc_run函数如何完成进程切换"><a class="markdownIt-Anchor" href="#33-proc_run函数如何完成进程切换"></a> 3.3 <code>proc_run</code>函数如何完成进程切换</h3>
<p>对进程切换的控制是通过<code>sched.c:schedule</code>函数完成的。一旦当前进程的<code>need_resched</code>变量被置为1，就调用<code>schedule</code>函数选择下一个要运行的进程，调用<code>proc_run</code>函数开始运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">schedule(void) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    list_entry_t *le, *last;</span><br><span class="line">    struct proc_struct *next = NULL;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = 0;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line">        do &#123;</span><br><span class="line">            if ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                if (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (le != last);</span><br><span class="line">        if (next == NULL || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        if (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就进入了<code>proc_run</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc != current) &#123;</span><br><span class="line">        bool intr_flag;</span><br><span class="line">        struct proc_struct *prev = current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的执行过程如下：</p>
<ol>
<li>关闭中断，保证原子操作</li>
<li>调用<code>load_esp0</code>函数，设置任务状态段<code>ts</code>中特权态0下的栈顶指针<code>esp0</code>为要切换到的内核线程的内核栈的栈顶，即<code>next-&gt;kstack + KSTACKSIZE</code>（建立指针的目的是，进行特权态切换时能够正确定位处于特权态0时进程的内核栈的栈顶）</li>
<li>设置CR3寄存器的值为要切换到的内核线程的页目录表起始地址，这实际上是完成进程间的页表切换，不过在内核中的内存切换下其实用不到</li>
<li>由 <code>switch_to</code>函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当<code>switch_to</code>函数执行完<code>ret</code>指令后，就切换到 <code>initproc</code>执行了</li>
</ol>
<p>在切换现场时，倒数第二条汇编指令<code>pushl 0(%eax)</code>其实把<code>context</code>中保存的下一个进程要执行的指令地址<code>context.eip</code>放到了堆栈顶，这样接下来执行最后一条指令<code>ret</code>时，会把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了。</p>
<p>事实上，在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>（见<code>copy_thread</code>函数），这样，当执行<code>switch_to</code>函数并返回后，将进入实际的执行入口地址<code>forkret</code>。而<code>forkret</code>会调用位于<code>kern/trap/trapentry.</code>S中的<code>forkrets</code>（参数是切换之后的进程的中断帧地址，该地址位于内核中线程对应的栈中，如果我没理解错的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&apos;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>forkrets</code>函数首先把<code>esp</code>指向当前进程的中断帧，然后跳转到<code>__trapret</code>，从中恢复中断帧的各个寄存器。这些寄存器是在<code>kernel_thread</code>函数中设置的，包括：</p>
<ul>
<li><code>tf.tf_cs = KERNEL_CS</code>：和内核使用同一代码段（这是合理的，因为<code>initproc</code>对应的代码也是内核的一部分）</li>
<li><code>tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS</code>：和内核使用同一数据（堆栈）段</li>
<li><code>tf.tf_regs.reg_ebx = (uint32_t)fn</code>：寄存器中的<code>ebx</code>为函数起始地址</li>
<li><code>tf.tf_regs.reg_edx = (uint32_t)arg</code>：寄存器中的<code>edx</code>指向函数参数地址</li>
<li><code>tf.tf_eip = (uint32_t)kernel_thread_entry</code>：中断后的实际起始地址是<code>kernel_thread_entry</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>对于<code>initproc</code>，<code>current-&gt;tf.tf_eip=kernel_thread_entry</code>，<code>initproc-&gt;tf.tf_cs = KERNEL_CS</code>，所以执行完<code>iret</code>后，就开始在内核中执行<code>kernel_thread_entry</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread</span><br></pre></td></tr></table></figure>
<p>首先把进程的参数入栈，然后调用起始地址（现在是实际的起始地址了，对于<code>initproc</code>，这个起始地址就是<code>init_main</code>函数的开头）。所以执行<code>call %ebx</code>后，就开始执行<code>initproc</code>的主体了。</p>
<p>执行结束后，返回到<code>kernel_tread_entry</code>函数，它会进一步调用<code>proc.c:do_exit</code>函数，执行退出操作。目前这个函数除了打印一点字符串没有做别的工作。</p>
<h3 id="扩展练习challenge实现支持任意大小的内存分配算法"><a class="markdownIt-Anchor" href="#扩展练习challenge实现支持任意大小的内存分配算法"></a> 扩展练习Challenge：实现支持任意大小的内存分配算法</h3>
<p>这不是本实验的内容，其实是上一次实验内存的扩展，但考虑到现在的slab算法比较复杂，有必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的slab如何调用基于页的内存分配算法（注意，不是要你关注slab的具体实现）来实现first-fit/best-fit/worst-fit/buddy等支持任意大小的内存分配算法。</p>
<p>【注意】下面是相关的Linux实现文档，供参考<br>
SLOB<br>
<a href="http://en.wikipedia.org/wiki/SLOB" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SLOB</a> <a href="http://lwn.net/Articles/157944/" target="_blank" rel="noopener">http://lwn.net/Articles/157944/</a><br>
SLAB<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></p>
<hr>
<p>没写。</p>
<h2 id="分析参考答案"><a class="markdownIt-Anchor" href="#分析参考答案"></a> 分析参考答案</h2>
<ul>
<li><code>alloc_proc</code>：和参考答案的实现类似，参考了答案中的一些我忘了写的部分，如初始化内核堆栈和将context清零</li>
<li><code>do_fork</code>：参考了答案，添加了一些错误处理，以及分配pid时关中断</li>
</ul>
<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点</h2>
<ul>
<li>进程状态</li>
<li>进程控制块</li>
<li>内核栈和用户栈</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/ucore/"><i class="fas fa-hashtag fa-fw"></i>ucore</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2015-final-exam-analysis/">
              
                  《操作系统》2015年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href></a>。这个卷子实在过于长了，不仅莫名有一个完整的缓冲区问题的实现，还有一堆ucore代码需要阅读和填空。</p>
<h2 id="一10分"><a class="markdownIt-Anchor" href="#一10分"></a> 一（10分）</h2>
<p>在用<code>do_execve</code>启动一个用户态进程时，ucore需要完成很多准备工作，这些工作有的在内核态完成，有的在用户态完成。请判断下列事项是否是ucore在正常完成<code>do_execve</code>中所需要的，如果是，指出它完成于内核态还是用户态（通过修改<code>trapframe</code>，在<code>iret</code>时改变寄存器的过程被认为是在内核态完成）。</p>
<ol>
<li>初始化进程所使用的栈</li>
<li>在栈上准备argc和argv的内容</li>
<li>将argc和argv作为用户main函数的参数放到栈上</li>
<li>设置EIP为用户main函数的地址</li>
<li>设置系统调用的返回值</li>
</ol>
<hr>
<ol>
<li>需要；内核态</li>
<li>需要；内核态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li>不需要</li>
</ol>
<p>这个题出的很没有意义啊，系统调用返回之后几乎就要立即跳转到用户进程指令的第一条了。</p>
<p>以下内容摘自ucore docs Lab5：</p>
<blockquote>
<p>最终通过<code>do_execve</code>函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
</blockquote>
<ul>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。<br>
……<br>
load_icode函数的工作：</li>
</ul>
<ol>
<li>初始化mm</li>
<li>分配和设置页目录表</li>
<li>解析ELF文件，建立vma，初始化进程的用户态虚拟地址空间</li>
<li>分配物理内存空间，建立页表映射关系，拷贝程序内容</li>
<li>设置用户栈</li>
<li>将页目录表基地址加载到CR3寄存器中</li>
<li>重设进程中断帧，准备切换到用户态<br>
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句） 后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。</li>
</ol>
<p>2018.5.25 UPD：<br>
tsz同学指出，事实上这道题和第六大题的代码内容直接相关。从中可以看出，<code>user/libs/initcode.S</code>做的就是在用户态为<code>main</code>函数设置参数的工作。所以3和4的答案应该修改一下。事实证明，想当然是不好的。</p>
<h2 id="二-vsfs18分"><a class="markdownIt-Anchor" href="#二-vsfs18分"></a> 二 VSFS（18分）</h2>
<p>这道题和<a href="/post/os-mooc-final-exam-analysis">MOOC期末考试题</a>中的第20题一模一样，所以略。</p>
<h2 id="三-进程状态变化16分"><a class="markdownIt-Anchor" href="#三-进程状态变化16分"></a> 三 进程状态变化（16分）</h2>
<p>在ucore中<code>enum proc_state</code>的定义包含以下四个值：</p>
<ul>
<li><code>PROC_UNINIT</code></li>
<li><code>PROC_SLEEPING</code></li>
<li><code>PROC_RUNNABLE</code></li>
<li><code>PROC_ZOMBIE</code><br>
请解释每一种状态的含义，以及各状态之间可能的迁移。</li>
</ul>
<hr>
<ul>
<li><code>PROC_UNINIT</code>：刚申请完进程控制块，进程还未被初始化</li>
<li><code>PROC_SLEEPING</code>：进程处于等待状态</li>
<li><code>PROC_RUNNABLE</code>：进程处于就绪或运行状态</li>
<li><code>PROC_ZOMBIE</code>：僵尸状态，进程已经退出，等待父进程进一步回收资源</li>
</ul>
<p>以下内容（进程的正常生命周期）摘自ucore docs Lab6：</p>
<blockquote>
<p>进程的正常生命周期如下：</p>
</blockquote>
<ul>
<li>进程首先在cpu初始化或者<code>sys_fork</code>的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入<code>uninit</code>态(在<code>proc.c</code>中<code>alloc_proc</code>)。</li>
<li>当进程完全完成初始化之后，该进程转为<code>runnable</code>态。</li>
<li>当到达调度点时，由调度器<code>sched_class</code>根据运行队列<code>rq</code>的内容来判断一个进程是否应该被运行，即把处于<code>runnable</code>态的进程转换成<code>running</code>状态，从而占用CPU执行。</li>
<li><code>running</code>态的进程通过<code>wait</code>等系统调用被阻塞，进入<code>sleeping</code>态。</li>
<li><code>sleeping</code>态的进程被<code>wakeup</code>变成<code>runnable</code>态的进程。</li>
<li><code>running</code>态的进程主动<code>exit</code>变成<code>zombie</code>态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为<code>unused</code>。</li>
<li>所有从<code>runnable</code>态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ul>
<p>以下内容摘自<a href="https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-4/process_status_change.html" target="_blank" rel="noopener">进程运行状态转变过程</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process state changing:</span><br><span class="line"></span><br><span class="line">  alloc_proc                                 RUNNING</span><br><span class="line">      +                                   +--&lt;----&lt;--+</span><br><span class="line">      +                                   + proc_run +</span><br><span class="line">      V                                   +--&gt;----&gt;--+</span><br><span class="line">PROC_UNINIT -- proc_init/wakeup_proc --&gt; PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --&gt; PROC_SLEEPING --</span><br><span class="line">                                           A      +                                                           +</span><br><span class="line">                                           |      +--- do_exit --&gt; PROC_ZOMBIE                                +</span><br><span class="line">                                           +                                                                  +</span><br><span class="line">                                           -----------------------wakeup_proc----------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="四-stride调度算法15分"><a class="markdownIt-Anchor" href="#四-stride调度算法15分"></a> 四 Stride调度算法（15分）</h2>
<p>假设在lab6测试stride scheduling的过程中，采用如下默认配置：BigStride为0x7FFFFFFF，CPU时间片为50ms，测试过程包含五个进程，其初始<del>stride</del>pass均为1，优先级分别为1、2、3、4、5，测试时间为10s。下面给出了五种修改上述配置的方式，试讨论：对于每一种改动，测试结果相比改动之前是否会发生明显的变化？如果是，结果会变得更接近于理想情况，还是远离理想情况？</p>
<ol>
<li>BigStride改为120</li>
<li>CPU时间片改为5ms</li>
<li>五个进程的初始pass改为100</li>
<li>五个进程的优先级设为2、4、6、8、10</li>
<li>测试时间延长到20s</li>
</ol>
<hr>
<p>在测试时间10s的情况下，时间片总个数为200。</p>
<ol>
<li>如果将BigStride改为120，则stride最大为120，不会溢出，而且120能够整除1、2、3、4、5，更能够保证进程的pass按优先级推进，因此会更接近于理想情况</li>
<li>时间片总个数变成2000，因为进程stride有偏差，因此会远离理想情况</li>
<li>因为100这个值相比各个进程的stride太小了，所以应该不会有明显变化</li>
<li>不会有明显变化</li>
<li>同2，更远离理想情况</li>
</ol>
<p>这个题目中不同学长的答案大相径庭，所以我选了一种我觉得合理的。事实上，Stride调度算法的论文中讨论了一下误差问题：在stride和优先级精确地成反比的情况下，各个线程之间按比例分配到的时间片数量的误差不超过1，也就是说，总误差是O(nc)（nc是线程数量）。所以大概stride计算不准确造成的影响是比较大的。</p>
<h2 id="五-生产者-消费者问题10分"><a class="markdownIt-Anchor" href="#五-生产者-消费者问题10分"></a> 五 生产者-消费者问题（10分）</h2>
<p>生产者-消费者问题是指，一组生产者进程和一组消费者进程共享一个初始为空、大小为3（不如说是BUFFER_SIZE）的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个生产者放入消息，或者一个消费者从中取出消息。</p>
<p>下面是生产者-消费者问题的一个实现和测试结果。请回答下面问题：</p>
<ol>
<li>请用伪码给出信号量的PV操作实现。</li>
<li>这个实现正确吗？如果不正确，给出你的正确实现。</li>
<li>这两个测试用例能发现该实现中的可能错误吗？如果不能，请给出你的尽可能完整的测试用例。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">==== producer-consumer.cpp ====</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;new&gt; // ::operator new[]</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define BUFFER_SIZE 3</span><br><span class="line">#define SLEEP_SPAN 5</span><br><span class="line">#define WORK_SPAN 4</span><br><span class="line"></span><br><span class="line">#define PRODUCER 0</span><br><span class="line">#define CONSUMER 1</span><br><span class="line"></span><br><span class="line">int iflag = 0;</span><br><span class="line">int oflag = 0;</span><br><span class="line">sem_t empty, full, mutex;</span><br><span class="line">int empty_count, full_count;</span><br><span class="line">int data_num = 0;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">int buffer[BUFFER_SIZE] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int p_task_done = -1;</span><br><span class="line">int c_task_done = -1;</span><br><span class="line"></span><br><span class="line">struct arg_struct &#123;</span><br><span class="line">    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent) &#123;&#125;</span><br><span class="line">    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&quot;&quot;)) &#123;&#125;</span><br><span class="line">    int id;</span><br><span class="line">    int start;</span><br><span class="line">    int work;</span><br><span class="line">    string indent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void* producer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;empty);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    int time = rand() % SLEEP_SPAN;</span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    p_task_done++;</span><br><span class="line">    printf(&quot;%sProd %d\n&quot;, indent, p_task_done);</span><br><span class="line"></span><br><span class="line">    buffer[iflag] = p_task_done;</span><br><span class="line"></span><br><span class="line">    if (empty_count == 0) printf(&quot;Error: Produce while no empty\n&quot;);</span><br><span class="line">    iflag = (iflag + 1) % BUFFER_SIZE;</span><br><span class="line">    empty_count--;</span><br><span class="line">    full_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;full);</span><br><span class="line">    printf(&quot;%srFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* consumer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line">    sem_wait(&amp;full);</span><br><span class="line">    printf(&quot;%saFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    ++c_task_done;</span><br><span class="line">    if (full_count == 0) printf(&quot;Error: Consume while no full\n&quot;);</span><br><span class="line"></span><br><span class="line">    int tmp = buffer[oflag];</span><br><span class="line">    printf(&quot;%sCons %d\n&quot;, indent, tmp);</span><br><span class="line"></span><br><span class="line">    oflag = (oflag + 1) % BUFFER_SIZE;</span><br><span class="line">    if (c_task_done != tmp) printf(&quot;Error: Consume data wrong\n&quot;);</span><br><span class="line">    if (c_task_done &gt; p_task_done) printf(&quot;Error: Over-consume!\n&quot;);</span><br><span class="line"></span><br><span class="line">    full_count--;</span><br><span class="line">    empty_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;empty);</span><br><span class="line">    printf(&quot;%srEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define N 3</span><br><span class="line">void testcase_producer_consumer(int ThreadNumber, int inst[2 * N][3]) &#123;</span><br><span class="line">    pthread_t * p_consumer = new pthread_t[ThreadNumber];</span><br><span class="line">    pthread_t * p_producer = new pthread_t[ThreadNumber];</span><br><span class="line"></span><br><span class="line">    int c_count = 0, p_count = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;testcase_producer_consumer:\n&quot;);</span><br><span class="line">    /* For managed creation of &apos;ThreadNumber&apos; threads */</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    /* Print the first line */</span><br><span class="line">    int tmp_c = 0, tmp_p = 0;</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER) &#123;</span><br><span class="line">            printf(&quot;P%d\t&quot;, tmp_p++);</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER) &#123;</span><br><span class="line">            printf(&quot;C%d\t&quot;, tmp_c++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* Create Producers and Consumers according to $inst*/</span><br><span class="line">    int rc;</span><br><span class="line">    string indent(&quot;&quot;);</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER)  &#123;</span><br><span class="line">            rc = pthread_create(p_producer + p_count, NULL, producer, new arg_struct(p_count, inst[i][1],</span><br><span class="line">            inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            p_count++;</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER)&#123;</span><br><span class="line">            rc = pthread_create(p_consumer + c_count, NULL, consumer, new arg_struct(c_count, inst[i][1],             inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            c_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        indent += &apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* wait until every thread finishes*/</span><br><span class="line">    for (int i = 0; i &lt; p_count; i++) &#123;</span><br><span class="line">        pthread_join(p_producer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; c_count; i++) &#123;</span><br><span class="line">        pthread_join(p_consumer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] p_producer;</span><br><span class="line">    delete[] p_consumer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line"></span><br><span class="line">    memset(buffer, 0, sizeof(int) * BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex, 0, 1);</span><br><span class="line">    sem_init(&amp;empty, 0, BUFFER_SIZE);</span><br><span class="line">    sem_init(&amp;full, 0, 0);</span><br><span class="line"></span><br><span class="line">    empty_count = BUFFER_SIZE;</span><br><span class="line">    full_count = 0;</span><br><span class="line"></span><br><span class="line">    /* For managed creation of 2 * N threads */</span><br><span class="line">    int ThreadNumber = 2 * N ;</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    int inst[2 * N][3] = &#123;</span><br><span class="line">        /* &#123; Consumer or Producer to be create?,</span><br><span class="line">        When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">        How long does it work after it enters critical zone? &#125; */</span><br><span class="line">        &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst);</span><br><span class="line">    st_time = 0;</span><br><span class="line"></span><br><span class="line">    int inst2[2 * N][3] = &#123;</span><br><span class="line">        &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例的执行输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">xyong@ubuntu-xyong:~/work$ gcc producer-consumer.cpp -lpthread -lstdc++</span><br><span class="line">xyong@ubuntu-xyong:~/work$ ./a.out</span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">C0    C1    C2    P0    P1    P2</span><br><span class="line">START</span><br><span class="line">      START</span><br><span class="line">            START</span><br><span class="line">                  START</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  aEMPTY</span><br><span class="line">                  ENTER</span><br><span class="line">                  Prod 0</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rFULL</span><br><span class="line">aFULL</span><br><span class="line">aMUTEX</span><br><span class="line">ENTER</span><br><span class="line">                        START</span><br><span class="line">Cons 0</span><br><span class="line">EXIT</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">rMUTEX</span><br><span class="line">rEMPTY</span><br><span class="line">                        Prod 1</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">      aFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      ENTER</span><br><span class="line">      Cons 1</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 2</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">            aFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">            Cons 2</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line"></span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">P0    P1    C0    C1    P2    C2</span><br><span class="line">START</span><br><span class="line">aMUTEX</span><br><span class="line">aEMPTY</span><br><span class="line">ENTER</span><br><span class="line">      START</span><br><span class="line">Prod 3</span><br><span class="line">EXIT</span><br><span class="line">rMUTEX</span><br><span class="line">rFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      aEMPTY</span><br><span class="line">      ENTER</span><br><span class="line">            START</span><br><span class="line">            aFULL</span><br><span class="line">      Prod 4</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">                  START</span><br><span class="line">                  aFULL</span><br><span class="line">            Cons 3</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  ENTER</span><br><span class="line">                  Cons 4</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 5</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">                              START</span><br><span class="line">                              aFULL</span><br><span class="line">                              aMUTEX</span><br><span class="line">                              ENTER</span><br><span class="line">                              Cons 5</span><br><span class="line">                              EXIT</span><br><span class="line">                              rMUTEX</span><br><span class="line">                              rEMPTY</span><br><span class="line">xyong@ubuntu-xyong:~/work$</span><br></pre></td></tr></table></figure>
<hr>
<p>这道题真是又臭又长……</p>
<p>信号量PV操作的伪代码：这个是十分简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P() &#123;</span><br><span class="line">    sem--;</span><br><span class="line">    if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    if (sem &lt;= 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是否正确？答案是不正确。producer线程的实现中获取<code>mutex</code>和<code>empty</code>信号量的顺序反了。总的来说，把这两个换一下就好了。</p>
<p>题目中给出的两个测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int inst[2 * N][3] = &#123;</span><br><span class="line">    /* &#123; Consumer or Producer to be create?,</span><br><span class="line">    When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">    How long does it work after it enters critical zone? &#125; */</span><br><span class="line">    &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我给出的测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目中并没有要求Producer和Consumer的数量必须为3个。从理论上来说，只要Producer比Consumer大的个数在3个（也就是缓冲区的大小）以内，都能正常结束。但是在错误实现中会发生这样的问题：P1-P3生产完之后，P4获得<code>mutex</code>后开始在<code>empty</code>信号量上等待。但是，由于它占据了<code>mutex</code>，因此C1和C2无法进入临界区进行消费，于是也不会对<code>empty</code>信号量执行V操作，发生死锁。</p>
<h2 id="六-ucore用户进程16分"><a class="markdownIt-Anchor" href="#六-ucore用户进程16分"></a> 六 ucore用户进程（16分）</h2>
<p>下面是关于ucore中用户程序的生命历程的代码。请完成下面填空和代码补全。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>在<code>sh</code>的命令行上输入<code>args 1</code>启动用户程序<code>args</code>，则<code>sh</code>会调用（<strong>1</strong>）创建新进程并调用（<strong>2</strong>）将<code>args</code>加载到该进程的地址空间中。（回答系统调用名称即可）</p>
<ol>
<li><code>SYS_fork</code></li>
<li><code>SYS_exec</code></li>
</ol>
<hr>
<p>这一题使我觉得我应该复习一下ucore里的各种系统调用、实现方法及其作用。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>将<code>args</code>从硬盘加载主要由<code>load_icode</code>完成，请补全以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">// load_icode - called by sys_exec--&gt;do_execve</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">load_icode(int fd, int argc, char **kargv) &#123;</span><br><span class="line">    /* LAB8:EXERCISE2 YOUR CODE HINT:how to load the file with handler fd in to process&apos;s memory? how to setup argc/argv?</span><br><span class="line">    * MACROs or Functions:</span><br><span class="line">    * mm_create - create a mm</span><br><span class="line">    * setup_pgdir - setup pgdir in mm</span><br><span class="line">    * load_icode_read - read raw data content of program file</span><br><span class="line">    * mm_map - build new vma</span><br><span class="line">    * pgdir_alloc_page - allocate new memory for TEXT/DATA/BSS/stack parts</span><br><span class="line">    * lcr3 - update Page Directory Addr Register -- CR3</span><br><span class="line">    */</span><br><span class="line">    /* (1) create a new mm for current process</span><br><span class="line">    * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="line">    * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="line">    * (3.1) read raw data content in file and resolve elfhdr</span><br><span class="line">    * (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="line">    * (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="line">    * (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="line">    * and copy them into the new allocated pages</span><br><span class="line">    * (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="line">    * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="line">    * (5) setup current process&apos;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="line">    * (6) setup uargc and uargv in user stacks</span><br><span class="line">    * (7) setup trapframe for user environment</span><br><span class="line">    * (8) if up steps failed, you should cleanup the env.</span><br><span class="line">    */</span><br><span class="line">    assert(argc &gt;= 0 &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    if (current-&gt;mm != NULL) &#123;</span><br><span class="line">        panic(&quot;load_icode: current-&gt;mm must be empty.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = -E_NO_MEM;</span><br><span class="line">    struct mm_struct *mm;</span><br><span class="line">    if ((mm = mm_create()) == NULL) &#123;</span><br><span class="line">        goto bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    if (setup_pgdir(mm) != 0) &#123;</span><br><span class="line">        goto bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Page *page;</span><br><span class="line"></span><br><span class="line">    struct elfhdr __elf, *elf = &amp;__elf;</span><br><span class="line">    /* 2a */</span><br><span class="line">    if ((ret = load_icode_read(fd, elf, _(2a)_, 0)) != 0) &#123;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr __ph, *ph = &amp;__ph;</span><br><span class="line">    uint32_t vm_flags, perm, phnum;</span><br><span class="line">    for (phnum = 0; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;</span><br><span class="line">        off_t phoff = elf-&gt;e_phoff + sizeof(struct proghdr) * phnum;</span><br><span class="line">        if ((ret = load_icode_read(fd, ph, sizeof(struct proghdr), phoff)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            /* 2b */</span><br><span class="line">            _(2b)_</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz == 0) &#123;</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = 0, perm = PTE_U;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        if (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        if ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        off_t offset = ph-&gt;p_offset;</span><br><span class="line">        size_t off, size;</span><br><span class="line">        uintptr_t start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != 0) &#123;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">        if (start &lt; la) &#123;</span><br><span class="line">            /* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br><span class="line">            if (start == end) &#123;</span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    /* 2c */</span><br><span class="line">    if ((ret = mm_map(mm, _(2c)_, USTACKSIZE, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">        goto bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    //setup argc, argv</span><br><span class="line">    uint32_t argv_size=0, i;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">    char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">    argv_size = 0;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        /* 2d */</span><br><span class="line">        _(2d)_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">    /* 2e */</span><br><span class="line">    *(int *)stacktop = _(2e)_;</span><br><span class="line"></span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    memset(tf, 0, sizeof(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = 0;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sizeof(struct elfhdr)</code>（读一个<code>elfhdr</code>大小的文件数据）</li>
<li><code>goto bad_cleanup_mmap;</code>（这个很简单：已经设置了<code>pgdir</code>和<code>mm</code>了，因此如果失败需要清理；而且周围都是跳转到这里）</li>
<li><code>USTACKTOP - USTACKSIZE</code>（这段大概是映射用户栈空间，不过我并不是很明白）</li>
<li><code>argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</code>（得到当前的参数的长度）</li>
<li><code>argc</code>（把argc放到栈顶；之所以是栈顶，是因为gcc是从右向左压栈的）</li>
</ol>
<hr>
<p>这种默写代码的题目实在是无聊死了。</p>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p>完成加载后会从内核态回到用户态，请补全此时的用户栈图示。（假定为写入部分全部初始化为0，注意使用小尾端）</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>(3a)</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>(3b)</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>(3c)</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>(3d)</td>
</tr>
</tbody>
</table>
<p>此时并不会直接进入main函数，而是执行以下代码，请简述其作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//////// user/libs/initcode.S //////////</span><br><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line"></span><br><span class="line">    movl (%esp), %ebx</span><br><span class="line">    lea 0x4(%esp), %ecx</span><br><span class="line"></span><br><span class="line">    subl $0x20, %esp</span><br><span class="line"></span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line"></span><br><span class="line">    call umain</span><br><span class="line">1: jmp 1b</span><br><span class="line"></span><br><span class="line">////////// user/libs/umain.c ////////////</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;file.h&gt;</span><br><span class="line">#include &lt;stat.h&gt;</span><br><span class="line">int main(int argc, char *argv[]);</span><br><span class="line">static int</span><br><span class="line">initfd(int fd2, const char *path, uint32_t open_flags) &#123;</span><br><span class="line">    int fd1, ret;</span><br><span class="line">    if ((fd1 = open(path, open_flags)) &lt; 0) &#123;</span><br><span class="line">        return fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fd1 != fd2) &#123;</span><br><span class="line">        close(fd2);</span><br><span class="line">        ret = dup2(fd1, fd2);</span><br><span class="line">        close(fd1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char *argv[]) &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if ((fd = initfd(0, &quot;stdin:&quot;, O_RDONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdin&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd = initfd(1, &quot;stdout:&quot;, O_WRONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdout&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = main(argc, argv);</span><br><span class="line">    exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<!--
恕我直言，我一开始不知道这道题在说什么。大概调用用户程序`args`的时候会有两个参数：`int argc`和`char** argv`，其中`argc = 2`，`argv = ['args', '1']`。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述内容执行完之后，得到<code>argv_size = 6</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">	uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">	argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argc;</span><br></pre></td></tr></table></figure>
<p>然后学长答案是这样：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>fd ff ff ff</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>f8 ff ff ff</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>02 00 00 00</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>00 00 00 00</td>
</tr>
</tbody>
</table>
<p>恕我直言，我也看不懂。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢tsz和xzh同学关于此题的讨论）</p>
<p>不妨把填充栈帧的代码段拿出来细看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在栈中预留函数参数的位置</span><br><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">// 在栈中预留函数参数指针的位置</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    // 从低地址到高地址填各参数指针，顺便把参数内容拷进去</span><br><span class="line">    uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">    // argv_size += 长度</span><br><span class="line">    argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把argc放入栈中</span><br><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argv;</span><br></pre></td></tr></table></figure>
<p>事实上，这段代码的目的，就是从栈底到栈顶，依次存参数内容（所有参数拼起来）、各参数的指针（<code>char **argv</code>）和argc存进去。实际上，被调用的进程<code>args</code>有两个实际参数：进程名<code>&quot;argc&quot;</code>和参数<code>&quot;1&quot;</code>（注意这两者都是字符串）。于是结果变成了这样：</p>
<ul>
<li>参数<code>&quot;1\0&quot;</code>存在<code>0xaffffffd</code>开始的2个字节中</li>
<li>参数<code>&quot;args\0&quot;</code>存在<code>0xaffffff8</code>开始的5个字节中</li>
<li>参数<code>&quot;1\0&quot;</code>所在的地址<code>0xaffffffd</code>存在<code>0xaffffff4</code>开始的4个字节中（注意大小端）</li>
<li>参数<code>&quot;args\0&quot;</code>所在的地址<code>0xaffffff8</code>存在<code>0xaffffff0</code>开始的4个字节中（注意大小端）</li>
<li><code>argc</code>存放在<code>0xafffffec</code>开始的4个字节中（注意大小端）</li>
</ul>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0xb0000000</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>0xaffffffc</code></td>
<td><code>00 31 00 00</code></td>
<td>字符串&quot;1&quot;（和&quot;args&quot;的<code>\0</code>）</td>
</tr>
<tr>
<td><code>0xaffffff8</code></td>
<td><code>61 72 67 73</code></td>
<td>字符串&quot;args&quot;</td>
</tr>
<tr>
<td><code>0xaffffff4</code></td>
<td><code>fd ff ff af</code></td>
<td>&quot;1&quot;的地址</td>
</tr>
<tr>
<td><code>0xaffffff0</code></td>
<td><code>f8 ff ff af</code></td>
<td>&quot;args&quot;的地址</td>
</tr>
<tr>
<td><code>0xafffffec</code></td>
<td><code>02 00 00 00</code></td>
<td><code>argv = 2</code></td>
</tr>
<tr>
<td><code>0xafffffe8</code></td>
<td><code>00 00 00 00</code></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>后面代码的作用据说是为umain函数压入argc和argv，调整esp，打开stdin/stdout，然后调用main。总之，打开stdin/stdout这个部分我好像看懂了；压入argc和argv的本质就是利用gcc调用了函数。</p>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> （4）</h3>
<p>虽然main函数以<code>return 0;</code>结束，但此后程序仍在用户态，经过（<strong>4a</strong>）进入内核态，参考<code>do_exit</code>代码，其主要完成了页表和文件描述符的释放、设置进程状态和返回值、唤醒等待中的父进程、（<strong>4b</strong>）。（<code>while</code>循环部分）</p>
<p><code>do_exit</code>中该进程占用的内存并未完全释放，例如（<strong>4c</strong>），它们将在（<strong>4d</strong>）中被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_exit(int error_code) &#123;</span><br><span class="line">	if (current == idleproc) &#123;</span><br><span class="line">    	panic(&quot;idleproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (current == initproc) &#123;</span><br><span class="line">		panic(&quot;initproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">	if (mm != NULL) &#123;</span><br><span class="line">		lcr3(boot_cr3);</span><br><span class="line">		if (mm_count_dec(mm) == 0) &#123;</span><br><span class="line">			exit_mmap(mm);</span><br><span class="line">			put_pgdir(mm);</span><br><span class="line">			mm_destroy(mm);</span><br><span class="line">		&#125;</span><br><span class="line">		current-&gt;mm = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	put_fs(current); //for LAB8</span><br><span class="line">	current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">	current-&gt;exit_code = error_code;</span><br><span class="line"></span><br><span class="line">	bool intr_flag;</span><br><span class="line">	struct proc_struct *proc;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">		proc = current-&gt;parent;</span><br><span class="line">		if (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">			wakeup_proc(proc);</span><br><span class="line">		&#125;</span><br><span class="line">		while (current-&gt;cptr != NULL) &#123;</span><br><span class="line">			proc = current-&gt;cptr;</span><br><span class="line">			current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">			proc-&gt;yptr = NULL;</span><br><span class="line">			if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) &#123;</span><br><span class="line">				initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proc-&gt;parent = initproc;</span><br><span class="line">			initproc-&gt;cptr = proc;</span><br><span class="line">				if (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">					if (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">						wakeup_proc(initproc);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">	panic(&quot;do_exit will not return!! %d.\n&quot;, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ol>
<li><code>exit</code>系统调用</li>
<li>把子进程逐个放入initproc的子进程中，如果发现子进程已经为僵尸状态且initproc进入WT_CHILD状态，则唤醒initproc回收子进程</li>
<li>进程控制块</li>
<li>父进程的<code>do_wait</code>（或者说被唤醒的执行了wait或wait_pid的父进程）</li>
</ol>
<p>这道题反而比较简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent:           proc-&gt;parent  (proc is children)</span><br><span class="line">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="line">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="line">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br></pre></td></tr></table></figure>
<h2 id="七-磁盘调度15分"><a class="markdownIt-Anchor" href="#七-磁盘调度15分"></a> 七 磁盘调度（15分）</h2>
<p>一磁盘逆时针旋转，磁盘有3个磁道和一个磁头，每个磁道有12个扇区。最外侧磁道0包含扇区0<sub>11，中间侧磁道1包含扇区12</sub>23，最内侧磁道包含扇区24~35。如下图所示，可以看到磁头初始位置在外侧磁道的扇区6的中间位置，扇区10与扇区6在一个磁道上。</p>
<p><img src="simple-disk.png" alt="磁盘示意图" /></p>
<p>完成一次磁盘扇区的访问请求时间包括：</p>
<ul>
<li>寻道时间（seek time）</li>
<li>旋转时间（rotational time）</li>
<li>传输时间（transfer time）</li>
</ul>
<p>如，ucore发出访问请求序列为[‘10’]，即只有一次对扇区10的访问请求，则磁盘花费的访问请求时间如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">TOTALS  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br></pre></td></tr></table></figure>
<p>表示寻道时间是0个时间单位，旋转时间是105个时间单位，总共的磁盘访问请求的时间是135。注意，相邻磁头移动一个磁道的时间是40个时间单位；从扇区6到扇区9，旋转了90度；而为了进行传输，需要从扇区9<sub>10的中间位置开始，从扇区10</sub>11的中间位置结束。所以需要再旋转15度，即旋转了105度，而每旋转1度花费1个时间单位，所以旋转花费了105个实践单位。</p>
<ol>
<li>若采用FIFO磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
<li>若采用SSFT磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
</ol>
<hr />
<!--
FIFO策略：
* 10
  * 磁道不变
  * 旋转：105
  * 传输：30
* 12
  * 寻道：40
  * 旋转：60
  * 传输：30
* 24
  * 寻道：40
  * 旋转：360
  * 传输：30
* 1
  * 寻道：80
  * 旋转：30
  * 传输：30

以及恕我无法理解学长答案。他给出的计算结果是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>SSFT策略：</p>
<ul>
<li>10
<ul>
<li>磁道不变</li>
<li>旋转：105</li>
<li>传输：30</li>
</ul>
</li>
<li>1
<ul>
<li>磁道不变</li>
<li>旋转：90</li>
<li>传输：30</li>
</ul>
</li>
<li>12
<ul>
<li>寻道：40</li>
<li>旋转：330</li>
<li>传输：30</li>
</ul>
</li>
<li>24
<ul>
<li>寻道：40</li>
<li>旋转：360</li>
<li>传输：30</li>
</ul>
</li>
</ul>
<p>经过查证，我发现这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。但是我认为程序说明自相矛盾，无法理解。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢zp、wj等人关于这道题的讨论）</p>
<p>这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。事实上，需要注意的一点是：磁盘在旋转过程中可以进行寻道。</p>
<p>FIFO策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td><img src="disk-fifo-1.png" alt="" /></td>
</tr>
<tr>
<td>12</td>
<td>30</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>320</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>30</td>
<td>80</td>
<td>30</td>
<td>110</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>SSFT策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>0</td>
<td>30</td>
<td>90</td>
<td>-</td>
</tr>
<tr>
<td>12</td>
<td>300</td>
<td>40</td>
<td>30</td>
<td>330</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>360</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>这个答案仍然和学长给出的不尽相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>可能之后有时间的时候还需要进行分析吧。</p>
-->
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
              <p class="current">
                  1 / 2
              </p>
              
                  <a class="next" rel="next" href="/archives/2018/05/page/2/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  





<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->



    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
