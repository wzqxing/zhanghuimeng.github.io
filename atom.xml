<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张慕晖的博客</title>
  
  <subtitle>LUX ET VERITAS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhanghuimeng.github.io/"/>
  <updated>2019-02-27T14:41:00.000Z</updated>
  <id>https://zhanghuimeng.github.io/</id>
  
  <author>
    <name>张慕晖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode Weekly Contest 125总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-125-summary/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-125-summary/</id>
    <published>2019-02-26T20:54:43.000Z</published>
    <updated>2019-02-27T14:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>比赛太多，题解写不过来，Leetcode题解也变成每周一份了……</p><h2 id="997-find-the-town-judge"><a class="markdownIt-Anchor" href="#997-find-the-town-judge"></a> <a href="https://leetcode.com/problems/find-the-town-judge/description/" target="_blank" rel="noopener">997. Find the Town Judge</a></h2><p>标记难度：Easy</p><p>提交次数：1/2</p><p>代码效率：252ms</p><h3 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h3><p>有<code>N</code>个人，他们之间有一些相互信任的关系，其中可能有一个town judge，如果有则只有一个，且满足以下要求：</p><ul><li>town judge不信任别人</li><li>除了town judge之外的其他人都信任他</li></ul><p>请找出town judge，或者返回-1。</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>水题，随便怎么做都好。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tSet[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> trusting[N + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(trusting, <span class="number">0</span>, <span class="keyword">sizeof</span>(trusting));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trust.size(); i++) &#123;</span><br><span class="line">            tSet[trust[i][<span class="number">1</span>]].insert(trust[i][<span class="number">0</span>]);</span><br><span class="line">            trusting[trust[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tSet[i].size() == N - <span class="number">1</span> &amp;&amp; trusting[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">-1</span>) ans = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="998-maximum-binary-tree-ii"><a class="markdownIt-Anchor" href="#998-maximum-binary-tree-ii"></a> <a href="https://leetcode.com/problems/maximum-binary-tree-ii/description/" target="_blank" rel="noopener">998. Maximum Binary Tree II</a></h2><p>标记难度：Medium</p><p>提交次数：1/2</p><p>代码效率：</p><ul><li>暴力：12ms</li><li>不暴力：8ms</li></ul><h3 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h3><p>定义一种“最大二叉树”：</p><ul><li>对于一个数组<code>A</code>，建一棵这样的树：<ul><li>找出其中最大的元素<code>A[i]</code></li><li>令当前结点的值为<code>A[i]</code>，左子结点为数组<code>A[:i-1]</code>建出的树，右子结点为数组<code>A[i+1:]</code>建出的数</li></ul></li></ul><p>现在给定一棵这样的二叉树，假设你在它对应的数组<code>A</code>后面加上一个值<code>val</code>，问得到的新树是什么样子的？</p><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>这道题还稍微有点意思。比赛的时候，鉴于这是在比赛，所以我就直接愚蠢地把整棵树序列化成数组，把<code>val</code>加上去，然后重造了一棵树，反正<code>N</code>也不大……复杂度最差<code>O(N^2)</code>。</p><p>不那么愚蠢的方法倒是很容易考虑。首先把<code>val</code>和树根比较，如果<code>val</code>比它大，那它就是新的树根；否则继续去右子树里面查。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><h4 id="暴力做法"><a class="markdownIt-Anchor" href="#暴力做法"></a> 暴力做法</h4><p>真的很暴力啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l = dfs(root-&gt;left);</span><br><span class="line">        l.push_back(root-&gt;val);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r = dfs(root-&gt;right);</span><br><span class="line">        l.insert(l.end(), r.begin(), r.end());</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(a[l]);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-1</span>, argmax = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; maxn) &#123;</span><br><span class="line">                maxn = a[i];</span><br><span class="line">                argmax = i;</span><br><span class="line">            &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(a[argmax]);</span><br><span class="line">        root-&gt;left = dfs(l, argmax - <span class="number">1</span>, a);</span><br><span class="line">        root-&gt;right = dfs(argmax + <span class="number">1</span>, r, a);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(dfs(root));</span><br><span class="line">        a.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, a.size() - <span class="number">1</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不暴力的做法"><a class="markdownIt-Anchor" href="#不暴力的做法"></a> 不暴力的做法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">            TreeNode* p = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            p-&gt;left = root;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;right = insertIntoMaxTree(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="999-available-captures-for-rook"><a class="markdownIt-Anchor" href="#999-available-captures-for-rook"></a> <a href="https://leetcode.com/problems/available-captures-for-rook/description/" target="_blank" rel="noopener">999. Available Captures for Rook</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3 id="题意-3"><a class="markdownIt-Anchor" href="#题意-3"></a> 题意</h3><p>在一个国际象棋盘上有一个白车，几个（或没有）白主教，几个（或没有）黑卒，剩下的地方都是空格。白车可以从上下左右中选择一个方向移动，直到遇到棋盘边沿/被主教堵住/吃到黑卒。问白车一共有可能吃到多少个黑卒？</p><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>这题水到不能再水了。模拟走四次即可……</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rx, ry;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(), m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    rx = i;</span><br><span class="line">                    ry = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rx, y = ry;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[x][y] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                x += mx[d];</span><br><span class="line">                y += my[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1001-grid-illumination"><a class="markdownIt-Anchor" href="#1001-grid-illumination"></a> <a href="https://leetcode.com/problems/grid-illumination/description/" target="_blank" rel="noopener">1001. Grid Illumination</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：764ms</p><h3 id="题意-4"><a class="markdownIt-Anchor" href="#题意-4"></a> 题意</h3><p>嘿，1000题呢？</p><p>在一个grid上有一些灯，每个灯会照亮所有和它同行、同列、同对角线的格子。我们query这个grid上的一些格子现在是不是亮的，同时，一旦进行一次query，就把和它八连通的灯都关掉（如果有这样的灯）。问每次query的结果。</p><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><p>这道题也挺水的。记录每一行、每一列、每条对角线被多少灯照亮了，然后在query的时候进行必要的删除就行。</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> my[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gridIllumination(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; lamps, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; row, col, ldiag, rdiag;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; lampSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lamps.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = lamps[i][<span class="number">0</span>], y = lamps[i][<span class="number">1</span>];</span><br><span class="line">            row[x]++;</span><br><span class="line">            col[y]++;</span><br><span class="line">            ldiag[x - y]++;</span><br><span class="line">            rdiag[x + y]++;</span><br><span class="line">            lampSet[&#123;x, y&#125;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queries[i][<span class="number">0</span>], y = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (row[x] &gt; <span class="number">0</span> || col[y] &gt; <span class="number">0</span> || ldiag[x - y] &gt; <span class="number">0</span> || rdiag[x + y] &gt; <span class="number">0</span>) ans.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> ans.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + mx[j], ny = y + my[j];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= N || ny &lt; <span class="number">0</span> || ny &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 删掉可能的lamp</span></span><br><span class="line">                <span class="keyword">if</span> (lampSet.find(&#123;nx, ny&#125;) != lampSet.end() &amp;&amp; lampSet[&#123;nx, ny&#125;] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lampSet[&#123;nx, ny&#125;]--;</span><br><span class="line">                    row[nx]--;</span><br><span class="line">                    col[ny]--;</span><br><span class="line">                    ldiag[nx - ny]--;</span><br><span class="line">                    rdiag[nx + ny]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/maximum-binary-tree-ii/discuss/242897/Java-clean-recursive-solution" target="_blank" rel="noopener">Leetcode 998 Solution - Java clean recursive solution</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比赛太多，题解写不过来，Leetcode题解也变成每周一份了……&lt;/p&gt;
&lt;h2 id=&quot;997-find-the-town-judge&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#997-find-the-town-judge&quot;&gt;&lt;/a&gt; &lt;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 996. Number of Squareful Arrays（DP）</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-996-number-of-squareful-arrays/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-996-number-of-squareful-arrays/</id>
    <published>2019-02-21T00:05:00.000Z</published>
    <updated>2019-02-21T00:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/number-of-squareful-arrays/description/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-squareful-arrays/description/</a></p><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：36.82%（12ms）</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定数组<code>A</code>，问有多少种<code>A</code>的排列，使得任意两个相邻元素的和都是平方数。认为两种排列不等当且仅当存在某个位置的元素不等（而不是把不同index的相同元素认为是不同的）。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>这又是一道“虽然看起来好像应该用状态DP做但因为数据量太小了所以不如直接DFS搜索”的题。既然我都写了DP了，现在实在懒得去写DFS，就这样好了。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSquare</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (s*s == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">bool</span> ok[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[state][end] != <span class="number">-1</span>) <span class="keyword">return</span> f[state][end];</span><br><span class="line">        <span class="keyword">if</span> (!(state &amp; (<span class="number">1</span> &lt;&lt; end))) &#123;</span><br><span class="line">            f[state][end] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(state) == <span class="number">1</span>) &#123;</span><br><span class="line">            f[state][end] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[state][end] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == end || !ok[i][end] || !(state &amp; (<span class="number">1</span> &lt;&lt; i))) <span class="keyword">continue</span>;</span><br><span class="line">            f[state][end] += calc(state ^ (<span class="number">1</span> &lt;&lt; end), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[state][end];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans *= x;</span><br><span class="line">            x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;A = A;</span><br><span class="line">        n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ok[i][i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSquare(A[i] + A[j]))</span><br><span class="line">                    ok[i][j] = ok[j][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ok[i][j] = ok[j][i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans += calc((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, i);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) cnt[x]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p: cnt) ans /= factorial(p.second);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/number-of-squareful-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Backtracking" scheme="https://zhanghuimeng.github.io/tags/alg-Backtracking/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Dynamic Porgramming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Porgramming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 995. Minimum Number of K Consecutive Bit Flips</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-995-minimum-number-of-k-consecutive-bit-flips/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-995-minimum-number-of-k-consecutive-bit-flips/</id>
    <published>2019-02-21T00:04:12.000Z</published>
    <updated>2019-02-22T00:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/</a></p><p>标记难度：Hard</p><p>提交次数：4/5</p><p>代码效率：</p><ul><li>暴力贪心：12.68%（5152ms）</li><li>线段树：52.11%（288ms）</li><li>O(n)：96.20%（84ms）</li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>有一个只包含0和1的数组<code>A</code>，每次可以将数组<code>A</code>中的恰好连续<code>k</code>个元素取反，问能否将<code>A</code>变成全1？</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>很容易就能想到一种贪心策略：找到左边第一个0，从它开始翻转连续<code>k</code>个元素（因为这个0只能在这里通过翻转而变成1，否则左边就会出现新的0），然后对于右边的0，继续进行这一操作，如果最后能成功则<code>A</code>可以变成全1。这个算法是<code>O(n*k)</code>的，或者说是<code>O(n^2)</code>的，可能太慢了。</p><p>很容易就能想到一种优化策略：用线段树来进行区间更新。这样复杂度就会变成<code>O(n*log(n))</code>，可以接受。</p><p>用线段树实在是overkill了。可以很简单地通过记录区间的开闭事件来确定当前元素是否需要取反。甚至可以不显式地记录开闭事件——如果<code>k</code>个元素之前的元素是<code>0</code>，那么现在就是一个区间的关闭。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="暴力贪心"><a class="markdownIt-Anchor" href="#暴力贪心"></a> 暴力贪心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K - <span class="number">1</span> &gt;= A.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">                    A[i + j] = <span class="number">1</span> - A[i + j];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><p>当然，这是一种比较愚蠢的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">bool</span> toFlip;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> _l = <span class="number">0</span>, <span class="keyword">int</span> _r = <span class="number">0</span>) &#123;</span><br><span class="line">            l = _l;</span><br><span class="line">            r = _r;</span><br><span class="line">            toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TreeNode tree[<span class="number">120005</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) tree[node].l = tree[node].r = l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            tree[node].l = l;</span><br><span class="line">            tree[node].r = r;</span><br><span class="line">            buildTree(node * <span class="number">2</span>, l, m);</span><br><span class="line">            buildTree(node * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].r &lt; l || r &lt; tree[node].l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tree[node].l &amp;&amp; tree[node].r &lt;= r) &#123;</span><br><span class="line">            tree[node].toFlip = !tree[node].toFlip;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].toFlip) &#123;</span><br><span class="line">            tree[node * <span class="number">2</span>].toFlip = !tree[node * <span class="number">2</span>].toFlip;</span><br><span class="line">            tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip = !tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip;</span><br><span class="line">            tree[node].toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update(node * <span class="number">2</span>, l, r);</span><br><span class="line">        update(node * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].l == tree[node].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[node].toFlip) <span class="keyword">return</span> !a[l];</span><br><span class="line">            <span class="keyword">return</span> a[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].toFlip) &#123;</span><br><span class="line">            tree[node * <span class="number">2</span>].toFlip = !tree[node * <span class="number">2</span>].toFlip;</span><br><span class="line">            tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip = !tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip;</span><br><span class="line">            tree[node].toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (tree[node].l + tree[node].r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="keyword">return</span> query(node * <span class="number">2</span>, l);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(node * <span class="number">2</span> + <span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        a = A;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        buildTree(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> x = query(<span class="number">1</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (!x &amp;&amp; i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">                update(<span class="number">1</span>, i, i + K - <span class="number">1</span>);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="on"><a class="markdownIt-Anchor" href="#on"></a> O(n)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> event[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur += event[i];</span><br><span class="line">            <span class="keyword">int</span> x = (A[i] + cur) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K - <span class="number">1</span> &gt;= n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                cur++;</span><br><span class="line">                ans++;</span><br><span class="line">                event[i + K]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/238609/JavaC++Python-One-Pass-and-O(1)-Space" target="_blank" rel="noopener">les215’s solution - [Java/C++/Python] One Pass and O(1) Space</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Educational Codeforces Round 60 总结</title>
    <link href="https://zhanghuimeng.github.io/post/codeforces-educational-codeforces-round-60-summary/"/>
    <id>https://zhanghuimeng.github.io/post/codeforces-educational-codeforces-round-60-summary/</id>
    <published>2019-02-20T18:50:42.000Z</published>
    <updated>2019-02-21T19:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛做得乱七八糟，事实上一共只做出来两道题，结果rating还涨了一点点，看来确实有点难。。</p><h2 id="1117a"><a class="markdownIt-Anchor" href="#1117a"></a> 1117A</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/A</a></p><p>提交次数：1/1</p><h3 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h3><p>给定一个数组，问数组中满足平均数最大的前提下长度最长的子数列。</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>就是找到最大值然后计算最大值最多连续出现了多少次而已。水题。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        maxn = max(maxn, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || a[i] != a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == maxn) ans = max(l, ans);</span><br><span class="line">            l = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1117b"><a class="markdownIt-Anchor" href="#1117b"></a> 1117B</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/B</a></p><p>提交次数：1/1</p><h3 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h3><p>给定<code>n</code>个emote，每个emote可以将对手的快乐值增加<code>a[i]</code>，你可以使用一些emote共<code>m</code>次，相同的emote最多连续使用<code>k</code>次，问最多能增加多少快乐值？</p><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>找出值最大和值次大的emote，连续用最大的emote<code>k</code>次，用一次次大的emote，再接着用最大的emote，以此类推，直到一共用了<code>m</code>次为止。水题。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL n, m, k;</span><br><span class="line">LL a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    LL cnt = m / (k + <span class="number">1</span>);</span><br><span class="line">    LL ans = cnt * (a[n<span class="number">-1</span>] * k + a[n<span class="number">-2</span>]) + (m - (k + <span class="number">1</span>) * cnt) * a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1117c"><a class="markdownIt-Anchor" href="#1117c"></a> 1117C</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/C</a></p><p>提交次数：1/4</p><h3 id="题意-3"><a class="markdownIt-Anchor" href="#题意-3"></a> 题意</h3><p>你在<code>(x1, y1)</code>处有一艘船，每天可以向上或下、左、右移动1格。每天的移动效果会和天气效果叠加，天气效果会使得船根据风向往上或下、左、右移动一格。给定<code>m</code>天的天气，之后的天气是循环的，问最少需要几天，船才能到达<code>(x2, y2)</code>处？</p><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>比赛的时候我意识到走完一个天气循环之后，能到的位置是一个菱形了（或者说是一个尖朝上的正方形）；但很可惜我没有意识到这件事的本质，还打算拿计算几何来做（？？）。显然，这件事的本质是这样的：把天气推船走的路和船自己走的路分开，可以得出一个结论：天气在一个循环内推船走的路是固定的，不妨记为<code>(dx, dy)</code>；船自己可以在这个点周围走出一个菱形，或者说是所有满足<code>|x-dx|+|y-dy|&lt;=n</code>的点。所以对天数二分查找就好了。当然，还是需要重视一下二分查找的前提：只要<code>x</code>天能到，那么<code>y&gt;=x</code>天也能到。（大不了不动）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>除此之外就是注意上界。显然如果能到达<code>(x2, y2)</code>，每个天气循环至少要向这个方向前进1格（曼哈顿距离），所以上界是<code>(|x2-x1| + |y2-y1|)*n</code>。如果走了这么多还没到，说明到不了了。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><p>因为<code>long long int</code>的使用错了好多次……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL x1, y1, x2, y2;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>];</span><br><span class="line">pair&lt;LL, LL&gt; pos[<span class="number">100005</span>];</span><br><span class="line">LL fx, fy;</span><br><span class="line"><span class="comment">// U, R, D, L</span></span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOk</span><span class="params">(LL days)</span> </span>&#123;</span><br><span class="line">    LL sx = (days / n) * fx, sy = (days / n) * fy;</span><br><span class="line">    sx += pos[days % n].first, sy += pos[days % n].second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x2 - sx) + <span class="built_in">abs</span>(y2 - sy) &lt;= days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    x2 -= x1;</span><br><span class="line">    y2 -= y1;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'U'</span>) d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'R'</span>) d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'D'</span>) d = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'L'</span>) d = <span class="number">3</span>;</span><br><span class="line">        pos[i].first = pos[i<span class="number">-1</span>].first + mx[d];</span><br><span class="line">        pos[i].second = pos[i<span class="number">-1</span>].second + my[d];</span><br><span class="line">    &#125;</span><br><span class="line">    fx = pos[n].first, fy = pos[n].second;</span><br><span class="line"></span><br><span class="line">    LL l = <span class="number">0</span>, r = (<span class="built_in">abs</span>(x2) + <span class="built_in">abs</span>(y2)) * n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        LL m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isOk(m)) r = m;</span><br><span class="line">        <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isOk(l)) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1117d"><a class="markdownIt-Anchor" href="#1117d"></a> 1117D</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/D</a></p><p>提交次数：1/1</p><h3 id="题意-4"><a class="markdownIt-Anchor" href="#题意-4"></a> 题意</h3><p>一颗魔法宝石可以分裂成<code>M</code>颗普通宝石，问有多少种选择魔法宝石的方法，使得分裂后总的宝石数量是<code>N</code>？不同的魔法宝石数量和不同index的分裂被认为是不同的方法。<code>N&lt;=10^18</code>，<code>M&lt;=100</code>。</p><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><p>比赛的时候我努力推了一个公式出来：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>⌊</mo><mi>N</mi><mi mathvariant="normal">/</mi><mi>M</mi><mo>⌋</mo></mrow></munderover><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>N</mi><mo>−</mo><mo>(</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>i</mi></mrow><mi>i</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{\lfloor N/M \rfloor} \binom{N-(M-1)i}{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.2386740000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌊</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mclose mtight">⌋</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>但是肯定不能这么算，因为<code>N</code>太大了。我心想：用动态规划估计也不行。</p><p>事实上得用到动态规划递推的思路，看到<code>N</code>和<code>M</code>的大小，我早该想到是矩阵快速幂才对。</p><p>令<code>f[n]</code>表示<code>N=n</code>时的方法数量。显然有两种方法进行递推：一种是加上一块不分裂的宝石（<code>f[n-1]</code>）；另一种是加上一块分裂的宝石（<code>f[n-M]</code>）。（虽然第二维看起来没有什么意义……）考虑到递推的本质，不需要乘新加的宝石的位置，因此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n] = f[n-1] + f[n-M]</span><br></pre></td></tr></table></figure><p>现在就可以造一个矩阵乘法迭代公式了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| f[n-M]  f[n-M+1]  ...  f[n-1] | * | 0 0 0 ... 0 1 | = | f[n-M+1] |</span><br><span class="line">                                    | 1 0 0 ... 0 0 |   | f[n-M+2] |</span><br><span class="line">                                    | 0 1 0 ... 0 0 |   |  ...     |</span><br><span class="line">                                    | 0 0 1 ... 0 0 |   | f[n-1]   |</span><br><span class="line">                                    | 0 0 0 ... 1 1 |   | f[n]     |</span><br></pre></td></tr></table></figure><p>然后矩阵快速幂即可。</p><p>太久没写矩阵快速幂，手都生了……</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL N;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    LL a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        n = _n;</span><br><span class="line">        m = _m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; m1, <span class="keyword">const</span> Matrix&amp; m2) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">m3</span><span class="params">(m1.n, m2.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1.n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1.m; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m2.m; k++)</span><br><span class="line">                    m3.a[i][k] = (m3.a[i][k] + m1.a[i][j] * m2.a[j][k]) % P;</span><br><span class="line">        <span class="keyword">return</span> m3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">getIdentity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">mat</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        mat.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; M) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">v</span><span class="params">(<span class="number">1</span>, M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">        v.a[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    v.a[<span class="number">1</span>][M] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Matrix <span class="title">x</span><span class="params">(M, M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i++)</span><br><span class="line">        x.a[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    x.a[<span class="number">1</span>][M] = x.a[M][M] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL delta = N - M;</span><br><span class="line">    Matrix <span class="built_in">pow</span> = x;</span><br><span class="line">    Matrix ans = getIdentity(M);</span><br><span class="line">    <span class="keyword">while</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &amp; <span class="number">1</span>) ans = ans * <span class="built_in">pow</span>;</span><br><span class="line">        delta &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pow</span> = <span class="built_in">pow</span> * <span class="built_in">pow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v = v * ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.a[<span class="number">1</span>][M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1117e"><a class="markdownIt-Anchor" href="#1117e"></a> 1117E</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/E</a></p><p>提交次数：1/1</p><h3 id="题意-5"><a class="markdownIt-Anchor" href="#题意-5"></a> 题意</h3><p>这是一道交互题。给定一个字符串，已知对它进行了<code>&lt;=n</code>次swap操作；你可以拿出一个新的和它长度一样的字符串，然后得到对这个字符串进行相同的swap之后的结果。你最多可以提交三次字符串。问原来的字符串是多少？</p><h3 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h3><p>比赛的时候，我看了看这道题……觉得很有趣，但应该想半天也做不出来吧。（我从来没在比赛里做对过交互题）这道题的一种解法是这样的：既然每次提交的字符串的swap操作是一样的，不妨把提交的三次字符串看成是一个字符串，它的每个位置是由三个字符组成的一个“超字符”。这样我们就可以认为每个位置的“超字符”是两两不等的了！因为<code>26^3 = 17576 &gt;= 1e4</code>，这是可行的。</p><p>然后就可以立即得到每个输入位置到输出位置的映射了，倒过来对原来的字符串重新做一遍就行了。</p><p>评论区里还出现了用中国剩余定理的做法，我没细看。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">char</span> q[<span class="number">3</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> mapping[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                q[<span class="number">0</span>][m] = i + <span class="string">'a'</span>;</span><br><span class="line">                q[<span class="number">1</span>][m] = j + <span class="string">'a'</span>;</span><br><span class="line">                q[<span class="number">2</span>][m] = k + <span class="string">'a'</span>;</span><br><span class="line">                m++;</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; q[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (a[<span class="number">0</span>][i] - <span class="string">'a'</span>) * <span class="number">26</span> * <span class="number">26</span> + (a[<span class="number">1</span>][i] - <span class="string">'a'</span>) * <span class="number">26</span> + (a[<span class="number">2</span>][i] - <span class="string">'a'</span>);</span><br><span class="line">        mapping[idx] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[mapping[i]];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1117f"><a class="markdownIt-Anchor" href="#1117f"></a> 1117F</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/F</a></p><p>提交次数：?/?</p><h3 id="题意-6"><a class="markdownIt-Anchor" href="#题意-6"></a> 题意</h3><p>还没看懂，感觉有点难度。</p><h2 id="111g"><a class="markdownIt-Anchor" href="#111g"></a> 111G</h2><p>题目来源：<a href="https://codeforces.com/contest/1117/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/G</a></p><p>提交次数：?/?</p><h3 id="题意-7"><a class="markdownIt-Anchor" href="#题意-7"></a> 题意</h3><p>给定一个由1到<code>n</code>的全排列组成的数组，记<code>m</code>是<code>[l, r]</code>范围内的最大元素index，定义函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(l, r) = (r - l + 1) + f(l, m - 1) + f(m + 1, r) (l &lt;= r)</span><br><span class="line">f(l, r) = 0 (l &gt; r)</span><br></pre></td></tr></table></figure><p>给定<code>q</code>个询问，请给定<code>f</code>的值。</p><p><code>1 &lt;= n, q &lt;= 1e6</code>。</p><h3 id="分析-6"><a class="markdownIt-Anchor" href="#分析-6"></a> 分析</h3><p>这道题我比赛的时候自然是不会做的。比赛完了，看看题解，发现也晦涩难懂。<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></p><p>首先需要把<code>f</code>分解成两个函数，<code>fl</code>和<code>fr</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fl(l, r) = (m - l) + fl(l, m-1) + fl(m+1, r)</span><br><span class="line">fr(l, r) = (r - m) + fr(l, m-1) + fr(m+1, r)</span><br><span class="line">f(l, r) = (r - l + 1) + fl(l, r) + fr(l, r)</span><br></pre></td></tr></table></figure><p>可以用数学归纳法简单地证明这个分解的正确性（虽然我可不知道为什么要这样分解……）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(l, r) = (r - l + 1) + fl(l, r) + fr(l, r)</span><br><span class="line">        = (r - l + 1) + fl(l, m-1) + fl(m+1, r) + (m - l)</span><br><span class="line">                      + fr(l, m-1) + fr(m+1, r) + (r - m)</span><br><span class="line">        = (r - l + 1) + f(l, m-1) - (m-1 - l + 1) + f(m+1, r) - (r - (m+1) + 1) + (r - l)</span><br><span class="line">        = (r - l + 1) + f(l, m-1) + f(m+1, r)</span><br></pre></td></tr></table></figure><p>然后不妨举一个例子来看看<code>fl</code>是怎么算出来的：</p><p><img src="tree.jpg" alt="fl的例子"></p><p>（显然<code>fl(i, i) = fr(i,i) = 0</code>）</p><p>把这些式子全部展开，就会变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fl(1, 6) = (3-1) + fl(1, 2) + fl(4, 6)</span><br><span class="line">         = (3-1) + (1-1) + fl(2, 2) + (4-4) + fl(5, 6)</span><br><span class="line">         = (3-1) + (1-1) + (2-2) + (4-4) + (6-5) + fl(5, 5)</span><br><span class="line">         = (3-1) + (1-1) + (2-2) + (4-4) + (6-5) + (5, 5)</span><br></pre></td></tr></table></figure><p>可以看出，<code>fl</code>其实是由6项组成的，而且每一项都是某个<code>l &lt;= i &lt;= r</code>与它左边最近的比它小的元素（或者<code>l</code>）之间的距离。这么想其实很合理。记<code>i</code>左边离它最近的比它大的元素为<code>lf[i]</code>，可以看出，它对<code>fl(l, r)</code>产生贡献当且仅当它被作为最大元素选中了，且贡献大小为<code>min(i - l, i - lf[i] - 1)</code>。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65365" target="_blank" rel="noopener">Educational Codeforces Round 60 Editorial</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65365?#comment-493763" target="_blank" rel="noopener">saeed_odak’s comment for 1117E</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次比赛做得乱七八糟，事实上一共只做出来两道题，结果rating还涨了一点点，看来确实有点难。。&lt;/p&gt;
&lt;h2 id=&quot;1117a&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1117a&quot;&gt;&lt;/a&gt; 1117A&lt;/h2&gt;
&lt;p&gt;题目来源：&lt;a
      
    
    </summary>
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/categories/Codeforces/"/>
    
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/tags/Codeforces/"/>
    
      <category term="Codeforces Contest" scheme="https://zhanghuimeng.github.io/tags/Codeforces-Contest/"/>
    
      <category term="alg:Math" scheme="https://zhanghuimeng.github.io/tags/alg-Math/"/>
    
      <category term="alg:Binary Search" scheme="https://zhanghuimeng.github.io/tags/alg-Binary-Search/"/>
    
      <category term="alg:Matrix" scheme="https://zhanghuimeng.github.io/tags/alg-Matrix/"/>
    
      <category term="alg:Segmentation Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Segmentation-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 994. Rotting Oranges（BFS）</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-994-rotting-oranges/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-994-rotting-oranges/</id>
    <published>2019-02-19T21:38:19.000Z</published>
    <updated>2019-02-20T23:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/cousins-in-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/cousins-in-binary-tree/description/</a></p><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：12ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>在一个四连通图上有若干个橘子，其中有一些是烂的，烂橘子每秒都会向四连通的橘子扩散，问经过多少秒，所有的橘子会烂掉？</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>前几天在CF上做过一道有点类似的题（<a href="https://codeforces.com/problemset/problem/1105/D" target="_blank" rel="noopener">1105D</a>，也是BFS分次扩展，当时虽然过了pretest，却因为每次扩展的结点过多且<code>queue</code>初始化过慢超时了。所以我就学到了一个道理：在这种情况下注意到底应该扩展哪些结点。不过这道题其实没有这个必要……</p><p>考虑到这一点，不如直接用<code>vector</code>代替<code>queue</code>。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> orangeCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) orangeCnt++;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) q.emplace_back(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q.size() == orangeCnt) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 全都烂了</span></span><br><span class="line">        <span class="keyword">if</span> (q.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 根本没有烂的</span></span><br><span class="line">        <span class="comment">// [lastEnd, lastSize)这部分是本次需要扩展的</span></span><br><span class="line">        <span class="comment">// 之前的已经扩展过了，没有再扩展一次的必要</span></span><br><span class="line">        <span class="keyword">int</span> lastEnd = <span class="number">0</span>, lastSize = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lastEnd; j &lt; lastSize; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = q[j].first, y = q[j].second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + mx[k], ny = y + my[k];</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">                        q.emplace_back(nx, ny);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本次没有扩展出新的烂橘子，且还有橘子没烂，说明扩展不到那边了</span></span><br><span class="line">            <span class="keyword">if</span> (lastSize == q.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 所有橘子都烂了</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() == orangeCnt) <span class="keyword">return</span> i;</span><br><span class="line">            lastEnd = lastSize;</span><br><span class="line">            lastSize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/cousins-in-binary-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/prob
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Breadth-first Search" scheme="https://zhanghuimeng.github.io/tags/alg-Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 993. Cousins in Binary Tree（树）</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-993-cousins-in-binary-tree/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-993-cousins-in-binary-tree/</id>
    <published>2019-02-19T02:51:51.000Z</published>
    <updated>2019-02-19T02:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/cousins-in-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/cousins-in-binary-tree/description/</a></p><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：8ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>定义二叉树中的“堂兄弟”结点：两个深度相同且父结点不同的结点。给定一棵结点值互异的二叉树和两个树中的结点值<code>x</code>和<code>y</code>，问这两个结点是否为堂兄弟。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>只要遍历二叉树，并记录对应的两个结点的父节点和深度即可。不过为了降低复杂度，甚至可以干脆把每个结点的父节点和深度都记录下来，然后在里面查。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>这里遍历用的是DFS。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> father[<span class="number">102</span>];</span><br><span class="line">    <span class="keyword">int</span> depth[<span class="number">102</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> d, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        father[root-&gt;val] = p;</span><br><span class="line">        depth[root-&gt;val] = d;</span><br><span class="line">        dfs(root-&gt;left, d + <span class="number">1</span>, root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, d + <span class="number">1</span>, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> depth[x] == depth[y] &amp;&amp; father[x] != father[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/cousins-in-binary-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/prob
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>重心剖分（Centroid Decomposition）简介及例题</title>
    <link href="https://zhanghuimeng.github.io/post/centroid-decomposition-summaary-and-example/"/>
    <id>https://zhanghuimeng.github.io/post/centroid-decomposition-summaary-and-example/</id>
    <published>2019-02-16T01:07:47.000Z</published>
    <updated>2019-02-20T18:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要参考了<a href="https://codeforces.com/blog/entry/52492" target="_blank" rel="noopener">Centroid Decomposition</a>和<a href="https://medium.com/carpanese/an-illustrated-introduction-to-centroid-decomposition-8c1989d53308" target="_blank" rel="noopener">An illustrated introduction to centroid decomposition</a>两篇文章。</p><hr><h2 id="问题的描述"><a class="markdownIt-Anchor" href="#问题的描述"></a> 问题的描述</h2><p>首先给出一道例题：<a href="http://codeforces.com/problemset/problem/342/E" target="_blank" rel="noopener">Codeforces 342E. Xenia and Tree</a>。这道题的题意是这样的：有一棵结点数量为<code>n</code>的树，结点标号为1到<code>n</code>。起始时，结点1是红色的，其他结点都是蓝色的。编程处理以下两种查询：</p><ul><li><code>update(a)</code>：将<code>a</code>更新为红色</li><li><code>query(a)</code>：查询<code>a</code>离最近的红色点的距离</li></ul><p><img src="xenia.png" alt="两种颜色的结点"></p><p>可以立刻想到两种解法：</p><ol><li>查询时做BFS/DFS（<code>O(N)</code>），更新时直接更新（<code>O(1)</code>）</li><li>维护每个结点到最近的红色点的距离，查询时直接查询（<code>O(1)</code>），更新时做BFS/DFS（<code>O(N)</code>）</li></ol><p>显然这两种解法都不够好。重心剖分（Centroid Decomposition，以下简写为CD）则可以在这两种方法之间取得平衡，使得查询和更新的代价都变成<code>O(log(N))</code>。</p><h3 id="重心的定义"><a class="markdownIt-Anchor" href="#重心的定义"></a> 重心的定义</h3><p>记树的总结点数为<code>n</code>，定义树的重心为，移除后使得留下的所有连通分量（树）的大小均不超过<code>n/2</code>的结点。</p><p><img src="centroid-def.gif" alt="一个重心的例子"></p><p>请注意：重心不是中心。</p><h3 id="如何找到树的重心"><a class="markdownIt-Anchor" href="#如何找到树的重心"></a> 如何找到树的重心？</h3><p>下面给出一种计算树的重心的算法。首先任取结点<code>a</code>，以<code>a</code>为树的根结点，计算它的所有子树的大小。如果这些子树的大小均不超过<code>n/2</code>，则<code>a</code>就是重心。否则，必然存在一棵（且只能有一棵——这一点是平凡的）子树，大小超过<code>n/2</code>。记<code>b</code>为该子树的根结点，对<code>b</code>重复上述算法。</p><p><img src="centroid-alg.gif" alt="上述算法的执行过程"></p><p>对<code>b</code>来说，以<code>a</code>为根的子树的大小必然不超过<code>n/2</code>，因此算法不会重复访问已经访问过的结点，因此算法是正确的，它的复杂度是<code>O(n)</code>。</p><p><img src="centroid-alg-proof.png" alt="为什么算法是正确的"></p><p>在具体实现中，以<code>a</code>为根结点，首先用DFS求出每棵子树的大小；然后用DFS寻找重心。因为算法不需要重复访问已经访问过的结点，因此对于每个结点，考虑它的子结点对应的子树大小即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> subSize[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tree[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p)</span><br><span class="line">            subSize[u] += dfs(v, u);</span><br><span class="line">    <span class="keyword">return</span> subSize[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p &amp;&amp; subSize[v] &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(v, u, n);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h3><p>练习1：请证明每棵树最多只有一个重心，或者给出反例。</p><p>反例：如下图。</p><p><img src="one-centroid.png" alt="蓝色和红色结点各表示一个重心"></p><p>练习2：在什么样的树中，中心和重心是相同的？</p><p>我感觉，计算出重心之后，以重心为根的树中，如果深度最大的两棵子树的深度相等或只相差1，那么中心等于重心。</p><h2 id="什么是重心剖分"><a class="markdownIt-Anchor" href="#什么是重心剖分"></a> 什么是重心剖分？</h2><p>树的重心剖分是另一棵树，它递归定义为：</p><ul><li>树根是原树的重心</li><li>树根的子结点是原树中移除重心后留下的子树的重心</li></ul><p><img src="cd.png" alt="一棵树的重心剖分"></p><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p>直接按照定义实现这棵树即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> subSize[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tree[N];  <span class="comment">// 为了方便删除……</span></span><br><span class="line"><span class="keyword">int</span> cd_father[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p)</span><br><span class="line">            subSize[u] += dfs(v, u);</span><br><span class="line">    <span class="keyword">return</span> subSize[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p &amp;&amp; subSize[v] &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(v, u, n);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重心分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs(u, p);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(u, p, n);</span><br><span class="line">    cd_father[centroid] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[centroid])</span><br><span class="line">        <span class="keyword">if</span> (v != p) &#123;</span><br><span class="line">            tree[v].erase(centroid);</span><br><span class="line">            centroid_decomposition(v, centroid);</span><br><span class="line">        &#125;</span><br><span class="line">    tree[centroid].clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3><p>建树的时间复杂度是多少？首先可以给出一个时间复杂度的上界：因为需要对每个结点都执行一次<code>centroid_decomposition</code>，且<code>dfs</code>的代价最多为<code>O(n)</code>，因此时间复杂度最多为<code>O(n^2)</code>。</p><p>不过事实上并没有那么多。对每个结点执行<code>centroid_decomposition</code>时，对应的连通分量大小已经大大减小了，所以<code>dfs</code>的代价也降低了——这是因为根据重心的性质，每个连通分量的大小最多为<code>n/2</code>。事实上这就类似于归并排序的分析：</p><p><img src="complexity.png" alt="每一层的代价之和都是O(n)"></p><p>因为树的高度是<code>O(log(n))</code>，因此总时间复杂度为<code>O(n*log(n))</code>。</p><p>而且实现中移除边的过程不会影响总时间复杂度，因为最多有<code>O(n)</code>条边需要移除，而移除每条边的代价最多是<code>O(log(n))</code>。（当然，你也可以不这么实现，省一点常数。）</p><h3 id="重心剖分的性质"><a class="markdownIt-Anchor" href="#重心剖分的性质"></a> 重心剖分的性质</h3><ol><li>在CD树中，结点属于它的所有祖先对应的连通分量。</li></ol><p><img src="centroid-property.png" alt="结点14属于14、15、11和3对应的连通分量"></p><p>证明：在CD树中，结点<code>a</code>是<code>b</code>的子结点，仅当<code>a</code>属于移除<code>b</code>后产生的连通分量。显然这件事的前提是，<code>a</code>属于<code>b</code>对应的连通分量。（这听起来是平凡的。）</p><ol start="2"><li>原树中结点<code>a</code>到结点<code>b</code>的最短路可以分解成结点<code>a</code>到<code>lca(a, b)</code>和<code>lca(a, b)</code>到<code>b</code>的两条路径，其中<code>lca(a, b)</code>是CD树中<code>a</code>和<code>b</code>的LCA。</li></ol><p><img src="cd-property-2.png" alt="原树中从9到10的最短路可以分解成从9到3的路径和从3到10的路径。"></p><p>证明：由性质1，<code>a</code>和<code>b</code>都属于<code>lca(a, b)</code>对应的连通分量。假定<code>lca(a, b)</code>并不在从<code>a</code>到<code>b</code>的最短路上，则在原树中移除<code>lca(a, b)</code>后，<code>a</code>和<code>b</code>仍然在同一个连通分量中，这意味着该连通分量的重心是<code>a</code>和<code>b</code>的比<code>lca(a, b)</code>更低的共同祖先，这显然是荒谬的。</p><ol start="3"><li>原树中的<code>n^2</code>条路径（此处把退化的路径也算进去了）均可分解成两条路径，这两条路径都属于在CD树中每个结点到它的所有祖先结点的共<code>O(n*log(n))</code>条路径的集合。（听起来真是晦涩……）</li></ol><p>这个性质比较难，但非常重要。以下图为例：</p><p><img src="centroid-property.png" alt="结点14属于14、15、11和3对应的连通分量"></p><p>共有<code>n</code>条从结点14开始的路径。这些路径可以分成以下几类：</p><ol><li><code>a in {14}</code>：从14到14，再从14到<code>a</code></li><li><code>a in {15}</code>：从14到15，再从15到<code>a</code></li><li><code>a in {6, 9, 13}</code>：从14到11，再从11到<code>a</code></li><li><code>a in {1, 2, 4, 5, 7, 8, 10, 12}</code>：从14到3，再从3到<code>a</code></li></ol><p>显然14、15、11和3都是14在CD树中的祖先。这种分类方法的思路是这样的：不是选择路径的两个端点，而是选择两个结点在CD树中的LCA。</p><p>证明1：性质2说明，原树中的每条路径都可以分解成两条路径（<code>a</code>到<code>lca(a, b)</code>，以及<code>lca(a, b)</code>到<code>b</code>）。下面证明从每个结点到它的CD树中祖先结点的路径总数是<code>O(n*log(n))</code>。显然CD树的高度是<code>O(log(n))</code>，共有<code>n</code>个结点，所以祖先总数是<code>O(n*log(n))</code>。</p><p>证明2：这次考虑CD树中每个结点的后代数量。显然根结点的后代总数是<code>n-1</code>，而且每一层的结点的后代总数都是<code>O(n)</code>，因此总路径数为<code>O(n*log(n))</code>。</p><h3 id="练习-2"><a class="markdownIt-Anchor" href="#练习-2"></a> 练习</h3><p>练习3：给定下图中的CD树，求原树。是否有多个可能的答案？</p><p><img src="ex3-tree.png" alt="CD树"></p><p>这棵树看起来好像很有问题，居然有重复结点，算了不管它了。。。不过显然CD树和原树不是一一对应的，举个最简单的例子，如果连通分量只剩下两个结点，那么这两个结点哪一个做重心都可以。</p><p>练习4：证明每棵CD树都是自己的CD树，或者举出反例。</p><p>证明：由CD树的构造过程可知，对于CD树的每棵子树，记其大小为<code>n</code>，去掉根结点后剩下的的每棵子树的大小均不超过<code>n/2</code>。这是因为每棵子树都是和一个联通分量对应的。因此，对CD树做重心剖分时，只需取每层的根结点为重心即可。</p><p>练习5：考虑以下陈述：“对于任意有根树，从<code>a</code>到<code>b</code>的路径都可以分解成从<code>a</code>到<code>lca(a, b)</code>的路径和从<code>lca(a, b)</code>到<code>b</code>的路径，这样我们就可以应用性质3中的方法进行处理。”如果这是真的，我们为什么需要重心剖分？</p><p>答：这确实是真的，但对于高度没有限制的树，这么做没有意义。考虑退化成一条链的树，根结点的后代数量是<code>n-1</code>，深度为1的结点的后代数量是<code>n-2</code>，以此类推，得到的分解路径总数是<code>n(n-1)/2</code>，和树中所有路径总数的数量级相同，没法起到简化表示的作用。</p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><h3 id="codeforces-342e-xenia-and-tree"><a class="markdownIt-Anchor" href="#codeforces-342e-xenia-and-tree"></a> <a href="https://codeforces.com/contest/342/problem/E" target="_blank" rel="noopener">Codeforces 342E. Xenia and Tree</a></h3><h4 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h4><p>略</p><h4 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h4><p>这道题就是上面讲解时用到的例题，应该很好理解。将树进行重心剖分之后，每两个结点之间的距离都可以分解成它们在原树中到重心剖分树中的LCA的距离。这句话听起来太绕了，不如说，对于每两个结点，它们在重心剖分树中的LCA必然会出现在它们在原树中的最短路径上。从这就可以直接推导出，原树中的每条路径都能以两个端点在重心剖分树中的LCA为终点分解成两条路径。</p><p>所以我们可以考虑用<code>ans</code>来维护重心剖分树中每个结点到它的子树中最近的红色结点的距离。初始时，<code>ans[a] = inf</code>（之后才将第一个结点涂成红色）。</p><p><img src="xenia-cd.png" alt="左侧是染色的原树，右侧是重心剖分和连通分量。"></p><p>对于每个<code>update(a)</code>操作，因为<code>a</code>出现在它的祖先结点对应的分量中，所以只需对它的每个祖先结点<code>b</code>，更新<code>ans[b] = min(ans[b], dist(a, b))</code>。由于树的高度为<code>O(log(n))</code>，计算<code>dist(a, b)</code>的复杂度是<code>O(log(n))</code>，因此更新操作的复杂度是<code>O(log^2(n))</code>。</p><p>对于每个<code>query(a)</code>操作，只需对它的所有祖先结点<code>b</code>，取<code>dist(a, b) + ans[b]</code>的最小值。如果记<code>ans[b]</code>对应的结点为<code>c</code>，则我们实际上是把从<code>a</code>到<code>c</code>的路径分解成了从<code>a</code>到<code>b</code>的路径（<code>dist(a, b)</code>）和从<code>b</code>到<code>c</code>的路径（<code>ans[b]</code>）。这意味着<code>dist(a, b) + ans[b]</code>是从<code>a</code>到<code>b</code>对应的连通分量中离<code>b</code>最近的红色结点的距离。查询操作的时间复杂度也是<code>O(log^2(n))</code>。</p><hr><p>我花了特别久的时间debug。模板背错之后出现的那些问题就不说了——一背错就很可能会死循环。首先，照原文中那种删除边的写法是行不通的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs(u, p); <span class="comment">// find the size of each subtree</span></span><br><span class="line">    <span class="keyword">int</span> centroid = dfs(u, p, n); <span class="comment">// find the centroid</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) p = centroid; <span class="comment">// dad of root is the root itself</span></span><br><span class="line">    dad[centroid] = p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each tree resulting from the removal of the centroid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : tree[centroid])</span><br><span class="line">        <span class="comment">// v被删除后，指针就失效了，肯定会挂</span></span><br><span class="line">        tree[centroid].erase(v), <span class="comment">// remove the edge to disconnect</span></span><br><span class="line">        tree[v].erase(centroid), <span class="comment">// the component from the tree</span></span><br><span class="line">        build(v, centroid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成不会产生指针失效的版本也不行，会超时。我目前看到了两种比较好的解决方案：</p><ul><li>仍然用<code>set</code>，但是在<code>for</code>循环中不从<code>centroid</code>对应的<code>set</code>删除，在<code>for</code>循环结束后再统一清空</li><li>改用<code>vector</code>，单独记录删除标记</li></ul><p>然后我想了想，觉得自己的LCA写的恐怕大有问题（因为太久没写了），于是就找了个地方，抄了一下LCA的主要计算过程。这之后我觉得没有什么问题了，但是交上去却持续WA。我感到很困惑，查了又查，却找不到什么错误。最后我找到了一份相当不错的结构和我类似的<a href="https://codeforces.com/contest/342/submission/23224047" target="_blank" rel="noopener">参考代码</a>，抱着“模块化debug”的心情把我的代码中的LCA整个换成了这份代码里的LCA——</p><p>结果竟然就过了！！！</p><p>原来我太久没写LCA，把初始化时求<code>2^k</code>级祖先的内外循环给搞反了。推导<code>father[i][j]</code>时可能需要的<code>father[?][j-1]</code>的第一维是不确定的，因此应该把<code>j</code>放在外层循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][j] = father[father[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">bool</span> deleted[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> subTreeSize[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100002</span>][<span class="number">21</span>];</span><br><span class="line">LL dist[<span class="number">100002</span>];</span><br><span class="line">LL ans[<span class="number">100002</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算父结点和结点深度（用于LCA）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    father[cur][<span class="number">0</span>] = parent == <span class="number">-1</span> ? cur : parent;</span><br><span class="line">    dist[cur] = depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != parent) &#123;</span><br><span class="line">            dfs(u, cur, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][j] = father[father[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算x和y的LCA</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[x] &lt; dist[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> d = dist[x] - dist[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x = father[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i]) &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据LCA和深度计算x和y在树中的距离</span></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = get_lca(x, y);</span><br><span class="line">    <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[fa];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小（每次重心剖分的子树都需要）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    subTreeSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent) &#123;</span><br><span class="line">            get_size(u, cur);</span><br><span class="line">            subTreeSize[cur] += subTreeSize[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent &amp;&amp; subTreeSize[u] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(u, cur, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归进行重心剖分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    get_size(cur, parent);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, parent, subTreeSize[cur]);</span><br><span class="line">    cd_father[centroid] = parent;</span><br><span class="line">    <span class="comment">// 这里采取的则是一种比较愚蠢的策略，单独为结点记录了删除标记……</span></span><br><span class="line">    deleted[centroid] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[centroid])</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent)</span><br><span class="line">            centroid_decomposition(u, centroid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a更新为红色结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = a;</span><br><span class="line">    <span class="comment">// 对于a在CD树中的每个祖先（包括a），更新a到它的距离</span></span><br><span class="line">    <span class="comment">// 注意不是a在CD树中到它的距离！！！</span></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">-1</span>) &#123;</span><br><span class="line">        ans[b] = min(ans[b], get_dist(a, b));</span><br><span class="line">        b = cd_father[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询a和最近的红色结点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = a;</span><br><span class="line">    LL x = <span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">// 对于a在CD树中的每个祖先（包括a），取答案为（a到该祖先的距离+该祖先到最近红色结点距离）的最小值</span></span><br><span class="line">    <span class="comment">// 注意距离不是CD树中的距离！！！</span></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">-1</span>) &#123;</span><br><span class="line">        x = min(x, ans[b] + get_dist(a, b));</span><br><span class="line">        b = cd_father[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> t, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些必要的初始化</span></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    lca_init();</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans[i] = <span class="number">1e9</span>;</span><br><span class="line">    update(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;t, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) update(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codeforces-321c-ciel-the-commander"><a class="markdownIt-Anchor" href="#codeforces-321c-ciel-the-commander"></a> <a href="https://codeforces.com/contest/321/problem/C" target="_blank" rel="noopener">Codeforces 321C. Ciel the Commander</a></h3><h4 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h4><p>给定一棵树，要求把上面的所有结点用<code>A</code>到<code>Z</code>标记，使得对于任意两个标记相同的结点，它们之间的最短路上至少有一个标记（字典序）更小的结点。</p><h4 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h4><p>只要会重心剖分，想到这道题要用到重心剖分并不难（……这好像是句废话，考虑到这道题是作为例题出现的……），所以难点在于如何证明重心剖分得到的是最优解。（对于实现而言，这并不是个难点）</p><p><a href="https://codeforces.com/blog/entry/8192" target="_blank" rel="noopener">题解</a>里给出了两种证明思路。第一种是自顶向下构造。显然，rank为A的结点只能有一个。选定一个结点为rank A之后，树会被分成几个连通分量，这些连通分量之间不会有非法路径（因为必须要通过这个结点），所以可以单独考虑这些连通分量，于是我们得到了一个递归解法。问题是应该怎么选择A。单从连通分量的大小来考虑，我们希望这些连通分量的大小尽量小，所以不妨取rank A结点为重心。然后判断CD树的高度是否大于26就行。</p><p>不过，问题是我觉得不能单从连通分量的大小来考虑。但到底怎么考虑比较好，这个我也不知道……</p><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> subSize[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_depth[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxDepth;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != p)</span><br><span class="line">            subSize[cur] += get_size(u, cur);</span><br><span class="line">    <span class="keyword">return</span> subSize[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != p &amp;&amp; subSize[u] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(u, cur, n);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get_size(cur, p);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, p, n);</span><br><span class="line">    cd_father[centroid] = p;</span><br><span class="line">    cd_depth[centroid] = depth;</span><br><span class="line">    maxDepth = max(depth, maxDepth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[centroid])</span><br><span class="line">        <span class="keyword">if</span> (u != p) &#123;</span><br><span class="line">            g[u].erase(centroid);</span><br><span class="line">            centroid_decomposition(u, centroid, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    g[centroid].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].insert(v);</span><br><span class="line">        g[v].insert(u);</span><br><span class="line">    &#125;</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxDepth &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (cd_depth[i] + <span class="string">'A'</span>) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要参考了&lt;a href=&quot;https://codeforces.com/blog/entry/52492&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Centroid Decomposition&lt;/a&gt;和&lt;a href=&quot;https://med
      
    
    </summary>
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/categories/Codeforces/"/>
    
    
      <category term="alg:Centroid Decomposition" scheme="https://zhanghuimeng.github.io/tags/alg-Centroid-Decomposition/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Global Round 1总结</title>
    <link href="https://zhanghuimeng.github.io/post/codeforces-global-round-1/"/>
    <id>https://zhanghuimeng.github.io/post/codeforces-global-round-1/</id>
    <published>2019-02-14T14:38:41.000Z</published>
    <updated>2019-02-14T14:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为写总结和做题实在太艰难了，我决定以后CF每场比赛只写一篇总结……</p><h2 id="1110a"><a class="markdownIt-Anchor" href="#1110a"></a> 1110A</h2><p>题目来源：<a href="https://codeforces.com/contest/1110/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/A</a></p><p>提交次数：1/1</p><h3 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h3><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><h2 id="1110d"><a class="markdownIt-Anchor" href="#1110d"></a> 1110D</h2><p>题目来源：<a href="https://codeforces.com/contest/1110/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/D</a></p><p>提交次数：1/1</p><h3 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h3><p>给定若干个1和m之间的整数，定义triplet为形如<code>(x, x, x)</code>或<code>(x, x+1, x+2)</code>的元组，问这些整数最多一共能组成多少个triplet？</p><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>这道题有一个非常必要的观察：如果有大于等于三个的形如<code>[x, x+1, x+2]</code>的triplet，那么完全可以把其中的三个替换成<code>[x, x, x]</code>，<code>[x+1, x+1, x+1]</code>和<code>[x+2, x+2, x+2]</code>。这也就意味着对于每一个<code>x</code>，形如<code>[x-2, x-1, x]</code>的triplet最多只有2个。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>然后我就想了一种错漏百出的方法，调了一个下午，终于调出来了。</p><p>令<code>f[i][x][y]</code>表示考虑前<code>i-1</code>个数组成的triplet，<code>a[i-1]</code>还剩<code>x</code>个，<code>a[i-2]</code>还剩<code>y</code>个时的triplet总数。我心想：既然连续的triplet最多只有2个，那么<code>x</code>和<code>y</code>的上限就都是2。（后来事实证明这很离谱）于是列出向后的转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不组成形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">0</span>) % <span class="number">3</span>][x - <span class="number">0</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i]- <span class="number">0</span>) % <span class="number">3</span>][x - <span class="number">0</span>], f[i][x][y] + <span class="number">0</span> + (a[i] - <span class="number">0</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 组成一个形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">1</span>) % <span class="number">3</span>][x - <span class="number">1</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i] - <span class="number">1</span>) % <span class="number">3</span>][x - <span class="number">1</span>], f[i][x][y] + <span class="number">1</span> + (a[i] - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 组成两个形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">2</span>) % <span class="number">3</span>][x - <span class="number">2</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i] - <span class="number">2</span>) % <span class="number">3</span>][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - <span class="number">2</span>) / <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>跑一下看看，发现错得离谱。思考了一段时间之后，发觉这个转移方程“太准确了”。比如说，<code>a[4]=2</code>时，<code>f[4][2][2]</code>可以转移到<code>f[5][1][1]</code>，但也应该可以转移到<code>f[5][0][1]</code>和<code>f[5][1][0]</code>（丢掉一些4和3也是可以的）。于是把转移方程修改如下，加入了后面两维的更多可能性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i], <span class="number">2</span>); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">0</span>; j++) &#123;</span><br><span class="line">            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">0</span> + (a[i] - k) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">1</span>, <span class="number">2</span>); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">1</span> + (a[i] - k - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">2</span>, <span class="number">2</span>); k++) &#123;</span><br><span class="line">        f[i+<span class="number">1</span>][k][x - <span class="number">2</span>] = </span><br><span class="line">            max(f[i+<span class="number">1</span>][k][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - k - <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果还是不对。经过更加漫长的debug，我意识到这种做法里的上限不能是2，因为它表示的是整体剩下的上限，而不是一共有多少个以它结尾的triplet。于是我直接把上限改成了6（既然有三种triplet的可能性），然后就过了（虽然耗时非常长）。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000005</span>][<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> *a = cnt + <span class="number">1</span>;  <span class="comment">// 处理i-2的边缘情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= min(<span class="number">6</span>, a[i<span class="number">-1</span>]); x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= min(<span class="number">6</span>, a[i<span class="number">-2</span>]); y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i], <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">0</span>; j++) &#123;</span><br><span class="line">                            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">0</span> + (a[i] - k) / <span class="number">3</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">1</span>, <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">1</span> + (a[i] - k - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">2</span>, <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        f[i+<span class="number">1</span>][k][x - <span class="number">2</span>] = </span><br><span class="line">                            max(f[i+<span class="number">1</span>][k][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - k - <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">6</span>; x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= <span class="number">6</span>; y++)</span><br><span class="line">            ans = max(ans, f[m + <span class="number">2</span>][x][y]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1110f"><a class="markdownIt-Anchor" href="#1110f"></a> 1110F</h2><p>题目来源：<a href="https://codeforces.com/contest/1110/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/F</a></p><p>提交次数：1/1</p><h3 id="题意-3"><a class="markdownIt-Anchor" href="#题意-3"></a> 题意</h3><p>给定一棵带权树，所有结点按DFS遍历顺序从1到n编号，回答q次询问：给定整数v、l和r，找到从结点v到编号在l和r之间的叶结点之间的最短距离。</p><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>题解里给出了一种很类似于可持久化线段树的离线方法：对根结点记录它到每个叶子的距离，然后从根结点走到需要查询的结点v，同时根据边权更新它到叶子的距离。不过并不是很详细。<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup></p><p>另一种方法是使用重心剖分（centroid decomposition，我就简称CD了）。首先对树进行重心剖分。对于每个叶结点，将它存储在它在重心剖分树的每个祖先结点中，也就是对重心剖分树中的每个结点，维护它子树中的叶结点的一个list，包括编号和（到该结点的）距离。需要回答询问时，对于结点v在重心剖分树中的每个祖先结点，查询该结点对应的叶结点中，编号在l和r之间的叶结点中的最短距离。这一步可以用线段树。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>不妨举个例子。这是CF上的第五个测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">1 12</span><br><span class="line">2 89</span><br><span class="line">3 20</span><br><span class="line">3 37</span><br><span class="line">3 15</span><br><span class="line">2 43</span><br><span class="line">7 8</span><br><span class="line">8 31</span><br><span class="line">1 52</span><br><span class="line">8 8 9</span><br><span class="line">1 1 8</span><br><span class="line">7 7 10</span><br><span class="line">4 3 4</span><br><span class="line">9 3 8</span><br><span class="line">7 7 9</span><br><span class="line">6 7 10</span><br><span class="line">2 3 7</span><br><span class="line">6 8 10</span><br><span class="line">7 1 4</span><br></pre></td></tr></table></figure><p><img src="tree.jpg" alt="左侧是原树，右侧是重心剖分树，以及子树中叶结点到当前结点的距离"></p><p>真的去写的时候，照例遇到了一万个问题，不过幸好这次有一份写得相当不错的代码<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>可以参照，省了很多时间。重心剖分的模板每次都背错这种愚蠢的事情就不说了，不过仍然会遇到如何组织树的这个问题。之前已经说过了，其实用修正过写法的<code>set</code>和<code>vector</code>加上删除标志都可以接受；但这次需要存边权，换成<code>map</code>听起来有点不太像一棵树。（倒不如说是我觉得这样遍历太麻烦了）所以换成了<code>vector&lt;pair&lt;int, long long&gt;&gt;</code>。</p><p>除了重心剖分以外，为了计算距离，当然LCA也是需要的。这次我虽然基本没有背错LCA模板，但我忘记这是棵带权树了。当然改起来很容易，把深度改成到根结点的距离就行。</p><p>初始化的部分倒是挺好写的——如果某个结点是叶子，那么就把它加到它在CD树的所有祖先（包括自己）的叶结点list中，同时计算距离。在这一步（或者不如说是下一步）中，我没有意识到这个list可能是空的，因为CD树的叶结点不一定是原树中的叶结点，所以仍然花了一些debug的时间。</p><p>所以下面得给每个结点都建一棵线段树。还采用自顶向下的那种方法就实在太冗长了，于是我直接抄了<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>中的<a href="https://codeforces.com/blog/entry/18051" target="_blank" rel="noopener">zkw_cf线段树</a>，这个东西是对zkw线段树的改进，不仅是自底向上的，而且只需要使用<code>2*n</code>的空间，不需要和2的幂对齐了。不过我还没太搞明白这是怎么做到的，就直接抄了。。。</p><p>下面这个问题花了我很久去debug，听起来十分愚蠢，但事实就是这样的……CD树上每个叶结点的线段树都是做了离散化的，只包含有的叶结点的编号。所以需要查的时候，显然需要找到编号的index。所以下面的问题是：对于排好序的<code>pair&lt;int, LL&gt; a[n]</code>和<code>l &lt;= r</code>，如何找到最左边的满足<code>a[i].first &gt;= l</code>的<code>i</code>和最右边的满足<code>a[i].first &lt;= r</code>的<code>i</code>？答案当然是二分查找，但是过程相当tricky……总之我最后也是又抄代码了。</p><p>最后一个问题很傻逼。我又忘记在CD树中从下向上查时，两个结点的距离不能用它们到中间结点的距离的和来推导了，这只能重新直接在原树中算……</p><p>总的来说这算法比较慢。我现在懒得去分析复杂度了……</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> q, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, LL&gt;&gt; tree[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">bool</span> deleted[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">500005</span>][<span class="number">30</span>];</span><br><span class="line">LL dist[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> level[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> subSize[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抄来的zkw_cf线段树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, LL&gt;&gt; leaves;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = leaves.size();</span><br><span class="line">        sort(leaves.begin(), leaves.end());</span><br><span class="line">        tree.resize(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            tree[n + i] = leaves[i].second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            tree[i] = min(tree[<span class="number">2</span> * i], tree[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> convert = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leaves.size() == <span class="number">0</span> || r &lt; leaves.front().first || leaves.back().first &lt; l) <span class="keyword">return</span> <span class="number">1e16</span>;</span><br><span class="line">        <span class="keyword">if</span> (convert) &#123;</span><br><span class="line">            <span class="comment">// 抄的代码（注意r是开区间，这是这种线段树写法的要求）</span></span><br><span class="line">            l = lower_bound(leaves.begin(), leaves.end(), make_pair(l, (LL) <span class="number">-1</span>)) - leaves.begin();</span><br><span class="line">            r = lower_bound(leaves.begin(), leaves.end(), make_pair(r + <span class="number">1</span>, (LL) <span class="number">-1</span>)) - leaves.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">1e16</span>;</span><br><span class="line">        <span class="keyword">for</span> (l += n, r += n; l &lt; r; l /= <span class="number">2</span>, r /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) ans = min(ans, tree[l++]);</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) ans = min(ans, tree[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; segTree[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, LL d, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    dist[cur] = d;</span><br><span class="line">    level[cur] = l;</span><br><span class="line">    father[cur][<span class="number">0</span>] = parent == <span class="number">-1</span> ? cur : parent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][i].first != parent)</span><br><span class="line">            dfs(tree[cur][i].first, cur, d + tree[cur][i].second, l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dep = <span class="number">1</span>; dep &lt; <span class="number">30</span>; dep++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][dep] = father[father[i][dep<span class="number">-1</span>]][dep<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level[x] &lt; level[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> d = level[x] - level[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x = father[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">            x = father[x][i], y = father[y][i];</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[get_lca(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs_sub_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    subSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = tree[cur][i].first;</span><br><span class="line">        <span class="keyword">if</span> (u != parent &amp;&amp; !deleted[u])</span><br><span class="line">            subSize[cur] += dfs_sub_size(u, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subSize[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][i].first != parent &amp;&amp; !deleted[tree[cur][i].first] </span><br><span class="line">            &amp;&amp; subSize[tree[cur][i].first] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(tree[cur][i].first, cur, n);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs_sub_size(cur, parent);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, parent, n);</span><br><span class="line">    cd_father[centroid] = parent;</span><br><span class="line">    deleted[centroid] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[centroid].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = tree[centroid][i].first;</span><br><span class="line">        <span class="keyword">if</span> (u != parent &amp;&amp; !deleted[u])</span><br><span class="line">            centroid_decomposition(u, centroid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    lca_init();</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].size() != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 是叶子</span></span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="number">-1</span>) &#123;</span><br><span class="line">            segTree[cur].leaves.emplace_back(i, get_dist(i, cur));</span><br><span class="line">            cur = cd_father[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        segTree[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">int</span> p = v;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// upDist并不是累加的！（某个bug曾经出现的位置）</span></span><br><span class="line">        ans = min(ans, segTree[p].query(l, r, <span class="literal">true</span>) + get_dist(v, p));</span><br><span class="line">        p = cd_father[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;p, &amp;w);</span><br><span class="line">        tree[i].emplace_back(p, w);</span><br><span class="line">        tree[p].emplace_back(i, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v, l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;v, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(v, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65079" target="_blank" rel="noopener">The Editorial of the First Codeforces Global Round</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65059?#comment-490727" target="_blank" rel="noopener">Codeforces - comment of gaurav172</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://codeforces.com/contest/1110/submission/49592451" target="_blank" rel="noopener">tfg’s solution for 1110F</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为写总结和做题实在太艰难了，我决定以后CF每场比赛只写一篇总结……&lt;/p&gt;
&lt;h2 id=&quot;1110a&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1110a&quot;&gt;&lt;/a&gt; 1110A&lt;/h2&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/categories/Codeforces/"/>
    
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 992. Subarrays with K Different Integers</title>
    <link href="https://zhanghuimeng.github.io/post/Leetcode%20992.%20Subarrays%20with%20K%20Different%20Integers/"/>
    <id>https://zhanghuimeng.github.io/post/Leetcode 992. Subarrays with K Different Integers/</id>
    <published>2019-02-12T17:30:55.000Z</published>
    <updated>2019-02-14T00:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/subarrays-with-k-different-integers/description/</a></p><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>两个滑动窗口：28.89%（340ms）</li><li>一个滑动窗口：</li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定数组<code>A</code>，求<code>A</code>中恰好含有<code>k</code>个不同元素的子数组的数量。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>从数据范围来看，显然<code>N^2</code>的算法是过不了的。所以比赛的时候我就想了一种这样的算法：</p><ul><li>遍历数组元素</li><li>用指针<code>i</code>和<code>j</code>分别表示从当前元素开始，含有<code>k</code>个不同元素的最短子数组的结尾元素和最长子数组的结尾元素</li><li>用两个<code>map</code>分别维护这两个子数组中的元素</li><li>需要移动到下一个元素时，从<code>map</code>中删除当前元素，并移动指针直到满足要求为止。显然<code>i</code>和<code>j</code>的位置是递增的</li></ul><p>这就相当于维护了两个滑动窗口。显然每个元素最多进出每个集合一次，所以整体复杂度应该是<code>O(N)</code>。（虽然常数实在很大……）</p><p>这个算法应该和<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/solution/" target="_blank" rel="noopener">题解</a>是很相似的。</p><hr><p>当然别人还有一些更神奇的做法，比如<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC++Python-Sliding-Window-with-Video" target="_blank" rel="noopener">lee215的另辟蹊径的方法</a>。他做了一件这样的事情：</p><ul><li>对于某个<code>K</code>，遍历数组元素</li><li>对于每个<code>A[j]</code>，找到使得<code>A[i...j]</code>中恰好有<code>K</code>个不同元素的最大的<code>i</code>，记<code>j-i+1</code>为以<code>j</code>结尾的最多有<code>K</code>个不同元素的子数组的数量</li><li>令<code>f(K)</code>表示数组中最多有<code>K</code>个不同元素的子数组的数量</li><li>则所求结果为<code>f(K) - f(K-1)</code></li></ul><p>还真是一个独到的想法，虽然有些不明白他是怎么想出来的……</p><hr><p>还有一种更有趣的方法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，没有显式地维护两个滑动窗口。我觉得这种方法的核心思路其实是这样的：</p><ul><li>对于每一个数组元素<code>A[i]</code>，记<code>sMin</code>为使得<code>A[sMin...i]</code>中包含<code>K</code>个不同元素的最小index，<code>sMax</code>为使得<code>A[sMax...i]</code>中包含<code>K</code>个不同元素的最大index</li><li>那么显然<code>A[sMin...i]</code>和<code>A[sMax...i]</code>包含的元素是一样的（虽然可能个数不同）</li><li>考虑从<code>A[i]</code>转移到<code>A[i+1]</code>的情况：<ul><li>如果<code>A[i+1]</code>是窗口中已经出现过的元素，则<code>sMin</code>不变，<code>sMax</code>可能会减小</li><li>如果<code>A[i+1]</code>是窗口中没有出现过的元素，则<code>sMin = sMax + 1</code>，<code>sMax &gt;= sMin</code></li></ul></li><li>所以维护<code>sMax</code>对应的小窗口就够了。</li></ul><hr><p>以及，有一个可以大幅度提速的优化。题目里给了数组元素的范围（<code>&lt;=N</code>），因此可以用数组代替<code>map</code>。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="两个滑动窗口"><a class="markdownIt-Anchor" href="#两个滑动窗口"></a> 两个滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; beginMap;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; endMap;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end1, end2 = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beginMap.size() &lt; K) &#123;</span><br><span class="line">                beginMap[A[i]]++;</span><br><span class="line">                endMap[A[i]]++;</span><br><span class="line">                <span class="keyword">if</span> (beginMap.size() == K) end1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (endMap.find(A[i]) == endMap.end()) &#123;</span><br><span class="line">                    end2 = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                endMap[A[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beginMap.size() &lt; K) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// end1和end2是两个窗口结尾的指针</span></span><br><span class="line">        ans += end2 - end1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            beginMap[A[i - <span class="number">1</span>]]--;</span><br><span class="line">            endMap[A[i - <span class="number">1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span> (beginMap[A[i - <span class="number">1</span>]] == <span class="number">0</span>) beginMap.erase(A[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (endMap[A[i - <span class="number">1</span>]] == <span class="number">0</span>) endMap.erase(A[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span> (end1 &lt; A.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beginMap.size() == K) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end1++;</span><br><span class="line">                beginMap[A[end1]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (beginMap.size() &lt; K) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (end2 &lt; A.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (endMap.size() &lt; K || endMap.size() == K &amp;&amp; endMap.find(A[end2 + <span class="number">1</span>]) != endMap.end()) &#123;</span><br><span class="line">                    end2++;</span><br><span class="line">                    endMap[A[end2]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (endMap.size() &lt; K) <span class="keyword">break</span>;</span><br><span class="line">            ans += end2 - end1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个滑动窗口"><a class="markdownIt-Anchor" href="#一个滑动窗口"></a> 一个滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sMin = <span class="number">0</span>, sMax = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// sMin不变，只修改sMax</span></span><br><span class="line">            <span class="keyword">if</span> (window.size() &lt; K || window.find(A[i]) != window.end()) &#123;</span><br><span class="line">                window[A[i]]++;</span><br><span class="line">                <span class="keyword">while</span> (window.size() == K &amp;&amp; window[A[sMax]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    window[A[sMax]]--;</span><br><span class="line">                    sMax++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// sMin和sMax都改变</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                window[A[i]]++;</span><br><span class="line">                sMin = sMax + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (window.size() &gt;= K) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.size() == K &amp;&amp; window[A[sMax]] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    window[A[sMax]]--;</span><br><span class="line">                    <span class="keyword">if</span> (window[A[sMax]] == <span class="number">0</span>) window.erase(A[sMax]);</span><br><span class="line">                    sMax++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (window.size() == K) ans += sMax - sMin + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++-with-picture-7-lines-56-ms" target="_blank" rel="noopener">votrubac’s solution - C++ with picture, 7 lines 56 ms</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/subarrays-with-k-different-integers/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leet
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 991. Broken Calculator</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-991-broken-calculator/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-991-broken-calculator/</id>
    <published>2019-02-11T15:00:35.000Z</published>
    <updated>2019-02-13T17:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/broken-calculator/description/" target="_blank" rel="noopener">https://leetcode.com/problems/broken-calculator/description/</a></p><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：100.00%（4ms）</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定两个数<code>X</code>和<code>Y</code>，可以对<code>X</code>执行以下两种操作：</p><ul><li>乘2</li><li>减1</li></ul><p>问最少需要对<code>X</code>执行多少次操作才能将<code>X</code>变成<code>Y</code>？（<code>X</code>和<code>Y</code>的范围都是1e9）</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>比赛的时候我居然首先就写了一个BFS，然后自然是超时了……</p><p>后来就思考怎么用数学方法解决，也没想出来，各种各样奇怪的贪心大部分也是错的。</p><p>后来想到了对<code>X</code>的操作就等同于对<code>Y</code>的除2和加1两种操作，不过想到了也没什么大的突破……</p><p>然后就没做出来……</p><hr><p>这道题考虑对<code>Y</code>的操作比考虑对<code>X</code>的操作要更容易。如果对<code>Y</code>加1两次再除2，显然不如先除2再加1，因此不会出现两次连续的加1操作。题解<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>是这么说的，不过我感觉有一点不太严谨。倒不如这么说：首先假设有一个最优的操作顺序，需要除2<code>n</code>次，且在第一次除2之前需要加1<code>a[0]</code>次，在第二次除2之前需要加1<code>a[1]</code>次，……，在最后一次除2之后需要加1<code>a[n]</code>次。此时总操作次数为<code>a[0] + a[1] + ... + a[n] + n</code>。假如存在<code>i &lt; n</code>且<code>a[i] &gt; 1</code>，那显然可以把多余的+1操作下移，变成<code>a'[i] = a[i] - 2 * (a[i]/2)</code>，<code>a'[i+1] = a[i+1] + a[i]/2</code>，总操作次数减少<code>a[i]/2</code>次。如果<code>a'[i+1]</code>仍然大于1，则可以继续尝试下移，直到除了<code>a[n]</code>以外的所有<code>a[i]</code>都变成0或1为止。</p><p>事实上我大概是做了一个Exchange类型的贪心证明……</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Y &gt; X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Y % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Y /= <span class="number">2</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Y = (Y + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + (X - Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/broken-calculator/solution/" target="_blank" rel="noopener">Leetcode Official Solution for 991. Broken Calculator</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/broken-calculator/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Math" scheme="https://zhanghuimeng.github.io/tags/alg-Math/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 990. Satisfiability of Equality Equations</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-990-satisfiability-of-equality-equations/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-990-satisfiability-of-equality-equations/</id>
    <published>2019-02-11T14:52:31.000Z</published>
    <updated>2019-02-11T14:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/description/" target="_blank" rel="noopener">https://leetcode.com/problems/satisfiability-of-equality-equations/description/</a></p><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：16ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一系列等式，每个等式形如<code>a==b</code>或<code>a!=b</code>，变量名为单个英文小写字母，问这些等式组能否成立？</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>这道题的思路很简单：首先将所有<code>a==b</code>等式转化成<code>a</code>和<code>b</code>之间的连边，然后做并查集或DFS，然后再判断形如<code>a!=b</code>的等式中的两个变量是否在同一个连通集中。总之用并查集和DFS都差不多……</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>所以我就直接写了并查集……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _fa[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            _fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> _fa[x] = fa(_fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = fa(x);</span><br><span class="line">        y = fa(y);</span><br><span class="line">        _fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'='</span>)</span><br><span class="line">                merge(s[<span class="number">0</span>] - <span class="string">'a'</span>, s[<span class="number">3</span>] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">                <span class="keyword">if</span> (fa(s[<span class="number">0</span>] - <span class="string">'a'</span>) == fa(s[<span class="number">3</span>] - <span class="string">'a'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/satisfiability-of-equality-equations/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lee
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Depth-first Search" scheme="https://zhanghuimeng.github.io/tags/alg-Depth-first-Search/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>翻译：计算几何（USACO）</title>
    <link href="https://zhanghuimeng.github.io/post/computational-geometry-usaco-translation/"/>
    <id>https://zhanghuimeng.github.io/post/computational-geometry-usaco-translation/</id>
    <published>2019-02-10T22:23:01.000Z</published>
    <updated>2019-02-11T14:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。</p><!-- Prerequisites --><h2 id="先决条件"><a class="markdownIt-Anchor" href="#先决条件"></a> 先决条件</h2><!-- Graph TheoryShortest Path --><blockquote><ul><li>图论</li><li>最短路</li></ul></blockquote><!-- Tools --><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><!-- This module discusses several algorithms that calculate various geometric properties, mostly based on only two operations described below: cross product and arctangent. --><blockquote><p>本节讨论了几种用于计算各类几何属性的算法，主要基于下面描述的两种操作：叉积和反正切。</p></blockquote><!-- Cross Product --><h3 id="叉积"><a class="markdownIt-Anchor" href="#叉积"></a> 叉积</h3><!-- The cross product of u and v is written as u x v. Computationally, the cross product of two three-dimensional vectors u and v is the vector determinant of the following matrix (where i, j, and k are unit vectors in the x, y, and z directions respectively):  --><blockquote><p>u和v的叉积写作u x v。在计算中，两个三维向量u和v的叉积是下列矩阵的矢量行列式（其中i、j和k分别是x、y和z方向的单位向量）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| i  j  k  |</span><br><span class="line">| ux uy uz |</span><br><span class="line">| vx vy vz |</span><br></pre></td></tr></table></figure><!-- That equation works out to: --><blockquote><p>这个式子的值为：</p></blockquote><blockquote><p>(uyvz-vyuz)i + (uzvx-uxvz)j + (uxvy-uyvx)k</p></blockquote><p><img src="geom6.gif" alt></p><!-- This definition can be used for vectors in two dimensions by using three-dimensional vectors with a z component of 0. The resulting vector will only have a z value. --><blockquote><p>通过将三维向量的z分量置为0，这一定义可用于二维向量。得到的向量只有z分量有值。</p></blockquote><!-- The cross product has three properties: --><blockquote><p>叉积有三条性质：</p></blockquote><!-- The cross product of two vectors is perpendicular to both vectors.The length of the cross product is equal to the product of:the length of u,the length of v, andthe sine of the angle between the vectors. --><blockquote><ul><li>两个向量的<em>叉积</em>垂直于这两个向量。</li><li>叉积的长度等于以下几项的乘积：<ul><li>u的长度</li><li>v的长度</li><li>u和v夹角的正弦值</li></ul></li></ul></blockquote><!-- Of the two different directions that are perpendicular to both u and v, the direction the cross product points depends on whether u is ``to the right'' of v or ``to the left.''  --><blockquote><p>在与u和v垂直的两个不同方向中，叉积指向的方向取决于u是在v的“右边”还是“左边”。</p></blockquote><p><img src="geom7.gif" alt></p><p>这就是右手定则吧。</p><!-- Dot product --><h3 id="点积"><a class="markdownIt-Anchor" href="#点积"></a> 点积</h3><!-- The dot product of two vectors u and v is a scalar written as u · v. Computationally, it is defined in three dimensions as: uxvx + u yvy + uzv z --><blockquote><p>两个向量u和v的点积是写作u·v的标量。在计算中，它在三维向量中定义为： uxvx + uyvy + uzvz</p></blockquote><!-- The dot product is actually equal to the product of: --><blockquote><p>点积实际上等于以下几项的乘积：</p></blockquote><!-- the length of uthe length of vthe cosine of the angle between u and v. --><blockquote><ul><li>u的长度</li><li>v的长度</li><li>u和v之间夹角的余弦值。</li></ul></blockquote><!-- Presuming u and v are non-zero, if the dot product if negative, u and v make an angle greater than 90 degrees. If it is zero, then u and v are perpendicular. If u cdot v is positive, then the two vectors form an acute angle. --><blockquote><p>假定u和v不为零，如果点积为负，则u和v的夹角大于90度。如果它为零，则u和v垂直。如果点积为正，则两个向量的夹角为锐角。</p></blockquote><!-- Arctangent --><h3 id="反正切"><a class="markdownIt-Anchor" href="#反正切"></a> 反正切</h3><!-- The arctangentfunction calculates the (an) angle whose tangent is its argument and generally returns a real number between -pi/2 and pi/2. An additional function in C, atan2, takes two arguments: a DELTA y value and a DELTA x value (in that order!). It determines the angle between the given vector and the positive x axis and returns a value between -pi and pi. This has the advantage of removing concerns about dividing by zero or writing code to repair angles in order to handle the negative x cases. The atan2 function is almost always easier to use than the simpler atan function that takes only one argument. --><blockquote><p>反正切函数计算其正切值等于它的参数的角度，通常返回-pi/2和pi/2之间的一个实数。C中的函数<code>atan2</code>接收两个参数：y轴的差值和x轴的差值（按此顺序！）。它确定给定向量和x轴正半轴之间的角度，并返回一个-pi和pi之间的值。这可以解决除零或需要撰写代码处理x轴负半轴的问题。该<code>atan2</code>函数几乎总是比简单的只有一个参数的反正切函数容易使用。</p></blockquote><p>显然如果只接收一个参数，无法处理向量和x轴垂直的情况（因为会发生除0问题），而且只有正负也无法说明是和正半轴还是负半轴的夹角。</p><!-- Particular Debugging Problems --><h2 id="调试中的特殊问题"><a class="markdownIt-Anchor" href="#调试中的特殊问题"></a> 调试中的特殊问题</h2><!-- The main problem with geometric problems is that they spawn a lot of special cases. Be on the lookout for these special cases and make sure your program works for all of them. --><blockquote><p>计算几何题的主要问题是它们会产生<strong>许多</strong>特殊情况。请留意这些特殊情况，并<strong>确保你的程序适用于所有这些情况</strong>。</p></blockquote><!-- Floating point calculations also create a new set of problems. Floating point calculations are rarely precise, as the computer only maintains so many bits (digits) of accuracy: be aware of this. In particular, when checking if two values are equal, check to see if they are within some small tolerance of each other not precisely equal. --><blockquote><p>浮点数计算也会产生很多新问题。浮点计算很少是精确的，因为计算机只准确保留了若干比特（位）：要注意这一点。特别注意，在检查两个值是否相等时，不要检查它们是否精确相等，而是检查它们之间的差值是否小于某个范围。</p></blockquote><!-- Geometric Algorithms --><h2 id="计算几何算法"><a class="markdownIt-Anchor" href="#计算几何算法"></a> 计算几何算法</h2><!-- Here are some of snippets that can help you solve geometry problems. --><blockquote><p>下面是一些可以帮助你解决计算几何问题的代码片段。</p></blockquote><!-- Area of Triangle --><h3 id="三角形面积"><a class="markdownIt-Anchor" href="#三角形面积"></a> 三角形面积</h3><!-- To calculate the area of a triangle with vertices (a, b, c), pick a vertex (say a) and create a vector to the other two vertices (let u = b - a, and v = c - a). The area of the triangle (a, b, c) is one half the length of cross product u x v. --><blockquote><p>要计算顶点为(a，b，c)的三角形的面积，选择一个顶点（比如说a），并创建从a指向另外两个顶的向量（令u = b - a，v = c - a）。则三角形(a，b，c)的面积是u和v叉积长度的一半。</p></blockquote><p><img src="geom1.gif" alt></p><!-- An alternative method to find the area of triangle is to use Hero's formula. If the lengths of the sides of a triangle are a, b, and c, let s = (a+b+c)/2. The area of the triangle is then --><blockquote><p>另一种计算三角形面积的方法是海伦公式。如果三角形的三条边长度分别为a，b，c，令s = s = (a+b+c)/2，则三角形的面积为</p></blockquote><!-- sqrt(s* (s-a)*(s-b)*(s-c)) . --><blockquote><p>sqrt(s*(s-a)*(s-b)*(s-c))</p></blockquote><!-- Are Two Line Segments Parallel? --><h3 id="两条线段是否平行"><a class="markdownIt-Anchor" href="#两条线段是否平行"></a> 两条线段是否平行？</h3><!-- To check if two line segments are parallel, create vectors along each line segment and check to see if their cross product is (almost) zero. --><blockquote><p>为了检查两条线段是否平行，请沿每条线段创建向量，并检查它们的叉积是否（几乎）为零。</p></blockquote><!-- Area of polygon --><h3 id="多边形面积"><a class="markdownIt-Anchor" href="#多边形面积"></a> 多边形面积</h3><!-- The area of a polygon with vertices (x 1, y 1), ..., (x n, y n) is equal to the determinant:  --><blockquote><p>顶点为(x1, y1), …，(xn, yn)的多边形的面积等于行列式：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1   | x1 x2 ... xn |</span><br><span class="line">---  |              |</span><br><span class="line"> 2   | y1 y2 ... yn |</span><br></pre></td></tr></table></figure><!-- where the determinate is defined to be similar to the 2 by 2 determinant: x1 y2 + x2y3 + ... + xn y1 - y1 x2 - y2x3 - ... - yn x1 --><blockquote><p>其中行列式的定义类似于2*2的行列式：x1y2 + x2y3 + … + xny1 - y1x2 - y2x3 - … - ynx1</p></blockquote><p>不过我觉得我一般只会把多边形分成若干个三角形来算……</p><!-- Distance from a point to a line --><h3 id="点到直线的距离"><a class="markdownIt-Anchor" href="#点到直线的距离"></a> 点到直线的距离</h3><!-- The distance from a point P to a line AB is given by the magnitude of the cross product. In particular, d(P,AB) = |(P - A) x (B - A)| / | B - A| . --><blockquote><p>从点P到线段AB的距离等于叉积的大小，即d(P，AB) = |(P-A）x (B-A)| / | B - A | 。</p></blockquote><!-- To determine the distance from a point P to the plane defined by A, B, and C, let n = (B - A) x (C - A). The distance is then give by the following equation: d(P,ABC) = (P-A) · n / |n|. --><blockquote><p>为了确定从点P到由点A、B和C定义的平面的距离，令n =(B-A) × (C-A)。下列等式即给出距离：d(P，ABC) = (P - A) · n / |n|。</p></blockquote><!-- Points on a line --><h3 id="点在直线上"><a class="markdownIt-Anchor" href="#点在直线上"></a> 点在直线上</h3><!-- A point is on a line if the distance from the point to the line is 0. --><blockquote><p>点在直线上当且仅当点到直线的距离为0。</p></blockquote><!-- Points on the same side of line --><h3 id="在直线同一侧的点"><a class="markdownIt-Anchor" href="#在直线同一侧的点"></a> 在直线同一侧的点</h3><!-- This notion only makes sense for two dimensions. To check if points C and D are on the same side of line AB, calculate the z component of (B - A) x (C - A) and (B - A) x (D - A). If the z components have the same sign (i.e., their product is positive), then C and D are on the same side of the line AB. --><p>这个概念只对二维平面有意义。要检查C点和D点是否在直线AB的同一侧，计算(B - A) x (C - A)和(B - A) x (D - A)的z分量。如果z分量具有相同的符号（即它们的乘积是正的），则C和D位于直线AB的同一侧。</p><!-- Point on line segment --><h3 id="点在线段上"><a class="markdownIt-Anchor" href="#点在线段上"></a> 点在线段上</h3><!-- To calculate if a point C is on the line segment AB, check if C is on the line AB. If it is, then check if the length of AB is equal to the sum of the lengths of AC and CB. --><blockquote><p>为了计算点C是否在线段AB上，检查C是否在直线AB上。如果是，则检查AB的长度是否等于AC和CB的长度之和。</p></blockquote><!-- Point in triangle --><h3 id="点在三角形中"><a class="markdownIt-Anchor" href="#点在三角形中"></a> 点在三角形中</h3><!-- To check if a point A is in a triangle, find another point B which is within the triangle (the average of the three vertices works well). Then, check if the point A is on the same side of the three lines defined by the edges of the triangle as B. --><blockquote><p>为了检查点A是否在三角形中，找到三角形内的另一个点B（三个顶点的平均值就可以）。然后，检查点A是否和点B在由三角形的边定义的三条直线的同一侧。</p></blockquote><p><img src="geom3.gif" alt></p><!-- Point in convex polygon --><h3 id="点在凸多边形中"><a class="markdownIt-Anchor" href="#点在凸多边形中"></a> 点在凸多边形中</h3><!-- The same trick works for a convex polygon:  --><blockquote><p>同样的技巧适用于凸多边形：</p></blockquote><p><img src="geom4.gif" alt></p><!-- Four (or more) points are coplanar --><h3 id="四或更多点共面"><a class="markdownIt-Anchor" href="#四或更多点共面"></a> 四（或更多）点共面</h3><!-- To determine if a collection of points is coplanar, select three points, A, B, and C. Now, if, for any other point D, (B - A) x (C - A)) · (D - A) = ~0, then the collection of points resides in some plane. --><blockquote><p>为了确定点集是否是共面的，选择三个点，A、B和C。如果对于任何其他点D，((B - A) x (C - A)) · (D - A) ≈ 0，则该点集共面。</p></blockquote><p>先算出三个点对应的平面的法向量……</p><!-- Two lines intersect --><h3 id="两条直线相交"><a class="markdownIt-Anchor" href="#两条直线相交"></a> 两条直线相交</h3><!-- Two lines intersect if and only if they are not parallel in two dimensions. --><blockquote><p>在二维平面中，两条线相交当且仅当它们不平行。</p></blockquote><!-- In three dimensions, two lines AB and CD intersect if they are not parallel and A, B, C, and D are coplanar. --><blockquote><p>在三维中，当直线AB和CD不平行且A、B、C、D共面时，AB和CD相交。</p></blockquote><!-- Two line segments intersect --><h3 id="两条线段相交"><a class="markdownIt-Anchor" href="#两条线段相交"></a> 两条线段相交</h3><!-- In two dimensions, two line segments AB and CD intersect if and only if A and B are on opposite sides of the line CD and C and D are on opposite sides of line AB. --><blockquote><p>在二维平面中，线段AB和CD相交，当且仅当A和B位于直线CD的不同侧且C和D位于直线AB的不同侧时。</p></blockquote><p><img src="geom5.gif" alt></p><!-- Note that both of the checks are necessary, as for the last case one of the checks returns true, while the other testifies to the fact that AB and CD do not intersect. In three dimensions, solve following system of equations, where i and j are the unknowns: --><p>请注意，两个检查都是必要的，因为在上图中最后一种情况中，一个检查返回true，而另一个检查才能证明AB和CD不相交。在三维情况中，求解下面的方程组，其中i和j是未知数：</p><!-- Ax + (Bx - Ax) i = Cx + (Dx - Cx) j Ay + (By - Ay) i = Cy + (Dy - Cy) j Az + (Bz - Az) i = Cz + (Dz - Cz) j  --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax) i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay) i = Cy + (Dy - Cy) j</span><br><span class="line">Az + (Bz - Az) i = Cz + (Dz - Cz) j</span><br></pre></td></tr></table></figure><!-- If this system has a solution (i, j), where 0 <= i <= 1 and 0 <= j <= 1, then the line segments intersect at: (Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i . --><blockquote><p>如果该方程组具有解(i，j)，其中0 &lt;= i &lt;= 1且0 &lt;= j &lt;= 1，则线段相交于点(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i。</p></blockquote><!-- Point of Intersection of Two Lines --><h3 id="两条直线的交点"><a class="markdownIt-Anchor" href="#两条直线的交点"></a> 两条直线的交点</h3><!-- For the lines AB and CD in two dimensions, the most straight-forward way to calculate the intersection of them is to solve the system of two equations and two unknowns: --><blockquote><p>对于二维平面中的直线AB和CD，计算它们交点的最直接方法是求解以下两方程两未知数的方程组：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax)i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay)i = Cy + (Dy - Cy) j</span><br></pre></td></tr></table></figure><!-- The point of intersection is: --><blockquote><p>交点坐标为：<br>(Ax + (Bx - Ax) i, Ay + (By - Ay) i)</p></blockquote><!-- In three dimensions, solve the same system of equations as was used to check line intersection, and the point of intersection is: --><blockquote><p>在三维情况下，求解与检查线段交叉时相同的方程组，则交点坐标为：<br>(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az)i)</p></blockquote><!-- Checking convexity of 2-dimensional polygon --><h3 id="检查二维多边形的凸性"><a class="markdownIt-Anchor" href="#检查二维多边形的凸性"></a> 检查二维多边形的凸性</h3><!-- To check the convexity of a 2-dimensional polygon, walk the polygon in clock-wise order. For each triplet of consecutive points (A, B, C), calculate the cross product (B - A) x (C - A). If the z component of each of these vectors is positive, the polygon is convex. --><blockquote><p>为了检查二维多边形的凸性，按顺时针顺序遍历多边形的顶点。对于所有的连续三个顶点(A，B，C)，计算叉积(B - A) x (C - A)。如果 得到的所有向量的z分量都是正的，则多边形是凸的。</p></blockquote><!-- Point in non-convex polygon --><h3 id="点在非凸多边形中"><a class="markdownIt-Anchor" href="#点在非凸多边形中"></a> 点在非凸多边形中</h3><!-- To calculate if a point is within a nonconvex polygon, make a ray from that point in a random direction and count the number of times it intersects the polygon. If the ray intersects the polygon at a vertex or along an edge, pick a new direction. Otherwise, the point is within the polygon if and only if the ray intersects the polygon an odd number of times. --><blockquote><p>为了计算某点是否在非凸多边形内，从该点沿随机方向发出一条射线，并计算它与多边形相交的次数。如果射线在顶点或沿边缘与多边形相交，则选择一个新方向。否则，当且仅当射线与多边形相交奇数次时，该点才在多边形内。</p></blockquote><p><img src="geom8.gif" alt></p><!-- This method also extends to three dimensions (and higher), but the restriction on intersection is that it only intersects at faces and not at either a vertex or an edge. --><blockquote><p>此方法也适用于三维（和更高维度），但对相交的限制是只在面上相交，而不是在顶点或边上。</p></blockquote><!-- Geometry Methodologies --><h2 id="计算几何方法"><a class="markdownIt-Anchor" href="#计算几何方法"></a> 计算几何方法</h2><!-- Geometric problems introduce several different tricks that can be used to either reduce the run-time or approximate the solution. --><blockquote><p>计算几何题引入了几种不同的技巧，可用于减少运行时间或估计解。</p></blockquote><!-- Monte Carlo --><h3 id="蒙特卡洛方法"><a class="markdownIt-Anchor" href="#蒙特卡洛方法"></a> 蒙特卡洛方法</h3><!-- The first geometric trick is based on randomness. Instead of calculating the probability that something occurs, simulate a random event and calculate the fraction of times it occurs. If enough events are simulated, the difference between these two values becomes very small. --><blockquote><p>第一种计算几何技巧基于随机性。我们不是计算某事发生的概率，而是模拟随机事件并计算它发生的次数。如果模拟了足够多的事件，则这两个值之间的差异将变得非常小。</p></blockquote><!-- This can be helpful to determine something like the area of a figure. Instead of calculating the area directly, determine a bounding box, and throw ``darts'' at the box, and estimate what the probability of hitting the figure is. If this is calculated accurately enough, this can give a good estimate of the actual area. --><blockquote><p>这有助于确定图形面积大小之类内容。我们不是直接计算区域，而是确定一个边界框，然后向框中抛出“飞镖”，并估计击中图形的概率是多少。如果计算得足够准确，这可以很好地估计实际面积。</p></blockquote><!-- The problem with this method is to get a good relative error (error divided by the actual value) requires a large number of successful events. If the probability of the event occurring is very small, the method does not yield good results. --><blockquote><p>这种方法的问题是，获得良好的相对误差（误差除以实际值）需要大量成功的事件。如果事件发生的概率非常小，则该方法不会产生很好的结果。</p></blockquote><!-- Partitioning --><h3 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h3><!-- Partitioning is a method to improve the speed of a geometric algorithm. This entails dividing the plane up into sections (usually by a grid but sometimes into radial sections or some other method), and bucketing the objects into appropriate section(s). When looking for objects within some figure, only those sections which have a non-zero intersection with that figure need to be examined, thereby greatly reducing the cost of the algorithm. This is helpful to determine the set of objects within some distance of a given point (the figure is a circle) or to check for intersections (the figure is a line). --><blockquote><p>分区是一种提高计算几何算法速度的方法。这需要将平面分成多个部分（通常通过网格，但有时也会按辐射切开或其他方法），并将对象分到对应的区域中。当在某个图形中查找对象时，只需要检查与该图图形具有非零交点的那些部分，从而大大降低了算法的成本。这有助于确定到给定点的距离在某个范围内的对象集和（图形是圆）或检查交叉点（图形是一条直线）。</p></blockquote><p><img src="geom9.gif" alt></p><!-- Graph Problems --><h3 id="图论问题"><a class="markdownIt-Anchor" href="#图论问题"></a> 图论问题</h3><!-- Sometimes what may look like a geometric problem is really a graph problem. Just because the input is points in the plane does not mean it's a geometric algorithm. --><blockquote><p>有时看起来像计算几何问题的问题实际上是图论问题。仅仅因为输入是平面中的点并不意味着需要计算几何算法。</p></blockquote><!-- Example Problems --><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><!-- Point Moving --><h3 id="移动点"><a class="markdownIt-Anchor" href="#移动点"></a> 移动点</h3><!-- Given a set of line segments in the plane, and two points A and B, is it possible to move from A to B without crossing any of the segments? --><blockquote><p>给定平面中的一组线段，以及两个点A和B，能否在不跨越任何线段的情况下从A移动到B？</p></blockquote><!-- The line segments partition the plane into regions. Determine these regions, and see if A and B reside in the same region. --><blockquote><p>分析：线段将平面划分为区域。确定这些区域，并检查A和B是否位于同一区域。</p></blockquote><p>问题是怎么确定这些区域，感觉有些麻烦……</p><!-- Bicycle Routing --><h3 id="自行车路线"><a class="markdownIt-Anchor" href="#自行车路线"></a> 自行车路线</h3><!-- Given a collection of non-intersecting buildings along with start and end locations, find the shortest path from A to B that doesn't go through any buildings. --><blockquote><p>给定一系列互不交叉建筑的以及它们的起点和终点位置，找到从A到B的不经过任何建筑物的最短路径。</p></blockquote><!-- Analysis: This is really a graph problem. The nodes are the start and end locations, along with the vertices of the buildings. There are edges between any two nodes such that the line segment between them does not intersect any buildings, with weight equal to the length of the length of the line segments. Once that graph has been calculated, the problem is shortest path. --><blockquote><p>分析：这实际上是一个图论问题。结点是起始位置和结束位置，以及建筑物的顶点。如果两个结点之间的线段不与任何建筑物相交，则它们之间有边，其权重等于线段的长度。构造完该图后，问题就变成了最短路。</p></blockquote><!-- Maximizing Line Intersections --><h3 id="最大化交叉点数量"><a class="markdownIt-Anchor" href="#最大化交叉点数量"></a> 最大化交叉点数量</h3><!-- Given a collection of segments in the plane, find the greatest number of segments which can by intersected by drawing a single line. --><blockquote><p>给定平面中的一组线段，找到可以与一条直线相交的线段的最大数量。</p></blockquote><!-- Analysis: With a little bit of thought, it is clear that the line segment must pass through two of the vertices of the collection of line segments. Thus, try all pairs of vertices, and calculate the crossing for each. Combining this with partitioning gives an algorithm that runs fairly quickly. --><blockquote><p>分析：经过一些思考，很显然直线必须通过线段集合中的两个顶点。因此，尝试所有顶点对，并计算每条直线的交叉点数量。将其与分区相结合，可以提供一种运行速度相当快的算法。</p></blockquote><p>或者说，一种最优解可以通过旋转变换成另一个一定至少通过两个顶点的最优解……</p><!-- Polygon Classification --><h3 id="多边形分类"><a class="markdownIt-Anchor" href="#多边形分类"></a> 多边形分类</h3><!-- Given a collection of segments defining a polygon, determine if it is simple (no two non-consecutive line segments intersect) and convex. --><blockquote><p>给定定义多边形的一组线段，确定它是否是简单多边形（没有两个非连续线段相交）和凸多边形。</p></blockquote><p>Q：凸多边形一定是简单的吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。&lt;/p&gt;
&lt;!-- Prerequisites --&gt;
&lt;h2 id=&quot;先决条件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先决条件&quot;&gt;&lt;/a&gt; 先决条件&lt;/h2&gt;
&lt;!-- Gra
      
    
    </summary>
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/categories/USACO/"/>
    
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/tags/USACO/"/>
    
      <category term="translation" scheme="https://zhanghuimeng.github.io/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 989. Add to Array-Form of Integer</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-989-add-to-array-form-of-integer/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-989-add-to-array-form-of-integer/</id>
    <published>2019-02-10T20:49:07.000Z</published>
    <updated>2019-02-10T20:49:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/add-to-array-form-of-integer/description/" target="_blank" rel="noopener">https://leetcode.com/problems/add-to-array-form-of-integer/description/</a></p><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：144ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一个自然数的各个数位从左到右的数组表示和另一个自然数，求这两个数的和的数组表示。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>很简单的加法题的一个小变形。题解的做法跟我差不多：开一个新的数组（因为原来的表示方法不符合一般从右往左表示的规律），从最后一位开始加，最后再把数组倒过来。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; addToArrayForm(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        a.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            a.back() += A[i];</span><br><span class="line">            a.back() += K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a.back() / <span class="number">10</span>;</span><br><span class="line">            a.back() %= <span class="number">10</span>;</span><br><span class="line">            a.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a.back() += K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a.back() / <span class="number">10</span>;</span><br><span class="line">            a.back() %= <span class="number">10</span>;</span><br><span class="line">            a.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a.size() &gt; <span class="number">1</span> &amp;&amp; a.back() == <span class="number">0</span>) a.pop_back();</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/add-to-array-form-of-integer/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.co
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Array" scheme="https://zhanghuimeng.github.io/tags/alg-Array/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>翻译：欧拉路（USACO）</title>
    <link href="https://zhanghuimeng.github.io/post/eulerian-tour-usaco-translation/"/>
    <id>https://zhanghuimeng.github.io/post/eulerian-tour-usaco-translation/</id>
    <published>2019-02-09T20:54:04.000Z</published>
    <updated>2019-02-09T20:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。</p><!-- Sample Problem: Riding The Fences --><h2 id="例题穿越栅栏"><a class="markdownIt-Anchor" href="#例题穿越栅栏"></a> 例题：穿越栅栏</h2><!-- Farmer John owns a large number of fences, which he must periodically check for integrity. Farmer John keeps track of his fences by maintaining a list of their intersection points, along with the fences which end at each point. Each fence has two end points, each at an intersection point, although the intersection point may be the end point of only a single fence. Of course, more than two fences might share an endpoint. --><blockquote><p>农夫约翰拥有大量围栏，他必须定期检查它们的完整性。农民约翰通过维护围栏的交叉点列表，以及在每个交叉点点结束的围栏来跟踪它们。每个围栏有两个端点，每个端点位于一个交叉点，交叉点可能只是单个围栏的终点。当然，两个以上的围栏也可能共享一个端点。</p></blockquote><!-- Given the fence layout, calculate if there is a way for Farmer John to ride his horse to all of his fences without riding along a fence more than once. Farmer John can start and end anywhere, but cannot cut across his fields (the only way he can travel between intersection points is along a fence). If there is a way, find one way. --><blockquote><p>给定围栏的布局，计算农夫约翰是否有办法骑马去他所有的围栏，且不需要不止一次地穿越围栏。约翰可以在任何地方开始和结束，但不能穿过他的田地（在交叉点之间穿行的唯一方法是沿着围栏）。如果有方法，找出一种方法。</p></blockquote><!-- The Abstraction --><h2 id="问题的抽象"><a class="markdownIt-Anchor" href="#问题的抽象"></a> 问题的抽象</h2><!-- Given: An undirected graph --><blockquote><p>给定：无向图</p></blockquote><!-- Find a path which uses every edge exactly once. This is called an Eulerian tour. If the path begins and ends at the same vertex, it is called a Eulerian circuit. --><blockquote><p>找到一条只使用每条边一次的路径。这样的路径称为欧拉路径。如果路径在同一顶点开始和结束，则称为欧拉回路。</p></blockquote><!-- The Algorithm --><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><!-- Detecting whether a graph has an Eulerian tour or circuit is actually easy; two different rules apply. --><blockquote><p>检查图中是否有欧拉路径或回路实际上很容易; 使用下列两条规则。</p></blockquote><!-- A graph has an Eulerian circuit if and only if it is connected (once you throw out all nodes of degree 0) and every node has `even degree'. --><!-- A graph has an Eulerian path if and only if it is connected and every node except two has even degree. --><!-- In the second case, one of the two nodes which has odd degree must be the start node, while the other is the end node. --><blockquote><ul><li>图中有欧拉回路，当且仅当它是连通图（在去掉度数为0的所有结点之后），且每个结点具有“偶数度”。</li><li>图中有欧拉路径，当且仅当它是连通图，且除了两个结点之外的每个结点的度数均为偶数。</li><li>在第二种情况下，具有奇数度的两个结点中的一个必须是起始结点，而另一个是结束结点。</li></ul></blockquote><!-- The basic idea of the algorithm is to start at some node the graph and determine a circuit back to that same node. Now, as the circuit is added (in reverse order, as it turns out), the algorithm ensures that all the edges of all the nodes along that path have been used. If there is some node along that path which has an edge that has not been used, then the algorithm finds a circuit starting at that node which uses that edge and splices this new circuit into the current one. This continues until all the edges of every node in the original circuit have been used, which, since the graph is connected, implies that all the edges have been used, so the resulting circuit is Eulerian. --><blockquote><p>算法的基本思想是从图的某个结点开始，并确定回到同一结点的回路。现在，随着回路的添加（事实上是以逆序），算法确保从该路径上所有结点出发的所有边都已被使用。如果该路径上还存在一些具有未使用的边的结点，则算法找到从该结点开始的使用这条边的回路，并将该新回路拼接到当前回路中。这一直持续到原始回路中每个结点的所有边都被使用为止，由于图是连通的，这意味着已经使用了所有边，因此得到的回路是欧拉回路。</p></blockquote><!-- More formally, to determine a Eulerian circuit of a graph which has one, pick a starting node and recurse on it. At each recursive step: --><blockquote><p>更正式地说，要确定一个含有欧拉回路的图中的欧拉回路，选择一个起始结点并对其进行递归。在每个递归步骤中：</p></blockquote><!-- Pick a starting node and recurse on that node. At each step: --><!-- If the node has no neighbors, then append the node to the circuit and return --><!-- If the node has a neighbor, then make a list of the neighbors and process them (which includes deleting them from the list of nodes on which to work) until the node has no more neighbors --><!-- To process a node, delete the edge between the current node and its neighbor, recurse on the neighbor, and postpend the current node to the circuit. --><blockquote><ul><li>选择一个起始结点并对该结点进行递归。在每一步中：</li><li>如果结点没有邻居，则将结点加入到回路中并返回</li><li>如果结点具有邻居，则创建邻居列表并对其进行处理（包括从需要处理的结点列表中删除它们），直到该节点不再有邻居为止</li><li>为了处理结点，删除当前结点与其邻居之间的边，递归邻居，然后将当前结点加入到电路中。</li></ul></blockquote><!-- And here's the pseudocode: --><blockquote><p>这是伪代码：</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># circuit是一个全局数组</span></span><br><span class="line">find_euler_circuit</span><br><span class="line">    circuitpos = <span class="number">0</span></span><br><span class="line">    find_circuit(node <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># nextnode和visited是局部数组</span></span><br><span class="line"><span class="comment"># 将以逆序找到路径</span></span><br><span class="line">find_circuit(node i)</span><br><span class="line">    <span class="keyword">if</span> 结点i没有邻居 then</span><br><span class="line">      circuit(circuitpos) = 结点i</span><br><span class="line">      circuitpos = circuitpos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">while</span> (结点i有邻居)</span><br><span class="line">          随机选择结点i的邻居结点j</span><br><span class="line">          delete_edges (结点j, 结点i)</span><br><span class="line">          find_circuit (结点j)</span><br><span class="line">      circuit(circuitpos) = 结点i</span><br><span class="line">      circuitpos = circuitpos + <span class="number">1</span></span><br></pre></td></tr></table></figure><!-- To find an Eulerian tour, simply find one of the nodes which has odd degree and call find_circuit with it. --><blockquote><p>为了找到欧拉路径，只需找到其中一个具有奇数度的结点，并对它调用<code>find_circuit</code>。</p></blockquote><!-- Both of these algorithms run in O(m + n) time, where m is the number of edges and n is the number of nodes, if you store the graph in adjacency list form. With larger graphs, there's a danger of overflowing the run-time stack, so you might have to use your own stack. --><blockquote><p>这两种算法的时间复杂度都是O(m + n)，其中m是边数，n是结点数，如果图是以邻接表形式存储的话。对于较大的图，存在运行时栈溢出的风险，因此你可能需要使用自己的栈。</p></blockquote><!-- Execution Example --><h2 id="执行示例"><a class="markdownIt-Anchor" href="#执行示例"></a> 执行示例</h2><!-- Consider the following graph:  --><blockquote><p>考虑下图：</p></blockquote><p><img src="euler1.gif" alt></p><!-- Assume that selecting a random neighbor yields the lowest numbered neighbor, the execution goes as follows: --><blockquote><p>假设选择随机邻居时选择的是编号最小的邻居，算法执行过程如下：</p></blockquote><p><img src="euler2a.gif" alt></p><!-- Stack: Location: 1 Circuit: --><blockquote><p>栈：<br>当前位置：1<br>回路：</p></blockquote><p><img src="euler2b.gif" alt></p><!-- Stack: 1 Location: 4 Circuit: --><blockquote><p>栈：1<br>当前位置：4<br>回路：</p></blockquote><p><img src="euler2c.gif" alt></p><!-- Stack: 1 4 Location: 2 Circuit: --><blockquote><p>栈：1 4<br>当前位置：2<br>回路：</p></blockquote><p><img src="euler2d.gif" alt></p><!-- Stack: 1 4 2 Location: 5 Circuit: --><blockquote><p>栈：1 4 2<br>当前位置：5<br>回路：</p></blockquote><p><img src="euler2e.gif" alt></p><!-- Stack: 1 4 2 5 Location: 1 Circuit: --><blockquote><p>栈：1 4 2 5<br>当前位置：1<br>回路：</p></blockquote><p><img src="euler2e.gif" alt></p><!-- Stack: 1 4 2 Location: 5 Circuit: 1 --><blockquote><p>栈：1 4 2<br>当前位置：5<br>回路：1</p></blockquote><p><img src="euler2f.gif" alt></p><!-- Stack: 1 4 2 5 Location: 6 Circuit: 1 --><blockquote><p>栈：1 4 2 5<br>当前位置：6<br>回路：1</p></blockquote><p><img src="euler2g.gif" alt></p><!-- Stack: 1 4 2 5 6 Location: 2 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6<br>当前位置：2<br>回路：1</p></blockquote><p><img src="euler2h.gif" alt></p><!-- Stack: 1 4 2 5 6 2 Location: 7 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2<br>当前位置：7<br>回路：1</p></blockquote><p><img src="euler2i.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 Location: 3 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2 7<br>当前位置：3<br>回路：1</p></blockquote><p><img src="euler2j.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 Location: 4 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2 7 3<br>当前位置：4<br>回路：1</p></blockquote><p><img src="euler2k.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 4 Location: 6 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2 7 3 4<br>当前位置：6<br>回路：1</p></blockquote><p><img src="euler2l.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 4 6 Location: 7 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2 7 3 4 6<br>当前位置：7<br>回路：1</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 4 6 7 Location: 5 Circuit: 1 --><blockquote><p>栈：1 4 2 5 6 2 7 3 4 6 7<br>当前位置：5<br>回路：1</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 4 6 Location: 7 Circuit: 1 5 --><blockquote><p>栈：1 4 2 5 6 2 7 3 4 6<br>当前位置：7<br>回路：1 5</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 4 Location: 6 Circuit: 1 5 7 --><blockquote><p>栈：1 4 2 5 6 2 7 3 4<br>当前位置：6<br>回路：1 5 7</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 3 Location: 4 Circuit: 1 5 7 6 --><blockquote><p>栈：1 4 2 5 6 2 7 3<br>当前位置：4<br>回路：1 5 7 6</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 7 Location: 3 Circuit: 1 5 7 6 4 --><blockquote><p>栈：1 4 2 5 6 2 7<br>当前位置：3<br>回路：1 5 7 6 4</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 2 Location: 7 Circuit: 1 5 7 6 4 3 --><blockquote><p>栈：1 4 2 5 6 2<br>当前位置：7<br>回路：1 5 7 6 4 3</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 6 Location: 2 Circuit: 1 5 7 6 4 3 7 --><blockquote><p>栈：1 4 2 5 6<br>当前位置：2<br>回路：1 5 7 6 4 3 7</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 5 Location: 6 Circuit: 1 5 7 6 4 3 7 2 --><blockquote><p>栈：1 4 2 5<br>当前位置：6<br>回路：1 5 7 6 4 3 7 2</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 2 Location: 5 Circuit: 1 5 7 6 4 3 7 2 6 --><blockquote><p>栈：1 4 2<br>当前位置：5<br>回路：1 5 7 6 4 3 7 2 6</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 4 Location: 2 Circuit: 1 5 7 6 4 3 7 2 6 5 --><blockquote><p>栈：1 4<br>当前位置：2<br>回路：1 5 7 6 4 3 7 2 6 5</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: 1 Location: 4 Circuit: 1 5 7 6 4 3 7 2 6 5 2 --><blockquote><p>栈：1<br>当前位置：4<br>回路：1 5 7 6 4 3 7 2 6 5 2</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: Location: 1 Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 --><blockquote><p>栈：<br>当前位置：1<br>回路：1 5 7 6 4 3 7 2 6 5 2 4</p></blockquote><p><img src="euler2m.gif" alt></p><!-- Stack: Location: Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 1 --><blockquote><p>栈：<br>当前位置：<br>回路：1 5 7 6 4 3 7 2 6 5 2 4 1</p></blockquote><!-- Extensions --><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2><!-- Multiple edges between nodes can be handled by the exact same algorithm. --><blockquote><p>重边可以通过完全相同的算法来处理。</p></blockquote><!-- Self-loops can be handled by the exact same algorithm as well, if self-loops are considered to add 2 (one in and one out) to the degree of a node. --><blockquote><p>如果认为自环会为结点度数增加2（一进一出），则自环也可以通过完全相同的算法来处理。</p></blockquote><!-- A directed graph has a Eulerian circuit if it is strongly connected (except for nodes with both in-degree and out-degree of 0) and the indegree of each node equals its outdegree. The algorithm is exactly the same, except that because of the way this code finds the cycle, you must traverse arcs in reverse order. --><blockquote><p>有向图仅当强连通且每个结点的入度等于出度时才有欧拉回路（除了入度和出度均为0的节点）。算法完全相同，只是由于此代码找到环路的方式，您必须以相反的顺序遍历边。</p></blockquote><!-- Finding a Eulerian path in a directed graph is harder. Consult Sedgewick if you are interested. --><blockquote><p>在有向图中找到欧拉路径更难。如果您有兴趣，请阅读Sedgewick的书。</p></blockquote><!-- Example problems --><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><!-- Airplane Hopping --><h3 id="飞机跳跃"><a class="markdownIt-Anchor" href="#飞机跳跃"></a> 飞机跳跃</h3><!-- Given a collection of cities, along with the flights between those cities, determine if there is a sequence of flights such that you take every flight exactly once, and end up at the place you started. --><blockquote><p>给定一系列城市，以及这些城市之间的航班，确定是否存在一个航班序列，使得你顺序搭乘每个航班一次，最后回到开始的地方。</p></blockquote><!-- Analysis: This is equivalent to finding a Eulerian circuit in a directed graph. --><blockquote><p>分析：这相当于在有向图中找到欧拉回路。</p></blockquote><!-- Cows on Parade --><h3 id="行进中的奶牛"><a class="markdownIt-Anchor" href="#行进中的奶牛"></a> 行进中的奶牛</h3><!-- Farmer John has two types of cows: black Angus and white Jerseys. While marching 19 of their cows to market the other day, John's wife Farmeress Joanne, noticed that all 16 possibilities of four successive black and white cows (e.g., bbbb, bbbw, bbwb, bbww, ..., wwww) were present. Of course, some of the combinations overlapped others. --><p>农夫约翰有两种类型的奶牛：黑色安格斯奶牛和白色泽西奶牛。前几天约翰的妻子琼安将19头奶牛赶到市场上时，注意到四只连续黑白奶牛的所有16种可能性（例如，bbbb，bbbw，bbwb，bbww，…，wwww）都存在。当然，有些组合与其他组合重叠。</p><!-- Given N (2 <= N <= 15), find the minimum length sequence of cows such that every combination of N successive black and white cows occurs in that sequence. --><blockquote><p>给定N（2 &lt;= N &lt;= 15），找到最小的奶牛长度序列，使得N个连续的黑色和白色奶牛的每个组合都出现在该序列中。</p></blockquote><!-- Analysis: The vertices of the graph are the possibilities of N-1 cows. Being at a node corresponds to the last N-1 cows matching the node in color. That is, for N = 4, if the last 3 cows were wbw, then you are at the wbw node. Each node has out-degree of 2, corresponding to adding a black or white cow to the end of the sequence. In addition, each node has in-degree of 2, corresponding to whether the cow just before the last N-1 cows is black or white. --><blockquote><p>分析：图的顶点是N-1头奶牛的可能颜色。位于一个结点处表示最后N-1头奶牛与该结点的颜色匹配。也就是说，对于N = 4，如果最后3头奶牛颜色是wbw，那么你就在wbw节点。每个节点的出度为2，对应于在序列末尾添加黑色或白色奶牛。另外，每个节点的入度为2，对应于最后N-1头奶牛之前的奶牛是黑色还是白色。</p></blockquote><p>嗯……为啥图的顶点是N-1头奶牛的可能颜色，而不是N头呢？</p><!-- The graph is strongly connected, and the in-degree of each node equals its out-degree, so the graph has a Eulerian circuit. --><blockquote><p>图是强连通的，并且每个结点的入度等于出度，因此图中有欧拉回路。</p></blockquote><!-- The sequence corresponding to the Eulerian circuit is the sequence of N-1 cows of the first node in the circuit, followed by cows corresponding to the color of the edge. --><blockquote><p>和欧拉回路相对应的序列是回路中第一个结点对应的N-1头母牛的序列，之后再加上每条边对应的颜色。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。&lt;/p&gt;
&lt;!-- Sample Problem: Riding The Fences --&gt;
&lt;h2 id=&quot;例题穿越栅栏&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#例题穿越栅栏&quot;
      
    
    </summary>
    
    
      <category term="Translation" scheme="https://zhanghuimeng.github.io/tags/Translation/"/>
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/tags/USACO/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 988. Smallest String Starting From Leaf（树）</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-988-smallest%20String%20Starting%20From%20Leaf%EF%BC%88%E6%A0%91%EF%BC%89/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-988-smallest String Starting From Leaf（树）/</id>
    <published>2019-02-05T16:25:48.000Z</published>
    <updated>2019-02-05T16:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/description/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-string-starting-from-leaf/description/</a></p><p>标记难度：Medium</p><p>提交次数：2/4</p><p>代码效率：</p><ul><li>BFS：4ms</li><li>暴力：0ms</li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一棵二叉树，令它的每个结点表示一个字符，问从每个叶结点开始，到树根结束的所有字符串中最小的字符串。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>考虑到这道题的数据范围（二叉树的最高层的叶结点数量大约最多是总结点数量的一半），完全可以把所有可能的字符串都生成出来，然后从里面找最小的……</p><p>另一种稍微不那么暴力的方法是做BFS，找到出现叶结点的第一层，然后再回溯（或者直接暴力……）。</p><hr><p>这道题实现过程中还有另一个问题：如何把单个char赋值给一个string？事实上，直接赋值和cast是不行的；如果想要采用<code>&quot;&quot; + 'a'</code>这种写法，就更是大错特错了，这相当于将指向字符串<code>&quot;&quot;</code>首位的指针加上<code>(int) 'a'</code>……</p><p>所以比较正确的方法是<code>string(1, 'a')</code>。不要把常量字符串加上char……<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h3><p>这份代码比较愚蠢的一点在于，它居然没有存每个结点对应的字符串，而是只存了每个结点的父节点的位置，这么写大概就是故意增加复杂度了……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;  <span class="comment">// node, father, depth</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end;</span><br><span class="line">        q.emplace_back(root, make_pair(<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (start &lt; q.size()) &#123;</span><br><span class="line">            end = q.size();</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                TreeNode* p = q[start].first;</span><br><span class="line">                <span class="keyword">int</span> depth = q[start].second.second;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) q.emplace_back(p-&gt;left, make_pair(start, depth + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) q.emplace_back(p-&gt;right, make_pair(start, depth + <span class="number">1</span>));</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; ans;  <span class="comment">// index, string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            TreeNode* p = q[i].first;</span><br><span class="line">            <span class="keyword">int</span> depth = q[i].second.second;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span> &amp;&amp; p-&gt;right == <span class="literal">NULL</span>) ans.emplace_back(i, <span class="built_in">string</span>(<span class="number">1</span>, p-&gt;val + <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> minimal;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; a;</span><br><span class="line">            minimal = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                minimal = minimal == <span class="string">""</span> || minimal &gt; ans[i].second ? ans[i].second : minimal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[i].second == minimal) &#123;</span><br><span class="line">                    <span class="keyword">int</span> last = q[ans[i].first].second.first;</span><br><span class="line">                    <span class="keyword">if</span> (last == <span class="number">-1</span>) <span class="keyword">return</span> minimal;</span><br><span class="line">                    a.emplace_back(last, minimal + (<span class="keyword">char</span>) (q[last].first-&gt;val + <span class="string">'a'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minimal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        s += (<span class="keyword">char</span>) (root-&gt;val + <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            reverse(s.begin(), s.end());</span><br><span class="line">            ans = ans == <span class="string">""</span> || s &lt; ans ? s : ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, s);</span><br><span class="line">        dfs(root-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://stackoverflow.com/questions/17201590/c-convert-from-1-char-to-string" target="_blank" rel="noopener">stackoverflow - C++ convert from 1 char to string? [closed]</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/smallest-string-starting-from-leaf/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetc
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 987. Vertical Order Traversal of a Binary Tree（树）</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-987-vertical-order-traversal-of-a-binary-tree/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-987-vertical-order-traversal-of-a-binary-tree/</id>
    <published>2019-02-04T21:59:35.000Z</published>
    <updated>2019-02-05T16:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/</a></p><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：0ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一棵二叉树，定义每个结点的坐标如下：如果父结点的坐标是<code>(X, Y)</code>，则左子结点的坐标是<code>(X - 1, Y - 1)</code>，右子结点的坐标是<code>(X - 1, Y + 1)</code>。将横坐标相同的结点的值放在一个列表中，按值排序，并将这些列表按横坐标排序。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>总的来说是道简单的题，用一个map存放横坐标相同的结点的值，然后再排序即可。不过我倒是复习了一下怎么遍历C++ map……（如果不用语法糖的话）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义迭代器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;::iterator it;</span><br><span class="line"><span class="comment">// 用迭代器进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (it = nodeMap.begin(); it != nodeMap.end(); it++) &#123;</span><br><span class="line">    <span class="comment">// 用指针进行访问</span></span><br><span class="line">    sort(it-&gt;second.begin(),it-&gt;second.end());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; nodeMap; <span class="comment">// x -&gt; (-y, value)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        nodeMap[x].emplace_back(-y, root-&gt;val);</span><br><span class="line">        dfs(x - <span class="number">1</span>, y - <span class="number">1</span>, root-&gt;left);</span><br><span class="line">        dfs(x + <span class="number">1</span>, y - <span class="number">1</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = nodeMap.begin(); it != nodeMap.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">            sort(it-&gt;second.begin(),it-&gt;second.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; it-&gt;second.size(); i++)</span><br><span class="line">                cols.push_back(it-&gt;second[i].second);</span><br><span class="line">            ans.push_back(cols);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://stackoverflow.com/questions/18424026/sort-vector-in-a-map-c" target="_blank" rel="noopener">stackoverflow - Sort Vector in a Map c++</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 986. Interval List Intersections</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-986-interval-list-intersections/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-986-interval-list-intersections/</id>
    <published>2019-02-04T00:19:53.000Z</published>
    <updated>2019-02-04T21:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/interval-list-intersections/description/" target="_blank" rel="noopener">https://leetcode.com/problems/interval-list-intersections/description/</a></p><p>标记难度：Medium</p><p>提交次数：2/2</p><p>代码效率：</p><ul><li>奇怪的做法：28ms</li><li>正常的合并：24ms</li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>有<code>A</code>和<code>B</code>两个闭区间数组，它们分别都是排过序的，且每个数组里的区间之间互不相交。请求出两个数组中闭区间的交。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>这道题的数据范围并不大（1000），所以我比赛的时候随便乱做了一下，也就过了。</p><p>不过正解是这样的：首先考虑最小的两个闭区间<code>A[0]</code>和<code>B[0]</code>，不失一般性，假设<code>A[0]</code>的右端点小于等于<code>B[0]</code>的右端点。由于<code>B</code>中的区间是互不相交的，因此<code>A[0]</code>只有可能与<code>B[0]</code>相交，不可能与<code>B</code>中其他的端点相交。因此我们可以在判断完后将<code>A[0]</code>丢掉，然后重新考虑新的<code>A</code>和<code>B</code>的相交情况。于是就得到了一个<code>O(N)</code>的算法。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="奇怪的做法"><a class="markdownIt-Anchor" href="#奇怪的做法"></a> 奇怪的做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(Interval x1, Interval x2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x1.end &lt; x2.start || x2.end &lt; x1.start) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; getIntsc(Interval x1, Interval x2) &#123;</span><br><span class="line">        <span class="keyword">return</span> make_pair(max(x1.start, x2.start), min(x1.end, x2.end));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; intervalIntersection(<span class="built_in">vector</span>&lt;Interval&gt;&amp; A, <span class="built_in">vector</span>&lt;Interval&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; m &amp;&amp; B[start].end &lt; A[i].start &amp;&amp; !intersect(A[i], B[start])) start++;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (intersect(A[i], B[j]))</span><br><span class="line">                    a.push_back(getIntsc(A[i], B[j]));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">            ans.emplace_back(a[i].first, a[i].second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="正常的做法"><a class="markdownIt-Anchor" href="#正常的做法"></a> 正常的做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; intervalIntersection(<span class="built_in">vector</span>&lt;Interval&gt;&amp; A, <span class="built_in">vector</span>&lt;Interval&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i].end &lt; B[j].start) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (B[j].end &lt; A[i].start) j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.emplace_back(max(A[i].start, B[j].start), min(A[i].end, B[j].end));</span><br><span class="line">                <span class="keyword">if</span> (A[i].end &lt; B[j].end) i++;</span><br><span class="line">                <span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/interval-list-intersections/solution/" target="_blank" rel="noopener">Leetcode Official Solution for 986</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/interval-list-intersections/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Two Pointers" scheme="https://zhanghuimeng.github.io/tags/alg-Two-Pointers/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 985. Sum of Even Numbers After Queries</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-985-sum-of-even-numbers-after-queries/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-985-sum-of-even-numbers-after-queries/</id>
    <published>2019-02-03T19:02:27.000Z</published>
    <updated>2019-02-03T19:02:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/sum-of-even-numbers-after-queries/description/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-even-numbers-after-queries/description/</a></p><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：96ms</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一个数组<code>A</code>，对其中的数做以下操作：</p><ul><li>更新：<code>A[index] += val</code></li><li>查询：问<code>A</code>中所有偶数的和</li></ul><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>首先预处理出<code>A</code>中所有偶数的和，然后在每次更新的时候，对这个和相应地进行更新。总的来说是道水题……</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumEvenAfterQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum += A[i];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queries[i][<span class="number">0</span>], k = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (A[k] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) sum += x;</span><br><span class="line">                <span class="keyword">else</span> sum -= A[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) sum += A[k] + x;</span><br><span class="line">            &#125;</span><br><span class="line">            A[k] += x;</span><br><span class="line">            ans.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/sum-of-even-numbers-after-queries/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetco
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Array" scheme="https://zhanghuimeng.github.io/tags/alg-Array/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 128. Longest Consecutive Sequence</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-128-longest-consecutive-sequence/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-128-longest-consecutive-sequence/</id>
    <published>2019-02-01T16:04:06.000Z</published>
    <updated>2019-02-01T16:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/description/</a></p><p>标记难度：Hard</p><p>提交次数：2/2</p><p>代码效率：</p><ul><li>排序：100.00%（4ms）</li><li>Hash Set：100.00%（4ms）</li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一个（未排序的）整数数组，找到最长的连续整数序列的长度。要求复杂度是<code>O(n)</code>。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>虽然说要求复杂度是<code>O(n)</code>，但是我想都没想就排了个序……然后直接扫描一遍数组就可以了。</p><p><a href="https://leetcode.com/articles/longest-consecutive-sequence/" target="_blank" rel="noopener">题解</a>里给出了不排序的做法：把每个数都存到一个哈希表里，然后对于每个数，如果它之前没有出现在某个连续序列里（也就是说比它少1的数不存在），则尝试寻找以它为开头的连续整数序列的长度。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// ……</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                ans = max(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            s.insert(num);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(num - <span class="number">1</span>) == s.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s.find(num + l) != s.end())</span><br><span class="line">                    l++;</span><br><span class="line">                maxn = max(maxn, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/longest-consecutive-sequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.co
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1107E. Vasya and Binary String（DP）</title>
    <link href="https://zhanghuimeng.github.io/post/codeforces-1107e-vasya-and-binary-string/"/>
    <id>https://zhanghuimeng.github.io/post/codeforces-1107e-vasya-and-binary-string/</id>
    <published>2019-01-31T17:31:57.000Z</published>
    <updated>2019-01-31T17:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://codeforces.com/contest/1107/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1107/problem/E</a></p><p>提交次数：1/1</p><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一个长度为<code>n</code>的只包含0和1的字符串，将该串中连续<code>i</code>个相同字符消去将得到<code>a[i]</code>的收益，问消去整个字符串能得到的最大收益是多少？</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>在不会做的三道题上鸽了好久，最后还是觉得DP最好写……</p><hr><p>这个题解[soln1]特别简明扼要，大概抓住了问题的本质，不过我可能还没有完全理解它：</p><ul><li>每一个状态都可以用<code>[start, end, prefix]</code>表示，其中<code>start</code>和<code>end</code>是字符串中的起始和结束index（不妨假设两端都是闭区间）（不是也行），<code>prefix</code>是字符串前面附加的和<code>s[start]</code>相等的字符的数量（包括<code>s[start]</code>）（不包括大概也行）</li><li>每一个状态都有两种递推方法：<ul><li>第一种是直接消去字符串前面附加的字符：<code>dp[start, end, prefix] = a[prefix] + dp[start + 1, end, 1]</code></li><li>第二种是在字符串其他位置找到一个和<code>s[start]</code>相同的字符，然后消去中间的字符，获得一个更大的前缀：<code>dp[start, end, prefix] = max(dp[start+1, i-1, 1] + dp[i, end, prefix+1]) (start &lt; i &lt;= end, s[i] == s[start])</code></li></ul></li></ul><p>虽然这个做法看起来很有道理，但其实我会有几个疑问。比如说，一些状态看起来其实是等价的：对于字符串<code>&quot;0001&quot;</code>，<code>dp[0, 3, 1]</code>和<code>dp[2, 3, 3]</code>表示的都是整个字符串。显然我们在递推过程中更容易得到前一种（没有被简化的）状态。那这两种状态有什么关系呢？是否需要手动简化？事实上，并不需要手动简化，<code>dp[0, 3, 1]</code>在递推中会自动得到<code>dp[1, 3, 2]</code>这个状态，并且进一步得到<code>dp[2, 3, 3]</code>。所以，与其说后一种状态是“简化之后的”，不如说是另一种对状态的看法，而且是一种一般化的表示。</p><p>至于递推的顺序，大概是得<code>end - start</code>从小到大，且<code>prefix</code>从小到大。这听起来有点麻烦（而且可能会增加复杂度），不如就写成递归形式算了。</p><p>[soln1]: <a href="https://codeforces.com/blog/entry/64833" target="_blank" rel="noopener">Codeforces Blog - Quick unofficial editorial for Educational Round 59 (Div. 2)</a></p><p>[soln2]: <a href="https://codeforces.com/blog/entry/64847" target="_blank" rel="noopener">Codeforces Blog - Educational Codeforces Round 59 Editorial</a></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> s[<span class="number">105</span>];</span><br><span class="line">LL a[<span class="number">105</span>];</span><br><span class="line">LL f[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[start][end][p] != <span class="number">-1</span>) <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        f[start][end][p] = a[p];</span><br><span class="line">        <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">    &#125;</span><br><span class="line">    f[start][end][p] = a[p] + calc(start + <span class="number">1</span>, end, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[start]) <span class="keyword">continue</span>;</span><br><span class="line">        f[start][end][p] = max(f[start][end][p], calc(start + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">1</span>) + calc(i, end, p + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[start][end][p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">        s[i] = ch - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; calc(<span class="number">0</span>, n<span class="number">-1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://codeforces.com/contest/1107/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1107/problem/E
      
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/tags/Codeforces/"/>
    
      <category term="Codeforces Contest" scheme="https://zhanghuimeng.github.io/tags/Codeforces-Contest/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
  </entry>
  
</feed>
