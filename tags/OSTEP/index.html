<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Tag: OSTEP | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
    <script>
        window.subData= { title:'标签 : OSTEP'}
    </script>




  <section class="post-list">
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-05-homework-coding-process-apis/">
              
                  OSTEP第05章作业：Coding: Process APIs
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-08-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章作业见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf</a>。</p>
<hr>
<p>在本次作业中，你将熟悉刚讲到的进程管理API的用法。这可是很有趣的，代码写得越多越好。所以赶紧去写吧。</p>
<p>（以下代码运行结果来自Ubuntu 16.04）</p>
<h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h2>
<p>写一个程序，调用<code>fork()</code>。在调用<code>fork()</code>之前，让主进程设置一个变量（如<code>x</code>）的值（如100）。子进程中这个变量的值是多少？当子进程和父进程都修改<code>x</code>的值时，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw01.c" target="_blank" rel="noopener">hw01.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw01</span><br><span class="line">x = 100 (pid:2597)</span><br><span class="line">parent: x = 100 (pid:2597)</span><br><span class="line">parent: x = 101 (pid:2597)</span><br><span class="line">child: x = 100 (pid:2598)</span><br><span class="line">child: x = 99 (pid:2598)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，子进程中<code>x</code>的值仍然为100，且父进程和子进程对<code>x</code>的修改是互相独立的。这是因为<code>fork()</code>系统调用把内存空间复制了一份（或者大概用了COW机制，不过这个暂时并不重要）。</p>
<h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h2>
<p>写一个程序，通过<code>open()</code>系统调用打开一个文件，并调用<code>fork()</code>创建一个新的进程。子进程和父进程可以同时访问<code>open()</code>返回的文件描述符吗？如果它们同时写这个文件，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw02.c" target="_blank" rel="noopener">hw02.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw02</span><br><span class="line">prompt&gt; cat hw02.output</span><br><span class="line">I am parent</span><br><span class="line">I am child</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，子进程和父进程可以同时访问这个文件，且输出结果基本是正常的。Linux实际上并不会保证并发的文件操作不出问题。不过，其实Linux的内部实现保证了<code>read()</code>和<code>write()</code>操作是串行执行的。详情可见<a href="https://stackoverflow.com/questions/2751734/how-do-filesystems-handle-concurrent-read-write" target="_blank" rel="noopener">How do filesystems handle concurrent read/write?</a>。</p>
<h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h2>
<p>再写一个调用<code>fork()</code>的程序。令子进程打印<code>&quot;hello&quot;</code>，父进程打印<code>&quot;goodbye&quot;</code>。你能否在父进程中不调用<code>wait()</code>的情况下保证子进程总是先打印？</p>
<hr>
<p>我感觉上一道题暗示我们，让子进程打印一点东西到文件中，然后在父进程中不断查看该文件中是否含有希望的信息。但我感觉这个做法可能不太可取。查了一些资料之后，我尝试让父进程用<a href="https://linux.die.net/man/2/kill" target="_blank" rel="noopener">kill(2)</a>检查子进程是否正在运行，但是我发现这也不可行，因为对僵尸进程进行这一检查也会返回<code>0</code>。事实上最科学的做法就是<code>wait()</code>系统调用了……所以我干脆用<code>waitpid()</code>好了。</p>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw03.c" target="_blank" rel="noopener">hw03.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw03</span><br><span class="line">Hello, I am child</span><br><span class="line">Goodbye, I am parent</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h2>
<p>写一个程序，调用<code>fork()</code>，然后通过某种形式的<code>exec()</code>运行<code>/bin/ls</code>。你能否尝试使用<code>exec()</code>的所有变形，包括<code>execl()</code>、<code>execle()</code>、<code>execlp()</code>、<code>execv()</code>、<code>execp()</code>和<code>execvpe()</code>？这个调用为何有这么多种形式？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw04.c" target="_blank" rel="noopener">hw04.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw04</span><br><span class="line">Parent: ready for execl(const char *path, const char *arg, ... /* (char  *) NULL */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execlp(const char *file, const char *arg, ... /* (char  *) NULL */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execv(const char *path, char *const argv[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execvp(const char *file, char *const argv[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execvpe(const char *file, char *const argv[], char *const envp[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>我猜这些形式主要是为了满足用户不同的需求。实际上，<code>exec</code>后面的那些后缀的含义是这样的（参见了<a href="http://www.cnblogs.com/mickole/p/3187409.html" target="_blank" rel="noopener">linux系统编程之进程（五）：exec系列函数（execl,execlp,execle,execv,execvp)使用</a>）：</p>
<ul>
<li><code>l</code>：参数以可变参数列表的形式给出，且以<code>NULL</code>结束（<code>execl()</code>，<code>execle()</code>，<code>execlp()</code>）</li>
<li>没有<code>l</code>：参数以<code>char *arg[]</code>形式给出，且<code>arg</code>最后一个元素必须为<code>NULL</code>（<code>execv()</code>，<code>execp()</code>，<code>execvpe()</code>）</li>
<li><code>p</code>：第一个参数不用输入完整路径，给出命令名即可，程序会在环境变量PATH当中查找命令（<code>execlp()</code>，<code>execp()</code>，<code>execvpe()</code>）</li>
<li>没有<code>p</code>：第一个参数需要输入完整路径（<code>execl()</code>，<code>execle()</code>，<code>execv()</code>）</li>
<li><code>e</code>：将环境变量传递给新进程（<code>execle()</code>，<code>execvpe()</code>）</li>
<li>没有<code>e</code>：不传递环境变量（<code>execl()</code>，<code>execlp()</code>，<code>execv()</code>，<code>execp()</code>）</li>
</ul>
<h2 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h2>
<p>写一个程序，让父进程调用<code>wait()</code>，等待子进程完成。<code>wait()</code>将返回什么？如果在子进程中调用<code>wait()</code>，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw05.c" target="_blank" rel="noopener">hw05.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw05</span><br><span class="line">I am parent (pid:4154)</span><br><span class="line">I am child (pid:4155)</span><br><span class="line">Child: wait() returns -1</span><br><span class="line">Parent: wait() returns 4155</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>如果<a href="http://man7.org/linux/man-pages/man2/waitpid.2.html" target="_blank" rel="noopener">wait(2)</a>找到了至少一个状态已经变化的子进程，则它会返回这个子进程的PID（因此此处父进程返回了子进程的PID，4155）；而子进程自己没有子进程，因此调用失败，返回<code>-1</code>。</p>
<h2 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h2>
<p>稍微修改一下上一题中的程序，改为使用<code>waitpid()</code>，而不是<code>wait()</code>。<code>waitpid()</code>何时是有用的？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw06.c" target="_blank" rel="noopener">hw06.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw06</span><br><span class="line">I am parent (pid:4368)</span><br><span class="line">I am child (pid:4369)</span><br><span class="line">Child: waitpid(-1) returns -1</span><br><span class="line">Parent: waitpid(4369) returns 4369</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>在需要等待某一个子进程执行完毕时，可以使用<code>waitpid()</code>。调用<code>waitpid(-1)</code>的效果与<code>wait()</code>基本是类似的。</p>
<h2 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h2>
<p>写一个程序，创建一个子进程，并在子进程中关闭标准输出（<code>STDOUT_FILENO</code>）。在关闭该文件描述符之后，如果子进程调用<code>printf()</code>来打印输出，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw07.c" target="_blank" rel="noopener">hw07.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw07</span><br><span class="line">I am parent</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>结果，无论是关闭之前还是关闭之后的<code>printf</code>都没有在屏幕打印出结果。我并没有查到为什么……</p>
<h2 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h2>
<p>写一个程序，创建两个子进程，通过<code>pipe()</code>系统调用，把其中一个进程的标准输出连接到另一个的标准输入。</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw08.c" target="_blank" rel="noopener">hw08.c</a>，参考了<a href="http://sealbird.iteye.com/blog/867908" target="_blank" rel="noopener">UNIX管道编程——使用pipe函数，dup函数，dup2函数</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw08</span><br><span class="line">Child 1 (pid=4727), writing to pipe.</span><br><span class="line">Child 2 (pid=4728), reading from pipe.</span><br><span class="line">Hello world , this is transported by pipe.</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-04-homework-simulation-process-run-py/">
              
                  OSTEP第04章作业：Simulation: process-run.py
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-08-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章作业见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a>和<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/HW-CPU-Intro.tgz" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/HW-CPU-Intro.tgz</a>。</p>
<hr>
<p>作业说明和模拟器代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/tree/master/ch04_Process-Intro" target="_blank" rel="noopener">https://github.com/zhanghuimeng/ostep-hw-translation/tree/master/ch04_Process-Intro</a>。</p>
<p>这次作业没有明确地说明调度策略——这也是因为现在还没有介绍到调度策略这么复杂的东西。通过阅读代码，我发现选择下一个运行进程的策略是通过PID进行循环查找：从当前进程的PID开始，如果这个进程处于就绪态，则选择它；否则<code>PID = (PID + 1) % 进程总数</code>。这个策略不太实际（有点类似于FIFO，但是优先级依赖于PID），但显然对于手动模拟比较方便。</p>
<h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h2>
<p>用以下参数运行程序：<code>./process-run.py -l 5:100,5:100</code>。CPU利用率（CPU处于使用状态的时间比例）是多少？为什么？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>我猜测Process0会先运行5个时间片；Process0运行完之后，Process1再运行5个时间片，也会结束。因为CPU运行完Process0就运行了Process1，中间没有空闲的时间，因此CPU利用率为100%。</p>
<p>运行结果如下（因为是win环境，所以用的是python）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 5:100,5:100 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2     RUN:cpu      READY          1</span><br><span class="line">  3     RUN:cpu      READY          1</span><br><span class="line">  4     RUN:cpu      READY          1</span><br><span class="line">  5     RUN:cpu      READY          1</span><br><span class="line">  6        DONE    RUN:cpu          1</span><br><span class="line">  7        DONE    RUN:cpu          1</span><br><span class="line">  8        DONE    RUN:cpu          1</span><br><span class="line">  9        DONE    RUN:cpu          1</span><br><span class="line"> 10        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 10</span><br><span class="line">Stats: CPU Busy 10 (100.00%)</span><br><span class="line">Stats: IO Busy  0 (0.00%)</span><br></pre></td></tr></table></figure>
<p>可以看出这个推测是正确的。</p>
<h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h2>
<p>用以下参数运行程序：<code>./process-run.py -l 4:100,1:0</code>。这些参数给定了两个进程，其中一个包含4条CPU指令，另一个只发出一个I/O请求并等待请求结束。两个进程都结束执行需要多长时间？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>Process0不发出I/O请求，因此它会一直执行到结束，共花费4个时间片。Process1发出一个I/O请求（1个时间片），I/O请求执行完毕需要5个时间片；因此，一共需要10个时间片结束执行。</p>
<p>运行结果如下（实际上刚才的结果参考了运行结果，因为我不知道所谓的“I/O请求花费5个时间片”算不算发出请求的指令的时间……当然从情理上和实验上来说都是不算的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 4:100,1:0 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2     RUN:cpu      READY          1</span><br><span class="line">  3     RUN:cpu      READY          1</span><br><span class="line">  4     RUN:cpu      READY          1</span><br><span class="line">  5        DONE     RUN:io          1</span><br><span class="line">  6        DONE    WAITING                     1</span><br><span class="line">  7        DONE    WAITING                     1</span><br><span class="line">  8        DONE    WAITING                     1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 10</span><br><span class="line">Stats: CPU Busy 5 (50.00%)</span><br><span class="line">Stats: IO Busy  4 (40.00%)</span><br></pre></td></tr></table></figure>
<h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h2>
<p>现在切换进程的顺序：<code>./process-run.py -l 1:0,4:100</code>。切换顺序对于结束执行的时间有影响吗？继续用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>显然有影响，因为Process0发出一个I/O请求（花费1个时间片）后，就会切换到Process1开始执行（4个时间片）；与此同时，I/O请求需要5个时间片完成。因此执行时间减少到了6个时间片。这说明了进程切换的必要性，因为增加了并行性，可以增加各种设备的利用率。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 6</span><br><span class="line">Stats: CPU Busy 5 (83.33%)</span><br><span class="line">Stats: IO Busy  4 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h2>
<p>下面我们探索一下其他的参数。参数<code>-S</code>指定了进程发出I/O请求时系统的反应策略。当该参数的值为<code>SWITCH_ON_END</code>时，系统不会在当前进程发出I/O请求时切换到另一个进程，而是等待进程结束之后再切换。如果你用以下参数运行程序（<code>-l 1:0,4:100 -c -S SWITCH_ON_END</code>），会发生什么？</p>
<hr>
<p>这道题的进程配置和上一道题一样，但是如果在进程发出I/O请求时不切换，就相当于必须执行完当前进程才能切换到下一个，这样设备利用率显然会下降，而运行时间会增加。Process0执行完需要6个时间片，Process1需要4个时间片，因此总时间为10个时间片，与进程顺序颠倒时相同。</p>
<p>运行结果如下（好吧，这说明我的分析有一点问题，这似乎与结束的总时间如何计算有关）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING      READY                     1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6*       DONE    RUN:cpu          1</span><br><span class="line">  7        DONE    RUN:cpu          1</span><br><span class="line">  8        DONE    RUN:cpu          1</span><br><span class="line">  9        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 9</span><br><span class="line">Stats: CPU Busy 5 (55.56%)</span><br><span class="line">Stats: IO Busy  4 (44.44%)</span><br></pre></td></tr></table></figure>
<h2 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h2>
<p>现在把<code>-S</code>参数的值置为SWITCH_ON_IO，此时只要进程发出I/O请求，就会切换到别的进程。（参数为<code>-l 1:0,4:100 -c -S SWITCH_ON_IO</code>）。那么，会发生什么呢？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>把参数设置成这样似乎就是默认值。结论是和第4题的分析相同吧？</p>
<p>运行结果如下（是的，的确如此）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 6</span><br><span class="line">Stats: CPU Busy 5 (83.33%)</span><br><span class="line">Stats: IO Busy  4 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h2>
<p>I/O请求结束时系统的执行策略也很重要。如果将参数<code>-I</code>的值置为<code>IO_RUN_LATER</code>，则I/O请求完成时，发出请求的进程不会立刻开始执行，当前运行中的进程会继续运行。如果使用以下参数组合，会发生什么？（<code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER</code>）</p>
<hr>
<p><code>IO_RUN_LATER</code>似乎就是默认值。Process0首先发出一个I/O请求（1个时间片），之后Process1，Process2和Process3依次执行完毕（共15个时间片）；最后Process0再重新开始执行，花费10个时间片进行两个I/O请求。然后，似乎因为最后一条指令为I/O指令，所以需要多花一个时间片确认为DONE（这一点是根据运行结果凑出来的）。因此总时间为27个时间片。</p>
<p>这个调度方法比较愚蠢，如果把Process0的I/O请求分散开，可以提高CPU和I/O设备的利用率。这说明在设计调度策略的时候，我们应当考虑到I/O密集型进程和CPU密集型进程的不同特点。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1     PID: 2     PID: 3        CPU        IOs</span><br><span class="line">  1      RUN:io      READY      READY      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  3     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  4     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  5     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  6*      READY    RUN:cpu      READY      READY          1</span><br><span class="line">  7       READY       DONE    RUN:cpu      READY          1</span><br><span class="line">  8       READY       DONE    RUN:cpu      READY          1</span><br><span class="line">  9       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 10       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 11       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 12       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 13       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 14       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 15       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 16       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 17      RUN:io       DONE       DONE       DONE          1</span><br><span class="line"> 18     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 19     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 20     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 21     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 22*     RUN:io       DONE       DONE       DONE          1</span><br><span class="line"> 23     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 24     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 25     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 26     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 27*       DONE       DONE       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 27</span><br><span class="line">Stats: CPU Busy 18 (66.67%)</span><br><span class="line">Stats: IO Busy  12 (44.44%)</span><br></pre></td></tr></table></figure>
<h2 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h2>
<p>将参数<code>-I</code>的值换成<code>IO_RUN_IMMEDIATE</code>，重新执行上述命令，此时，当I/O请求完成时，发出请求的进程会立刻抢占CPU。现在程序的运行结果有何不同？为什么让刚刚执行完I/O的进程立刻开始运行可能是个好主意？</p>
<hr>
<p>就像上一题所分析的那样，如果把I/O请求分散开来，则可以提高设备的利用率。在设计调度策略的时候应当考虑到进程的I/O密集程度，这个思路见于多级反馈队列调度算法中——如果进程用完了时间片则下移一个队列；否则，如果在时间片结束之前就发出了I/O请求，则保留在当前队列中。此时花费的总时间就是3条I/O指令加上15条CPU指令的时间。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p</span><br><span class="line">Time     PID: 0     PID: 1     PID: 2     PID: 3        CPU        IOs</span><br><span class="line">  1      RUN:io      READY      READY      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  3     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  4     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  5     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  6*     RUN:io      READY      READY      READY          1</span><br><span class="line">  7     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  8     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line">  9     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 10     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 11*     RUN:io       DONE      READY      READY          1</span><br><span class="line"> 12     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 13     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 14     WAITING       DONE       DONE    RUN:cpu          1          1</span><br><span class="line"> 15     WAITING       DONE       DONE    RUN:cpu          1          1</span><br><span class="line"> 16*       DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 17        DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 18        DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 18</span><br><span class="line">Stats: CPU Busy 18 (100.00%)</span><br><span class="line">Stats: IO Busy  12 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h2>
<p>用下列随机生成的参数组合运行程序，比如<code>-s 1 -l 3:50,3:50</code>，<code>-s 2 -l 3:50,3:50</code>和<code>-s 3 -l 3:50,3:50</code>。你能否预测程序运行结果？将<code>-I</code>参数的值分别置为<code>IO_RUN_IMMEDIATE</code>和<code>IO_RUN_LATER</code>时，运行结果有何区别？将<code>-S</code>参数的值分别置为<code>SWITCH_ON_IO</code>和<code>SWITCH_ON_END</code>时，运行结果有何区别？</p>
<hr>
<h3 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h3>
<p>使用参数<code>-s 1 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  cpu</span><br><span class="line">  cpu</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50 -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6     WAITING       DONE                     1</span><br><span class="line">  7*     RUN:io       DONE          1</span><br><span class="line">  8     WAITING       DONE                     1</span><br><span class="line">  9     WAITING       DONE                     1</span><br><span class="line"> 10     WAITING       DONE                     1</span><br><span class="line"> 11     WAITING       DONE                     1</span><br><span class="line"> 12*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 12</span><br><span class="line">Stats: CPU Busy 6 (50.00%)</span><br><span class="line">Stats: IO Busy  8 (66.67%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时结果相同，因为Process0发出的I/O请求在Process1完全执行结束之后才完成：</p>
<p><code>-S SWITCH_ON_IO</code>时结果也相同，因为这个是默认值。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间变长，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50 -S SWITCH_ON_END -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6     WAITING      READY                     1</span><br><span class="line">  7*     RUN:io      READY          1</span><br><span class="line">  8     WAITING      READY                     1</span><br><span class="line">  9     WAITING      READY                     1</span><br><span class="line"> 10     WAITING      READY                     1</span><br><span class="line"> 11     WAITING      READY                     1</span><br><span class="line"> 12*       DONE    RUN:cpu          1</span><br><span class="line"> 13        DONE    RUN:cpu          1</span><br><span class="line"> 14        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 14</span><br><span class="line">Stats: CPU Busy 6 (42.86%)</span><br><span class="line">Stats: IO Busy  8 (57.14%)</span><br></pre></td></tr></table></figure>
<h3 id="82"><a class="markdownIt-Anchor" href="#82"></a> 8.2</h3>
<p>使用参数<code>-s 2 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时，输出如下，出现了两个进程同时I/O的情况（不过此时我们认为I/O是可以并行的，不存在等待I/O设备的问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50 -I IO_RUN_LATER -p -c</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING     RUN:io          1          1</span><br><span class="line">  4     WAITING    WAITING                     2</span><br><span class="line">  5     WAITING    WAITING                     2</span><br><span class="line">  6*     RUN:io    WAITING          1          1</span><br><span class="line">  7     WAITING    WAITING                     2</span><br><span class="line">  8*    WAITING     RUN:io          1          1</span><br><span class="line">  9     WAITING    WAITING                     2</span><br><span class="line"> 10     WAITING    WAITING                     2</span><br><span class="line"> 11*    RUN:cpu    WAITING          1          1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 13</span><br><span class="line">Stats: CPU Busy 6 (46.15%)</span><br><span class="line">Stats: IO Busy  11 (84.62%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时，输出完全相同（因为I/O请求很多，所以当前I/O结束之后，CPU处于空闲状态，可以直接开始执行下一条指令）。</p>
<p><code>-S SWITCH_ON_IO</code>时输出完全相同（因为这是默认值……）。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间大大增加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50 -S SWITCH_ON_END -p -c</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING      READY                     1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6*     RUN:io      READY          1</span><br><span class="line">  7     WAITING      READY                     1</span><br><span class="line">  8     WAITING      READY                     1</span><br><span class="line">  9     WAITING      READY                     1</span><br><span class="line"> 10     WAITING      READY                     1</span><br><span class="line"> 11*    RUN:cpu      READY          1</span><br><span class="line"> 12        DONE    RUN:cpu          1</span><br><span class="line"> 13        DONE     RUN:io          1</span><br><span class="line"> 14        DONE    WAITING                     1</span><br><span class="line"> 15        DONE    WAITING                     1</span><br><span class="line"> 16        DONE    WAITING                     1</span><br><span class="line"> 17        DONE    WAITING                     1</span><br><span class="line"> 18*       DONE     RUN:io          1</span><br><span class="line"> 19        DONE    WAITING                     1</span><br><span class="line"> 20        DONE    WAITING                     1</span><br><span class="line"> 21        DONE    WAITING                     1</span><br><span class="line"> 22        DONE    WAITING                     1</span><br><span class="line"> 23*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 23</span><br><span class="line">Stats: CPU Busy 6 (26.09%)</span><br><span class="line">Stats: IO Busy  16 (69.57%)</span><br></pre></td></tr></table></figure>
<h3 id="83"><a class="markdownIt-Anchor" href="#83"></a> 8.3</h3>
<p>使用参数<code>-s 3 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 3 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 3 -l 3:50,3:50 -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING     RUN:io          1          1</span><br><span class="line">  4     WAITING    WAITING                     2</span><br><span class="line">  5     WAITING    WAITING                     2</span><br><span class="line">  6     WAITING    WAITING                     2</span><br><span class="line">  7*    RUN:cpu    WAITING          1          1</span><br><span class="line">  8*       DONE     RUN:io          1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10        DONE    WAITING                     1</span><br><span class="line"> 11        DONE    WAITING                     1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 13</span><br><span class="line">Stats: CPU Busy 6 (46.15%)</span><br><span class="line">Stats: IO Busy  9 (69.23%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时输出不变，因为I/O请求结束的时间又一次恰好和CPU被占用的时间错开了。</p>
<p><code>-S SWITCH_ON_IO</code>时输出不变（因为这仍然是默认值）。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间仍然会增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">python process-run.py -s 3 -l 3:50,3:50 -S SWITCH_ON_END -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6     WAITING      READY                     1</span><br><span class="line">  7*    RUN:cpu      READY          1</span><br><span class="line">  8        DONE     RUN:io          1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10        DONE    WAITING                     1</span><br><span class="line"> 11        DONE    WAITING                     1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE     RUN:io          1</span><br><span class="line"> 14        DONE    WAITING                     1</span><br><span class="line"> 15        DONE    WAITING                     1</span><br><span class="line"> 16        DONE    WAITING                     1</span><br><span class="line"> 17        DONE    WAITING                     1</span><br><span class="line"> 18*       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 18</span><br><span class="line">Stats: CPU Busy 6 (33.33%)</span><br><span class="line">Stats: IO Busy  12 (66.67%)</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-05-summary-interlude-process-api/">
              
                  OSTEP第05章总结：Interlude: Process API
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-07
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf</a>。</p>
<hr>
<p>本章的内容是“幕间休息”（interlude）：这些章节讲的是OS中与具体API相关的内容，和原理关系不大，如果不想了解这些具体内容，可以跳过。（但是最好还是不跳过，因为实践出真知，对吧？）本章主要介绍了以下三个与进程创建相关的UNIX系统调用，以及它们的设计原理：</p>
<ul>
<li><code>fork()</code></li>
<li><code>wait()</code></li>
<li><code>exec()</code></li>
</ul>
<h2 id="fork系统调用通过复制来创建新进程"><a class="markdownIt-Anchor" href="#fork系统调用通过复制来创建新进程"></a> fork系统调用：通过复制来创建新进程</h2>
<p>下面的例子说明了<code>fork()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// p1.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        printf(&quot;hello, I am parent of %d (pid:%d)\n&quot;,</span><br><span class="line">        rc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，程序开始执行的时候打印了一条信息，其中包含了<strong>进程标识符</strong>（process identifier，PID）。该进程的PID是29146。在UNIX系统中，PID是进程的唯一标识。然后进程调用了<code>fork()</code>系统调用，通过拷贝当前进程创建了一个新进程。有趣的是，这两个进程几乎相同，都正准备从<code>fork()</code>系统调用返回。新进程（称为子进程；原来的进程称为父进程）不会从<code>main()</code>开始运行（因为<code>hello world</code>只被打印了一次），而是好像自己已经调用了<code>fork()</code>一样。这样设计的原因，将在后面进行解释。</p>
<p>子进程和父进程几乎相同（地址空间、寄存器、PC），只有一点区别：<code>fork()</code>调用的返回值不同。父进程的返回值是子进程的PID，而子进程的返回值是0。这一区别使得我们可以撰写代码分别处理这两种情况。</p>
<p>值得注意的另一点是，p1.c的输出是<strong>不确定的</strong>（nondeterminism）：当子进程创建的时候，系统中出现了两个活跃进程，而CPU调度器选择哪一个先开始运行是不确定的。因此，如果子进程被创建之后立刻开始运行，上述程序的输出就会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="wait系统调用等待子进程退出"><a class="markdownIt-Anchor" href="#wait系统调用等待子进程退出"></a> wait系统调用：等待子进程退出</h2>
<p>下面的例子说明了<code>wait()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// p2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (wc:29267) (pid:29266)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，父进程调用<code>wait()</code>，使得它在子进程结束执行之后才继续执行。当子进程结束之后，<code>wait()</code>调用才返回。此时，上述代码的输出显然是确定（deterministic）的了。如果父进程先运行，它会立刻调用<code>wait()</code>，等待子进程运行结束；因此子进程必然先运行。</p>
<h2 id="exec系统调用通过覆盖改变当前进程的内容"><a class="markdownIt-Anchor" href="#exec系统调用通过覆盖改变当前进程的内容"></a> exec系统调用：通过覆盖改变当前进程的内容</h2>
<p>下面的例子说明了<code>exec()</code>系统调用的使用方法，它一般和<code>fork()</code>一起使用，用于创建新进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p3.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">        printf(&quot;this shouldn’t print out&quot;);</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (wc:29384) (pid:29383)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>事实上，在Linux中，<code>exec()</code>是一类系统调用的总称，一共有6个变种：<code>execl()</code>，<code>execlp()</code>，<code>execle()</code>，<code>execv()</code>，<code>execvp()</code>和<code>execvpe()</code>。详情见<a href="http://man7.org/linux/man-pages/man3/exec.3.html" target="_blank" rel="noopener">exec(3)</a></p>
<p>在这个例子中，在调用<code>fork()</code>创建子进程后，子进程调用了<code>execvp()</code>，用程序<code>wc</code>覆盖自己并开始执行该程序。<code>wc</code>是字数统计（word counting）程序，此处它被用来统计源文件<code>p3.c</code>中行、词和字节的数量。</p>
<p><code>fork()</code>系统调用的设计固然很怪，它的“同伙”<code>exec()</code>也有够怪的。事实上，<code>exec()</code>所做的事情是这样的：给定一个可执行文件的名字（如<code>wc</code>）和一些参数（如<code>p3.c</code>），它会<strong>加载</strong>（load）这个可执行文件的代码（和静态数据），覆盖当前进程的代码段和静态数据，并且重新初始化进程的堆栈和其他内存空间。然后OS把参数作为新进程的<code>argv</code>数组，直接开始运行新程序。所以<code>exec()</code>调用并没有创建一个新进程；它只是把当前正在运行的进程（<code>p3</code>）换成了一个新的程序（<code>wc</code>）。在子进程执行<code>exec()</code>调用之后，<code>p3.c</code>就好像从未运行过一样了；对<code>exec()</code>的成功调用是不会返回的。</p>
<h2 id="fork和exec的设计原因方便shell和管道的实现"><a class="markdownIt-Anchor" href="#fork和exec的设计原因方便shell和管道的实现"></a> fork和exec的设计原因：方便shell和管道的实现</h2>
<p>我们为什么要这样设计创建新进程的API呢？事实上，对于UNIX shell来说，在创建新进程的过程中把<code>fork()</code>和<code>exec()</code>分开是非常必要的，因为这样shell才能在调用<code>fork()</code>之后，调用<code>exec()</code>的过程之前运行一些代码来改变即将运行的程序的环境，这就使得我们可以创造很多有趣的特性。</p>
<p>shell是一个帮助你执行程序（命令）的用户程序。它显示一个<strong>命令提示符</strong>（prompt），然后等待你在里面打字。你在里面打一个命令（比如可执行程序的名字和参数）；然后，shell一般会找到这个可执行程序在文件系统中的位置，调用<code>fork()</code>创建一个新的子进程，然后（子进程）调用<code>exec()</code>的某个变种开始执行命令，最后（父进程）调用<code>wait()</code>等待命令执行结束。当子进程运行结束之后，shell（父进程）从<code>wait()</code>返回，再次打印出命令提示符，等待你的下一条指令。</p>
<p>把<code>fork()</code>和<code>exec()</code>分开使得shell能在其间够做很多有用的东西。比如，我们执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; wc p3.c &gt; newfile.txt</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>wc</code>的输出被<strong>重定向</strong>（redirect）到输出文件<code>newfile.txt</code>中。shell完成这个任务的方法很简单：在创建子进程之后，调用<code>exec()</code>之前，shell关闭<strong>标准输出</strong>（standard output）并打开文件<code>newfile.txt</code>。这样，即将被执行的程序<code>wc</code>的任何输出都会被发送到这个文件而不是屏幕。</p>
<p>下面的代码实现了子进程输出的重定向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p4.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child: redirect standard output to a file</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        // now exec &quot;wc&quot;...</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p4</span><br><span class="line">prompt&gt; cat p4.output</span><br><span class="line">32 109 846 p4.c</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>这种方法的工作原理与OS管理文件描述符的方法相关。UNIX系统在分配文件描述符时，会从0开始寻找空闲的文件描述符。<a href="/post/ostep-ch-04-summary-the-abstraction-the-process">上一章</a>中曾经讲过，对于一个进程，默认有三个文件描述符是开启的：标准输入（<code>STDIN_FILENO=0</code>）、标准输出（<code>STDOUT_FILENO=1</code>）和标准错误输出（<code>STDERR_FILENO=2</code>）。关闭标准输出之后，在调用<code>open()</code>分配新的文件描述符时，<code>STDOUT_FILENO=1</code>就成了第一个可用的文件描述符，于是它就指向了我们需要的输出文件<code>./p4.output</code>。于是，子进程之后对标准输出文件描述符的写操作会被透明地指向新打开的文件。（真是有趣的设计啊）</p>
<p>UNIX<strong>管道</strong>（pipe）机制的实现方法类似。通过<code>pipe()</code>系统调用，一个进程的输出被连接到一个内核管道（pipe）中，另一个进程的输入也连接到这个相同的管道；这样，一个进程的输出就无缝连接到另一个进程的输入了。下面的例子通过管道命令实现了在文件中查找词并计算这个词出现次数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o foo file | wc -l</span><br></pre></td></tr></table></figure>
<h2 id="温馨提示"><a class="markdownIt-Anchor" href="#温馨提示"></a> 温馨提示</h2>
<h3 id="rtfm"><a class="markdownIt-Anchor" href="#rtfm"></a> RTFM</h3>
<p>我们刚才只是大概介绍了这些系统调用的基本原理，还有许多细节没有涉及到。为了了解这些细节，你应当去阅读手册。作为一个系统程序员，阅读<strong>手册</strong>（manual/man pages）是非常重要的，因为里面提供了很多细节，而且还可以帮助你减少烦你的同事的次数。如果你直接去问他们细节问题，他们可能会回答你：“<a href="https://zh.wikipedia.org/zh/RTFM" target="_blank" rel="noopener">RTFM</a>。”（Read the fucking manual！）</p>
<h3 id="get-it-right"><a class="markdownIt-Anchor" href="#get-it-right"></a> Get it right</h3>
<p>兰普森（<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%89%B9%E5%8B%92%C2%B7%E8%98%AD%E6%99%AE%E6%A3%AE" target="_blank" rel="noopener">Butler W. Lampson</a>）在他那篇广受好评的论文“<a href="https://microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf" target="_blank" rel="noopener">Hints for Computer Systems Design</a>”中这样说：“做正确的事。（<strong>Get it right.</strong>）抽象和简化都不能代替正确的做法。”</p>
<p>实际上，设计进程创建API有很多方法，但是UNIX的设计者选择了正确的那一种。（虽然我觉得本章中并没有充分论述它的正确性）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-04-summary-the-abstraction-the-process/">
              
                  OSTEP第04章总结：The Abstraction: The Process
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a>。</p>
<hr>
<p>这一章主要讲了OS的一种基本抽象模型：进程（Process）。</p>
<ul>
<li>进程的定义</li>
<li>与进程相关的API</li>
<li>进程的创建过程和状态（生命周期）</li>
<li>进程的数据结构（进程控制块和进程状态队列）</li>
</ul>
<h2 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h2>
<p>我们首先给出一个进程的非正式定义：进程是一个正在运行的程序。</p>
<p>我们通常希望同时运行多个（甚至成百上千个）程序。这样用起来很方便，但是我们遇到的挑战是：如何创造这样由很多个虚拟CPU的假象？</p>
<p>OS通过对CPU进行虚拟化创造这一假象。它不断地运行一个程序，暂停，然后再运行下一个。这被称作CPU的分时共享（time sharing），这种技术允许程序的并发，同时也会牺牲一定的性能，因为一个程序的运行时间肯定会慢得多。</p>
<p>我们可以把实现CPU的虚拟化的过程拆分成两个步骤：</p>
<ul>
<li>机制（mechanism）：这是实现一种功能的底层方法或协议；如上下文切换（context switch），这是一种分时机制（time-sharing mechanism），用于帮助OS实现暂停一个程序后切换到下一个的功能</li>
<li>策略（policy）：这是利用底层机制，在OS内进行决策的算法；如调度（scheduling）算法会利用历史信息、程序信息和性能评价方式进行决策</li>
</ul>
<p>这是一种模块化的程序设计思路。不过，本节中我们似乎既没有讲机制也没有讲策略，而是讲了一些抽象内容（进程）的基本概念。</p>
<h2 id="进程的正式定义"><a class="markdownIt-Anchor" href="#进程的正式定义"></a> 进程的正式定义</h2>
<p>上面给出的那个定义是正确的，然而并不全面。如何更具体地描述一个进程？一般来说，我们可以通过记录进程在运行过程中访问或影响的系统部分来描述一个进程。于是我们可以定义进程的机器状态（machine state）：</p>
<ul>
<li>内存（地址空间）：包含指令和程序读写的数据</li>
<li>寄存器：通用寄存器和一些特殊寄存器，如PC（program counter）和栈指针、帧指针</li>
<li>I/O信息：进程开启的文件列表</li>
</ul>
<h2 id="与进程相关的api"><a class="markdownIt-Anchor" href="#与进程相关的api"></a> 与进程相关的API</h2>
<p>既然进程是OS为我们提供的一种抽象，那么显然需要一些使用它的方法。因此下面介绍了一些与进程相关的API，一般来说，任何现代OS都提供了这些API：</p>
<ul>
<li>创建（create）：创建新进程</li>
<li>销毁（destroy）：强制终止进程，对于失控的进程来说是很必要的</li>
<li>等待（wait）：等待其他进程结束运行</li>
<li>其他控制（miscellaneous control）：除了杀死或等待进程以外的控制方式，如将进程挂起后恢复运行的机制</li>
<li>状态（status）：通常会提供一些能够获得进程状态信息的接口，包括运行时间和状态</li>
</ul>
<h2 id="进程的生命周期"><a class="markdownIt-Anchor" href="#进程的生命周期"></a> 进程的生命周期</h2>
<h3 id="进程的创建过程"><a class="markdownIt-Anchor" href="#进程的创建过程"></a> 进程的创建过程</h3>
<p>为了启动一个进程，OS需要做以下事情：</p>
<ol>
<li>将程序的代码和静态数据（初始化了的变量）加载到进程地址空间中。通常程序以某种可执行文件格式存储在磁盘（或者SSD）中，所以OS需要从磁盘读取数据。</li>
</ol>
<ul>
<li>此时有一个加载策略的选择问题：积极加载（eager load）还是懒惰加载（lazy load）</li>
<li>积极加载：将所有代码和数据在运行之前就全部装入内存中，是早期和简单OS的做法</li>
<li>懒惰加载：用到对应的代码和数据时才加载，是现代OS的做法。</li>
<li>这个问题与分页（paging）和交换（swapping）有关，之后还会谈到。</li>
</ul>
<ol start="2">
<li>为程序的运行栈分配内存；对栈进行初始化（比如把<code>main</code>函数的<code>argc</code>和<code>argv</code>放进去）</li>
<li>为程序的堆分配内存。堆用于在程序运行中动态分配内存，程序调用<code>malloc()</code>请求内存，调用<code>free()</code>释放内存。</li>
<li>对I/O进行初始化：对于类UNIX系统，每个进程默认有三个打开的文件描述符（file descriptor），用于标准输入、标准输出和标准错误输出，这使得进程能够从终端读入输入并打印到屏幕。我们将在本书的第三部分（持久化）中更多的谈到这个问题。</li>
<li>跳转到<code>main()</code>函数的起始点，将CPU的控制权交给新创建的进程。</li>
</ol>
<h3 id="进程的状态模型"><a class="markdownIt-Anchor" href="#进程的状态模型"></a> 进程的状态模型</h3>
<p>创建了一个进程之后，它的状态（state）会不断变化。一个简化的进程三状态模型如下：</p>
<ul>
<li>运行态（running）：进程正在处理器上运行，正在执行指令。</li>
<li>就绪态（ready）：进程已经准备好执行了，但由于某些原因，OS现在并没有运行它。</li>
<li>等待态（blocked）：进程执行了一些操作，使得它不能继续运行，直到发生某些其他事件为止。例如，进程启动对磁盘的I/O请求时，它就被阻塞了，此时其他的进程可以使用处理器。</li>
</ul>
<p><img src="fig4-2_process-state-transitins.png" alt="进程在状态之间的迁移"></p>
<p>上图说明了这个简化模型中进程如何在状态间迁移：</p>
<ul>
<li>OS可以通过调度使进程在运行态和就绪态之间转换</li>
<li>如果进程进入了等待态，则只有对应的事件发生时才会进入就绪态</li>
</ul>
<p>下面举两个例子进行说明。在第一个例子中，两个进程只使用CPU而不进行I/O；调度策略是进程0执行完之后进程1才能开始执行。</p>
<p><img src="fig4-3_tracing-process-state-cpu-only.png" alt="只使用CPU的两个进程的状态变化"></p>
<p>在第二个例子中，进程会进行I/O操作。当进程0进行I/O之后，它进入阻塞状态。于是进程1开始运行。进程0的I/O完成之后，它进入就绪态，等待进程1执行结束之后继续执行。</p>
<p><img src="fig4-4_tracing-process-state-cpu-and-io.png" alt="使用CPU并进行I/O的两个进程的状态变化"></p>
<p>事实上，在上述过程中，OS采用了以下两种策略：</p>
<ul>
<li>在进程0进行I/O时切换到进程1：这个决策看起来是明智的，因为可以增加CPU使用率</li>
<li>在进程0的I/O操作结束之后，没有立即切换回切换0：这个策略的好坏很难说</li>
</ul>
<p>（上述内容将出现在作业中）</p>
<h2 id="进程的数据结构"><a class="markdownIt-Anchor" href="#进程的数据结构"></a> 进程的数据结构</h2>
<p>上面的内容可以说是非常抽象了。所以下面会讲到，这些抽象的内容如何用OS中具体的数据结构来表示。</p>
<h3 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h3>
<p>我们把进程信息对应的数据结构称为进程控制块（Process Control Block，PCB）。下面是xv6教学OS中一个实际的进程控制块的定义（也就是说，会涉及大量<strong>底层机制</strong>内容）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// the registers xv6 will save and restore</span><br><span class="line">// to stop and subsequently restart a process</span><br><span class="line">struct context &#123;</span><br><span class="line">    int eip;</span><br><span class="line">    int esp;</span><br><span class="line">    int ebx;</span><br><span class="line">    int ecx;</span><br><span class="line">    int edx;</span><br><span class="line">    int esi;</span><br><span class="line">    int edi;</span><br><span class="line">    int ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// the different states a process can be in</span><br><span class="line">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line">// the information xv6 tracks about each process</span><br><span class="line">// including its register context and state</span><br><span class="line">struct proc &#123;</span><br><span class="line">    char *mem;                  // Start of process memory</span><br><span class="line">    uint sz;                    // Size of process memory</span><br><span class="line">    char *kstack;               // Bottom of kernel stack</span><br><span class="line">                                // for this process</span><br><span class="line">    enum proc_state state;      // Process state</span><br><span class="line">    int pid;                    // Process ID</span><br><span class="line">    struct proc *parent;        // Parent process</span><br><span class="line">    void *chan;                 // If non-zero, sleeping on chan</span><br><span class="line">    int killed;                 // If non-zero, have been killed</span><br><span class="line">    struct file *ofile[NOFILE]; // Open files</span><br><span class="line">    struct inode *cwd;          // Current directory</span><br><span class="line">    struct context context;     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;       // Trap frame for the</span><br><span class="line">                                // current interrupt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面对其中一些比较重要的内容给出说明。首先可以看到，<code>context</code>中存储了通用寄存器的内容，用于上下文切换（保存一个暂停的进程的寄存器的值；在进程恢复运行时，这些值将被重新加载到寄存器中），这是之前讲到的。其次可以发现，这里定义了6种状态，和之前讲到的三状态模型不完全相符（这可能也体现了抽象策略和底层机制的区别）。除了运行态、就绪态和等待态以外，此处还定义了其他的状态，如初始（initial）态（进程刚被创建时的状态，对应的大概是上述代码中的EMBRYO态）和终止（final）态（进程已经退出，但尚未被完全清理，在类UNIX系统中，这一状态被称为僵尸（zombie）态）。进入终止态的进程允许其他进程（通常是创建这个进程的父进程）检查进程的返回值，查看它是否成功结束。父进程在自己结束之前会执行最后一个调用（<code>wait()</code>），等待子进程执行完成（进入终止态），此时OS可以清理子进程相关的数据结构。</p>
<p>（我不知道我有没有理解清楚关于僵尸态的内容）</p>
<h3 id="进程状态队列"><a class="markdownIt-Anchor" href="#进程状态队列"></a> 进程状态队列</h3>
<p>为了管理进程的状态，OS会维护一些进程状态队列，用来跟踪就绪进程、正在运行的进程和阻塞进程，并且在发生事件的时候唤醒正确的进程。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-03-summary-a-dialogue-on-virtualization/">
              
                  OSTEP第03章总结：A Dialogue on Virtualization
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-03
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这篇对话是本书第一部分——虚拟化（Virtualization）——的开头，简单叙述了一下虚拟化的概念。</p>
<p>Professor教授（我今后就这样叫他了，毕竟这位教授的名字就是“Professor”）举了一个这样的例子：假设我们有一个物理的桃子，有很多人都想吃桃子，但桃子只有一个，不能满足所有人的需求。于是我们通过某种神奇的技术，在物理桃子的基础上创造出许多虚拟桃子，仿佛每个人都拥有自己的桃子一般，但事实上只有一个桃子。</p>
<p>这时Student学生（同理）提了一个很好的问题：如果很多人同时共享一个桃子，他们应该会注意到这一点。Professor教授指出，这些人大部分时间都在干别的，所以把桃子直接拿走是完全可行的。</p>
<p>Student学生要求Professor教授举一个具体的例子——那就PCU吧。假定系统里有一个物理CPU，虚拟化技术使得系统里好像有很多虚拟CPU在同时运行。每个进程都认为它独占了一个虚拟CPU，而实际上只有一个物理CPU。OS的工作就是将实际的CPU进行虚拟化。</p>
<p>最后Professor教授表示，今后不会再有这么多桃子的例子，因为他自己也不是很喜欢吃桃子。（但是作者很喜欢吧？）</p>
<hr>
<p>我很想探讨一下这个故事中的比喻到底指代的什么。桃子当然指的是被虚拟化后共享的资源——除了物理CPU之外，物理内存也被进程这样共享。不过桃子和CPU相比有一个小问题：桃子是会被吃完的，也就是说，这是一种不可再生资源，和CPU可以不断重复利用的性质不同。那我们就当这些食客只是在舔桃子好啦……</p>
<p>所谓“很多人同时共享一个桃子会被注意到”也许只是Student学生随口一说的结果，但我觉得这一点说的更像是同步互斥问题。毕竟进程没有思想和感受，它们之间一般是相互隔离的，所谓“注意到”必然是进程通信或共享资源的结果，而这种时候是一定会出现同步互斥问题的。但是，如果这样认为，Professor教授给出的解决方案就有点儿怪了——这些人大部分时间都在干别的？我想这说的是CPU运行进程和设备I/O的并行化——I/O需要的时间很多，所以在需要进行I/O时，进程就主动放弃控制权，切换别的进程来继续占用CPU。这一点当然很好，不过好像并不能解决同步互斥问题。</p>
<p>不过这也并没有那么重要，希望Professor教授和Student在书里过得开心，吃点自己想吃的水果好啦。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-02-summary-introduction-to-operating-systems/">
              
                  OSTEP第02章总结：Introduction to Operating Systems
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf</a>。</p>
<hr>
<p>这一章对全书内容做了一些简单的概括：</p>
<ul>
<li>用三个程序概括了本书将讲到的三个基本概念（虚拟化、并发、持久化）</li>
<li>讲了一些OS的设计目标和OS的历史</li>
</ul>
<h2 id="基本概念概述"><a class="markdownIt-Anchor" href="#基本概念概述"></a> 基本概念概述</h2>
<h3 id="虚拟化"><a class="markdownIt-Anchor" href="#虚拟化"></a> 虚拟化</h3>
<p>虚拟化是本书第一部分的主题。</p>
<h4 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: cpu &lt;string&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char *str = argv[1];</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">        Spin(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中调用的<code>Spin()</code>函数（具体程序见本章附带的<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Code/code.intro.tgz" target="_blank" rel="noopener">代码</a>）会在运行1秒后返回。这个程序会不断运行，每秒输出一个<code>A</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o cpu cpu.c -Wall</span><br><span class="line">prompt&gt; ./cpu &quot;A&quot;</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">ˆC</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>如果同时运行不同的程序实例，CPU会不断在程序之间切换，使得每个程序都认为自己独占了CPU，这被称为CPU的<strong>虚拟化</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./cpu A &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D &amp;</span><br><span class="line">[1] 7353</span><br><span class="line">[2] 7354</span><br><span class="line">[3] 7355</span><br><span class="line">[4] 7356</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而OS选择什么程序来运行是一种<strong>策略</strong>，之后我们会学到相关内容（进程调度）。</p>
<h4 id="内存的虚拟化"><a class="markdownIt-Anchor" href="#内存的虚拟化"></a> 内存的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: mem &lt;value&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int *p;                   // memory for pointer is on &quot;stack&quot;</span><br><span class="line">    p = malloc(sizeof(int));  // malloc&apos;d memory is on &quot;heap&quot;</span><br><span class="line">    assert(p != NULL);</span><br><span class="line">    printf(&quot;(pid:%d) addr of p:        %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) &amp;p);</span><br><span class="line">    printf(&quot;(pid:%d) addr stored in p: %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) p);</span><br><span class="line">    *p = atoi(argv[1]);       // assign value to addr stored in p</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        Spin(1);</span><br><span class="line">        *p = *p + 1;</span><br><span class="line">        printf(&quot;(pid:%d) value of p: %d\n&quot;, getpid(), *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代机器的内存模型就是一个数组，读写都需要给出地址。</p>
<p>上述程序所做的事很简单：</p>
<ul>
<li>分配一些内存</li>
<li>打印内存的地址，以及程序的PID</li>
<li>将数0放入新分配的内存的第一个位置（4字节的int）中</li>
<li>循环，将p中存储的值+1</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem</span><br><span class="line">(2134) address pointed to by p: 0x200000</span><br><span class="line">(2134) p: 1</span><br><span class="line">(2134) p: 2</span><br><span class="line">(2134) p: 3</span><br><span class="line">(2134) p: 4</span><br><span class="line">(2134) p: 5</span><br><span class="line">ˆC</span><br></pre></td></tr></table></figure>
<p>如果仍然同时运行几个程序的实例，则会发现，每个程序都在同一地址处分配内存，而且对这一内存处存储的值的更新是相互独立的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem &amp;; ./mem &amp;</span><br><span class="line">[1] 24113</span><br><span class="line">[2] 24114</span><br><span class="line">(24113) address pointed to by p: 0x200000</span><br><span class="line">(24114) address pointed to by p: 0x200000</span><br><span class="line">(24113) p: 1</span><br><span class="line">(24114) p: 1</span><br><span class="line">(24114) p: 2</span><br><span class="line">(24113) p: 2</span><br><span class="line">(24113) p: 3</span><br><span class="line">(24114) p: 3</span><br><span class="line">(24113) p: 4</span><br><span class="line">(24114) p: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这说明OS对内存进行了虚拟化，每个进程访问的是自己的虚拟地址空间。</p>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common_threads.h&quot;</span><br><span class="line"></span><br><span class="line">volatile int counter = 0;</span><br><span class="line">int loops;</span><br><span class="line"></span><br><span class="line">void *worker(void *arg) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">        counter = counter + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: threads &lt;loops&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    loops = atoi(argv[1]);</span><br><span class="line">    pthread_t p1, p2;</span><br><span class="line">    printf(&quot;Initial value : %d\n&quot;, counter);</span><br><span class="line">    Pthread_create(&amp;p1, NULL, worker, NULL);</span><br><span class="line">    Pthread_create(&amp;p2, NULL, worker, NULL);</span><br><span class="line">    Pthread_join(p1, NULL);</span><br><span class="line">    Pthread_join(p2, NULL);</span><br><span class="line">    printf(&quot;Final value   : %d\n&quot;, counter);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一程序通过调用<code>Pthread_create</code>创建了两个线程，分别将一个计数器自增N次，然后将计数器的结果输出。显然，正常情况下程序输出应该为2N。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o thread thread.c -Wall -pthread</span><br><span class="line">prompt&gt; ./thread 1000</span><br><span class="line">Initial value : 0</span><br><span class="line">inal value : 2000</span><br></pre></td></tr></table></figure>
<p>但如果两个线程执行的次数N比较大，则程序的输出可能不再会为2N，而且会不太稳定。这是由于+1的操作不是原子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 143012 // huh??</span><br><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 137298 // what the??</span><br></pre></td></tr></table></figure>
<p>这体现了并发中可能出现的一些问题，我们将要在本书的第二部分讲到这些问题。</p>
<h3 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void do_work() &#123;</span><br><span class="line">    int fd = open(&quot;/tmp/file&quot;, O_WRONLY | O_CREAT | O_TRUNC,</span><br><span class="line">		  S_IRUSR | S_IWUSR);</span><br><span class="line">    assert(fd &gt;= 0);</span><br><span class="line">    char buffer[20];</span><br><span class="line">    sprintf(buffer, &quot;hello world\n&quot;);</span><br><span class="line">    int rc = write(fd, buffer, strlen(buffer));</span><br><span class="line">    assert(rc == strlen(buffer));</span><br><span class="line">    printf(&quot;wrote %d bytes\n&quot;, rc);</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    do_work();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会创建文件<code>/tmp/file</code>，并在里面写入字符串<code>hello world</code>。</p>
<p>内存是一种易失性存储，所以需要能够持续性地存储程序的硬件和软件，也就是硬盘（SSD）和文件系统。</p>
<p>和虚拟化的内存地址空间相比，因为用户通常会使用文件来共享信息，所以OS并不会为每个应用进程创建虚拟化的磁盘。OS向硬盘写数据的过程是十分复杂的，但OS对此进行了抽象，可以通过系统调用来访问设备。因此OS可以被看成是一个标准库。</p>
<h2 id="os的设计目标"><a class="markdownIt-Anchor" href="#os的设计目标"></a> OS的设计目标</h2>
<ul>
<li>抽象：使系统更易用</li>
<li>高性能</li>
<li>保护：在应用程序之间，以及应用程序和系统之间提供保护和隔离</li>
<li>可靠性</li>
<li>节能、安全性、可移动性……</li>
</ul>
<h2 id="os的历史"><a class="markdownIt-Anchor" href="#os的历史"></a> OS的历史</h2>
<ul>
<li>早期操作系统（大型机批处理系统）：基本只是标准库，需要操作员参与管理</li>
<li>中期操作系统：提供了文件系统和保护机制，系统调用和硬件特权级的概念出现了</li>
<li>多道程序系统：内存保护和并发的概念</li>
<li>现代操作系统：……</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-01-summary-a-dialogue-on-the-book/">
              
                  OSTEP第01章总结：A Dialogue on the Book
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这是全书开头的第一章，奠定了全书逗比的基调（雾）。这一章主要只是用来扯皮的，真正的介绍性内容在下一章。</p>
<p>本章讲述了一位叫“Professor”的教授和一位叫“Student”的学生的故事。</p>
<p>Professor指出，“Three Easy Pieces”这个题目是为了致敬费曼的“Six Easy Pieces”这本书。因为操作系统只有物理学的一半那么难，所以核心概念也只有物理学的一半那么多。（真的吗？）</p>
<p>我们将要讲授的3个核心概念是：虚拟化（virtualization），并发（concurrency）和持久化（persistence）。</p>
<p>我们将要学到OS如何工作，具体内容包括：</p>
<ul>
<li>OS如何决定下一个将在CPU上运行的是什么程序</li>
<li>如何在虚拟内存系统中处理内存过载</li>
<li>如何管理磁盘上的信息</li>
<li>如何建立一个可靠的分布式系统</li>
<li>等等</li>
</ul>
<p>Professor对学习者的建议：</p>
<ul>
<li>上课，听讲</li>
<li>每周结束时读这本书</li>
<li>考试之前再读一遍书（虽然可能我没有那么多的时间，我就没有）</li>
<li>做教授留的作业和项目</li>
</ul>
<p>Professor：“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣。”（荀子《儒效篇》）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-29-summary-lock-based-concurrent-data-structures/">
              
                  OSTEP第29章总结：Lock-Based Concurrent Data Structures
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-26
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章主要介绍了如何以锁为基础，将常见的数据结构改造为线程安全的。</p>
<ul>
<li>一种通用的解决方法</li>
<li>性能：缩放（scaling）问题</li>
<li>并发计数器</li>
<li>并发链表</li>
<li>并发队列</li>
<li>并发哈希表</li>
</ul>
<p>最后强调了几点经验教训：</p>
<ul>
<li>在控制流变化的时候不要忘记释放锁（见并发链表的错误实现）</li>
<li>提高并发性不等于提升性能（见交替上锁的链表）</li>
<li>在编写多线程应用时，正确性比效率更重要，需要避免过早优化（premature optimization）</li>
</ul>
<h2 id="一种通用的解决方法"><a class="markdownIt-Anchor" href="#一种通用的解决方法"></a> 一种通用的解决方法</h2>
<p>很容易想到，使常见的数据结构线程安全的最简单的方法，就是在对该数据结构执行任何操作之前都上锁，执行完之后再释放锁。</p>
<p>以计数器为例。一个普通的计数器的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在计数器上加入一个操作锁，此时程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">    Pthread_mutex_init(&amp;c-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> rc = c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现方法显然是简单且正确的。</p>
<h2 id="性能缩放scaling问题"><a class="markdownIt-Anchor" href="#性能缩放scaling问题"></a> 性能：缩放（scaling）问题</h2>
<p>上述简单粗暴的实现显然会降低并发性，因为有些操作完全是可以并行执行的（如多个<code>get</code>操作）。对于这一问题，给出一形式化的定义如下：</p>
<p><strong>完全缩放</strong>（perfect scaling）：对于一个线程安全的数据结构，如果需要访问它的线程数量小于系统中处理器的数量，且满足多个线程并发访问该数据结构的运行时间不多于只有单个线程访问该数据结构时的运行时间，则称该数据结构是完全缩放的。</p>
<p>实验结果表明，上述实现方法完全做不到完全缩放，多线程并发访问的时间随线程数量而线性增加（在线程数&lt;CPU数的前提下）。这是符合逻辑的。</p>
<h2 id="并发计数器"><a class="markdownIt-Anchor" href="#并发计数器"></a> 并发计数器</h2>
<p>我个人认为精确的计数器实现是很难（或者说不可能？）做到完全缩放的，因为这些操作本身已经足够简单，很难再有并行优化的余地。书中给出了一种不精确的计数器的实现，称为“sloppy counter”。</p>
<p>这一计数器的基本思想如下：</p>
<ul>
<li>每个CPU拥有一个本地计数器，除此之外，有一个全局计数器；每个计数器各有一个锁</li>
<li>当某个CPU上运行的线程需要执行<code>increment</code>操作时，获得本地计数器的锁，执行操作，并释放锁</li>
<li>当某个本地计数器的值达到阈值S时，则获得该计数器和全局计数器的锁，全局计数器+=本地计数器，本地计数器清零；释放锁</li>
<li>全局计数器中存放的是计数器的一个估计值，读取时需要先获得全局计数器的锁。可以通过获得全部锁来获得计数器当前的真实值，但这一操作显然是非缩放的</li>
</ul>
<p>下面是一个S=5，4个线程的执行示例：<br>
<img src="tracing-the-sloppy-counters.png" alt></p>
<p>可以看出，S的值越小，该实现方法越类似于直接加锁的实现（当S=1时基本退化为直接加锁的实现）；S的值越大，该方法的缩放性越强，性能越好，但全局计数器的值就会偏离真实值更远。</p>
<p><img src="scaling-sloppy-counters.png" alt="4个线程，4个CPU，分别increment一百万次，执行时间随S的变化"></p>
<p>下面给出一种简单的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> global; <span class="comment">// global count</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> glock; <span class="comment">// global lock</span></span><br><span class="line">    <span class="keyword">int</span> local[NUMCPUS]; <span class="comment">// local count (per cpu)</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS]; <span class="comment">// ... and locks</span></span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values</span></span><br><span class="line"><span class="comment">// of all local counts and global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    c-&gt;threshold = threshold;</span><br><span class="line">    c-&gt;global = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">        c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update: usually, just grab local lock and update local amount</span></span><br><span class="line"><span class="comment">// once local count has risen by ’threshold’, grab global</span></span><br><span class="line"><span class="comment">// lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu = threadID % NUMCPUS;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;llock[cpu]);</span><br><span class="line">    c-&gt;local[cpu] += amt; <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;local[cpu] &gt;= c-&gt;threshold) &#123; <span class="comment">// transfer to global</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[cpu];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[cpu] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;llock[cpu]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">return</span> val; <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发链表"><a class="markdownIt-Anchor" href="#并发链表"></a> 并发链表</h2>
<p>书中给出了一种错误的实现，在此不再摘录了。该错误的问题在于，如果获得锁之后未能成功进行相应操作，则直接返回，忘记释放锁了。我们可以从中得出如下教训：</p>
<ul>
<li>不要扩大锁覆盖的范围，只覆盖关键区就可以了</li>
<li>安排好代码的执行顺序，对于有多个出口点的代码，最好将出口点汇总在一起，这样不容易忘记释放锁；在具体实现的时候，可以记录返回值，并配合goto语句</li>
</ul>
<p>下面是正确的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> *L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronization not needed</span></span><br><span class="line">    <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是原先出错的位置，现在已移出上锁区域</span></span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// just lock critical section</span></span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出口点集合</span></span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">// now both success and failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表的缩放性"><a class="markdownIt-Anchor" href="#链表的缩放性"></a> 链表的缩放性</h3>
<p>显然上述实现并不具有完全缩放性。另一种想法是采用交替上锁（hand-over-hand locking）技术：为每个结点都初始化一个锁，需要访问结点时，则获取该结点对应的锁。这个想法虽然听起来很好，极大地增加了并发性，但在实际操作中效率很低，因为请求/释放锁的操作耗时太多。如果采取一种混合策略（如每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>个结点上一个锁），就可以在并发性和效率之间取得一种平衡。</p>
<h2 id="并发队列"><a class="markdownIt-Anchor" href="#并发队列"></a> 并发队列</h2>
<p>书中给出了一种比较巧妙的实现。一般来说，入队操作只会访问队头，出队操作只会访问队尾，因此可以对这两种操作分别建立一个锁，一个队头锁，一个队尾锁；在进行操作时分别上锁。</p>
<p>代码中的细节是，为了将两种操作分离开，在队列的头部增加了一个伪结点；所以出队的时候返回的是队头的下一个结点的值；然后删除队头，它原来的下一个结点成为队头，也成为伪结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">node_t</span> *tail;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> headLock;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> tailLock;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Init</span><span class="params">(<span class="keyword">queue_t</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;headLock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tailLock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = newHead-&gt;value;</span><br><span class="line">    q-&gt;head = newHead;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发哈希表"><a class="markdownIt-Anchor" href="#并发哈希表"></a> 并发哈希表</h2>
<p>并发哈希表的实现借用了上述并发链表的实现，这一实现是比较简化的。由于不同的槽对应的链表的操作是可以并行的（相当于每个槽对应一个锁），因此这一实现的并发性是比较高的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash_Init</span><span class="params">(<span class="keyword">hash_t</span> *H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123;</span><br><span class="line">        List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Lookup</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h2>
<p>没写。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-28-summary-locks/">
              
                  OSTEP第28章总结：Locks
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-18
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章主要介绍了锁的基础知识，以及各种锁的实现方法和评价标准：</p>
<ul>
<li>硬件支持
<ul>
<li>关中断</li>
<li>TS指令实现自旋锁</li>
<li>CS指令实现自旋锁</li>
<li>LL/SC指令实现自旋锁</li>
<li>FA指令实现无饥饿的自旋锁</li>
</ul>
</li>
<li>硬件和OS支持
<ul>
<li>从自旋锁到yield</li>
<li>使用队列和睡眠</li>
<li>Linux中的实际例子</li>
<li>两阶段锁</li>
</ul>
</li>
</ul>
<h2 id="锁的基本定义和用法"><a class="markdownIt-Anchor" href="#锁的基本定义和用法"></a> 锁的基本定义和用法</h2>
<p>锁是一个变量。在任意时刻，该变量中都存储着锁的状态：</p>
<ul>
<li>可获得（或者说释放，开锁的，说明没有线程持有该锁）</li>
<li>不可获得（未被释放，上锁的，说明有一个线程持有该锁，很可能处于关键区内）</li>
</ul>
<p>锁的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock_t mutex; // some globally-allocated lock &apos;mutex&apos;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + 1;  // 关键区</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p><code>lock()</code>的语义：</p>
<ul>
<li>尝试获得锁</li>
<li>如果该锁未被获得，则获得该锁，进入关键区，该线程成为锁的拥有者</li>
<li>如果该锁已被获得，则在锁被释放之前始终阻塞，防止多个线程同时进入关键区<br>
<code>unlock()</code>的语义：</li>
<li>释放线程当前持有的锁</li>
<li>如果还有其他线程在等待锁，则通知其中一个进程开始运行，获得锁，并进入关键区</li>
</ul>
<p>锁能够帮助程序员更多地获得对线程的控制权。</p>
<h2 id="锁的评价标准"><a class="markdownIt-Anchor" href="#锁的评价标准"></a> 锁的评价标准</h2>
<ol>
<li>基本要求：提供互斥访问功能</li>
<li>公平性：是否会出现线程饥饿的状况？</li>
<li>性能：不同场景下的时间开销</li>
<li>单线程获取并释放锁</li>
<li>多线程请求同一个锁</li>
<li>多CPU上的多线程请求同一个锁</li>
</ol>
<h2 id="锁的实现方法"><a class="markdownIt-Anchor" href="#锁的实现方法"></a> 锁的实现方法</h2>
<p>本章中给出了一种单纯用现有非特权指令（加载和存储）实现锁的方法，但是失败了。当然，其实这样是可以成功的（Dekker和Peterson算法），也做过一些研究，但是这些算法对硬件也有一些假设，而且人们已经发现，在硬件中提供一些支持会方便很多。所以就不赘述了。</p>
<h3 id="用硬件原语实现锁"><a class="markdownIt-Anchor" href="#用硬件原语实现锁"></a> 用硬件原语实现锁</h3>
<h4 id="关中断"><a class="markdownIt-Anchor" href="#关中断"></a> 关中断</h4>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void lock() &#123;</span><br><span class="line">	DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line">void unlock() &#123;</span><br><span class="line">	EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：简单</p>
<p>缺点：</p>
<ul>
<li>需要线程执行特权指令，可能被滥用，OS无法得到控制权</li>
<li>不适用于多处理器系统</li>
<li>关中断太久可能导致重要的中断请求被丢失</li>
<li>效率低，因为现代CPU开关中断的速度比较慢</li>
</ul>
<p>目前这一方法主要用于OS本身的原子性操作，因为这样就不存在滥用问题。</p>
<h4 id="使用tstest-and-set指令实现自旋锁"><a class="markdownIt-Anchor" href="#使用tstest-and-set指令实现自旋锁"></a> 使用TS（Test-And-Set）指令实现自旋锁</h4>
<p>TS指令原子地完成以下操作：</p>
<ul>
<li>读出某个地址处的值</li>
<li>将新的值写入该地址</li>
<li>返回旧值</li>
</ul>
<p>用代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int TestAndSet(int *old_ptr, int new) &#123;</span><br><span class="line">    int old = *old_ptr; // fetch old value at old_ptr</span><br><span class="line">    *old_ptr = new; // store &apos;new&apos; into old_ptr</span><br><span class="line">    return old; // return the old value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以利用TS指令实现自旋锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int flag;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void init(lock_t *lock) &#123;</span><br><span class="line">    // 0 indicates that lock is available, 1 that it is held</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)</span><br><span class="line">        ; // spin-wait (do nothing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理是：</p>
<ul>
<li><code>flag</code>变量表示锁是否被持有，0表示空闲</li>
<li>在<code>lock()</code>函数中，不断使用TS指令测试锁是否空闲，空闲则获得锁并将<code>flag</code>置为1；不空闲则自旋等待</li>
<li>在<code>unlock()</code>函数中，只需简单地将<code>flag</code>置为0</li>
</ul>
<h4 id="对自旋锁的评价"><a class="markdownIt-Anchor" href="#对自旋锁的评价"></a> 对自旋锁的评价</h4>
<ol>
<li>正确性：显然是正确的</li>
<li>公平性：无法保证，可能会导致饥饿</li>
<li>性能：</li>
<li>单CPU系统：性能很差</li>
<li>多CPU系统：还不错（如果线程的数量大致与CPU相等）</li>
</ol>
<h4 id="使用cscompare-and-swap指令实现自旋锁"><a class="markdownIt-Anchor" href="#使用cscompare-and-swap指令实现自旋锁"></a> 使用CS（Compare-And-Swap）指令实现自旋锁</h4>
<p>CS指令原子地完成以下操作：</p>
<ul>
<li>读出某个地址处的值</li>
<li>判断它是否与期望的值相等，如果相等，则更新该地址处的值为某给定的值</li>
<li>返回该地址处原有的值</li>
</ul>
<p>用代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CompareAndSwap(int *ptr, int expected, int new) &#123;</span><br><span class="line">	int actual = *ptr;</span><br><span class="line">	if (actual == expected)</span><br><span class="line">		*ptr = new;</span><br><span class="line">	return actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与TS指令类似，可以利用CS指令实现自旋锁（其他函数与TS指令的实现相同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">	while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)</span><br><span class="line">		; // spin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理也类似。</p>
<h4 id="用llload-linked和scstore-conditional指令实现自旋锁"><a class="markdownIt-Anchor" href="#用llload-linked和scstore-conditional指令实现自旋锁"></a> 用LL（Load-Linked）和SC（Store-Conditional）指令实现自旋锁</h4>
<p>这两个指令是MIPS架构下提供的。LL指令类似于普通的加载指令，把某个值从内存中加载到寄存器中；但它会标记这个地址，SC指令更新该地址处的值时，仅在上次LL过后该值还没有被修改过时才会成功。</p>
<p>用代码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LoadLinked(int *ptr) &#123;</span><br><span class="line">    return *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StoreConditional(int *ptr, int value) &#123;</span><br><span class="line">    if (no one has updated *ptr since the LoadLinked to this address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        return 1; // success!</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0; // failed to update</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        while (LoadLinked(&amp;lock-&gt;flag) == 1)</span><br><span class="line">            ; // spin until it&apos;s zero</span><br><span class="line">        if (StoreConditional(&amp;lock-&gt;flag, 1) == 1)</span><br><span class="line">            return; // if set-it-to-1 was a success: all done</span><br><span class="line">        // otherwise: try it all over again</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个线程同时在请求这个锁，则先执行SC指令的线程可以获得锁，另一个线程执行SC指令时就会返回0，需要重新进入请求状态。</p>
<h4 id="用fafetch-and-add指令实现标签锁ticket-lock"><a class="markdownIt-Anchor" href="#用fafetch-and-add指令实现标签锁ticket-lock"></a> 用FA（Fetch-And-Add）指令实现标签锁（ticket lock）</h4>
<p>FA指令原子地完成以下任务：</p>
<ul>
<li>读出某个地址处的值</li>
<li>将这个值+1</li>
<li>重新写回该地址处</li>
<li>返回原来的值</li>
</ul>
<p>用代码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int FetchAndAdd(int *ptr) &#123;</span><br><span class="line">	int old = *ptr;</span><br><span class="line">	*ptr = old + 1;</span><br><span class="line">	return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用该指令可以实现一个思路稍有不同的锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int ticket;</span><br><span class="line">    int turn;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void lock_init(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;ticket = 0;</span><br><span class="line">    lock-&gt;turn = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    int myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    while (lock-&gt;turn != myturn)</span><br><span class="line">        ; // spin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;turn = lock-&gt;turn + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ticket</code>变量表示曾经请求过锁的线程的个数，<code>turn</code>变量表示当前（应该）是第几个等待线程持有锁。<code>lock()</code>函数中，通过FA指令为本线程获得“排位”（<code>myturn</code>），并等待前面的线程执行完毕。<code>unlock()</code>函数中，只需简单地将<code>turn</code>变量+1（轮到下一个线程了）。</p>
<p>这个实现方法的优点是，不存在饥饿问题，请求同一个锁的线程按请求顺序获得锁。（但是这样会不会有死锁问题？？）</p>
<h3 id="用硬件原语和os的支持实现锁"><a class="markdownIt-Anchor" href="#用硬件原语和os的支持实现锁"></a> 用硬件原语和OS的支持实现锁</h3>
<h4 id="直接把自旋改为yield"><a class="markdownIt-Anchor" href="#直接把自旋改为yield"></a> 直接把自旋改为<code>yield</code></h4>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    flag = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock() &#123;</span><br><span class="line">    while (TestAndSet(&amp;flag, 1) == 1)</span><br><span class="line">        yield(); // give up the CPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock() &#123;</span><br><span class="line">    flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得不到锁的线程不再自旋，而是主动放弃控制权。虽然减少了自旋浪费的时间片，不过仍然耗费了一些切换上下文的时间。</p>
<h4 id="利用队列和睡眠实现锁"><a class="markdownIt-Anchor" href="#利用队列和睡眠实现锁"></a> 利用队列和睡眠实现锁</h4>
<p>现在改为由OS控制当前的锁被释放之后，哪一个线程能够获得锁。为此引入睡眠机制：</p>
<ul>
<li><code>park()</code>系统调用：将调用线程睡眠</li>
<li><code>unpark(ThreadID)</code>系统调用：唤醒某个进程</li>
</ul>
<p>下面是一个使用队列、TS指令、<code>yield</code>、自旋和睡眠机制的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int flag;</span><br><span class="line">    int guard;</span><br><span class="line">    queue_t *q;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void lock_init(lock_t *m) &#123;</span><br><span class="line">    m-&gt;flag = 0;</span><br><span class="line">    m-&gt;guard = 0;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *m) &#123;</span><br><span class="line">    while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span><br><span class="line">        ; //acquire guard lock by spinning</span><br><span class="line">    if (m-&gt;flag == 0) &#123;</span><br><span class="line">        m-&gt;flag = 1; // lock is acquired</span><br><span class="line">        m-&gt;guard = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        setpark();  // avoid wakeup/waiting race</span><br><span class="line">        m-&gt;guard = 0;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *m) &#123;</span><br><span class="line">    while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span><br><span class="line">        ; //acquire guard lock by spinning</span><br><span class="line">    if (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = 0; // let go of lock; no one wants it</span><br><span class="line">    else</span><br><span class="line">        unpark(queue_remove(m-&gt;q)); // hold lock (for next thread!)</span><br><span class="line">    m-&gt;guard = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该锁的内部嵌套了一个用TS指令实现的自旋锁，对应的变量是<code>guard</code>，保护的关键区是对锁的内部状态的修改和更新过程。</p>
<ul>
<li><code>lock()</code>函数：
<ul>
<li>首先尝试进入关键区</li>
<li>如果能获得锁，则离开关键区</li>
<li>如果不能获得锁，则把自己加入队列中，离开关键区，然后放弃CPU（注意，如果先放弃CPU，则guard永远不会变成0，别的进程就无法获得和释放锁了）</li>
</ul>
</li>
<li><code>unlock()</code>函数：
<ul>
<li>首先尝试进入关键区</li>
<li>如果等待队列为空，则直接放弃锁，并离开关键区</li>
<li>否则从队列中唤醒一个线程（注意，此时<code>flag</code>并不会被置为0，因为被唤醒的线程此时回到了<code>park()</code>执行完毕的地方，它已经离开了关键区，因此也不应该尝试把<code>flag</code>设为1；因此，我们直接把锁交给下一个线程，重甲不进行释放）</li>
</ul>
</li>
</ul>
<p>另一个可能存在的问题是，如果没有<code>setpark()</code>一句，且请求锁的线程在<code>park()</code>之前被打断，那么如果此时锁被释放了，重新被唤醒的请求线程会继续执行<code>park()</code>，并永远沉睡下去。<code>setpark()</code>可以解决这个问题：在调用它之后，如果线程在调用<code>park()</code>之前被打断，且其他的线程对它调用了<code>unpark()</code>，那么该线程随后对<code>park()</code>的调用会立即返回。</p>
<h4 id="一个实际的锁的实现"><a class="markdownIt-Anchor" href="#一个实际的锁的实现"></a> 一个实际的锁的实现</h4>
<p>这个实现利用了Linux中的两个函数：</p>
<ul>
<li><code>futex_wait(address, expected)</code>：如果address处的值与expected相等，则睡眠，否则返回</li>
<li><code>futex_wake(address)</code>：唤醒一个在该地址的队列中等待的线程</li>
</ul>
<p>这个实现中，一个整数（mutex）用于跟踪锁是否被持有（最高位）和等待该锁的线程数（其他所有位）。所以，如果mutex为负数，则锁被持有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void mutex_lock (int *mutex) &#123;</span><br><span class="line">	int v;</span><br><span class="line">	/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span><br><span class="line">	if (atomic_bit_test_set (mutex, 31) == 0)</span><br><span class="line">		return;</span><br><span class="line">	atomic_increment (mutex);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		if (atomic_bit_test_set (mutex, 31) == 0) &#123;</span><br><span class="line">			atomic_decrement (mutex);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		/* We have to wait now. First make sure the futex value</span><br><span class="line">		we are monitoring is truly negative (i.e. locked). */</span><br><span class="line">		v = *mutex;</span><br><span class="line">		if (v &gt;= 0)</span><br><span class="line">			continue;</span><br><span class="line">		futex_wait (mutex, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mutex_unlock (int *mutex) &#123;</span><br><span class="line">	/* Adding 0x80000000 to the counter results in 0 if and only if there are not other interested threads */</span><br><span class="line">	if (atomic_add_zero (mutex, 0x80000000))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* There are other threads waiting for this mutex,</span><br><span class="line">	wake one of them up. */</span><br><span class="line">	futex_wake (mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mutex_lock</code>函数：
<ul>
<li>如果该锁空闲，则返回</li>
<li>否则等待线程数+1，并开始循环</li>
<li>在每次循环中，如果发现该锁空闲，则获得该锁（使用的是TS指令），等待线程数-1，并返回</li>
<li>如果发现该锁不空闲，在等待之前重新进行一次检查，如果发现锁空闲则继续循环；否则开始睡眠</li>
</ul>
</li>
<li><code>mutex_unlock</code>函数：
<ul>
<li>将最高位置0的同时检查是否有其他线程在等待，如果没有，则直接返回</li>
<li>如果有，则唤醒一个等待中的线程</li>
</ul>
</li>
</ul>
<p>其中，在尝试睡眠的过程中，<code>futex_wait</code>函数的特性保证了“wakeup/waiting race”不会发生：首先读出<code>mutex</code>处的值，确保此时锁不空闲；即使此时被打断，<code>mutex</code>处的值被修改，<code>futex_wait</code>也会因为两个值不相等而返回，不会永远进入睡眠状态。</p>
<h4 id="两阶段锁"><a class="markdownIt-Anchor" href="#两阶段锁"></a> 两阶段锁</h4>
<p>这个锁的原理是混合了自旋锁和队列睡眠机制。好像没有什么好说的。</p>
<h2 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h2>
<p>没有做。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-27-summary-interlude-thread-api/">
              
                  OSTEP第27章总结：Interlude: Thread API
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-16
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章主要介绍了POSIX标准下的线程API，包括：</p>
<ul>
<li>创建线程</li>
<li>等待线程结束</li>
<li>创建和使用互斥锁</li>
<li>创建和使用条件变量</li>
</ul>
<h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">pthread_create( pthread_t * thread,</span><br><span class="line">		 const pthread_attr_t * attr,</span><br><span class="line">			   void * (*start_routine)(void*),</span><br><span class="line">               void * arg);</span><br></pre></td></tr></table></figure>
<p>4个参数的含义如下：</p>
<ul>
<li><code>thread</code>：指向<code>struct pthread_t</code>类型的变量的指针，我们需要这一变量用来控制线程，因此需要把它的指针传递过去进行初始化</li>
<li><code>attr</code>：指定线程的属性，如栈的大小和线程的调度优先级；属性是通过调用<code>pthread attr_init()</code>进行初始化的</li>
<li><code>start_routine</code>：指定线程运行的函数，它只有一个<code>void*</code>类型的参数，返回值也是<code>void*</code>类型</li>
<li><code>arg</code>：在进程执行的时候传递给函数的参数</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct __myarg_t &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125; myarg_t;</span><br><span class="line"></span><br><span class="line">void *mythread(void *arg) &#123;</span><br><span class="line">    myarg_t *m = (myarg_t *) arg;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, m-&gt;a, m-&gt;b);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[]) &#123;</span><br><span class="line">    pthread_t p;</span><br><span class="line">    int rc;</span><br><span class="line"></span><br><span class="line">    myarg_t args;</span><br><span class="line">    args.a = 10;</span><br><span class="line">    args.b = 20;</span><br><span class="line">    rc = pthread_create(&amp;p, NULL, mythread, &amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="等待线程结束"><a class="markdownIt-Anchor" href="#等待线程结束"></a> 等待线程结束</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **value_ptr);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>thread</code>：等待哪一个线程结束；这个变量是通过调用<code>pthread_create()</code>来初始化的</li>
<li><code>value_ptr</code>：指向将会得到的返回值的指针</li>
</ul>
<h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef struct __myarg_t &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125; myarg_t;</span><br><span class="line"></span><br><span class="line">typedef struct __myret_t &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125; myret_t;</span><br><span class="line"></span><br><span class="line">void *mythread(void *arg) &#123;</span><br><span class="line">    myarg_t *m = (myarg_t *) arg;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, m-&gt;a, m-&gt;b);</span><br><span class="line">    myret_t *r = Malloc(sizeof(myret_t));</span><br><span class="line">    r-&gt;x = 1;</span><br><span class="line">    r-&gt;y = 2;</span><br><span class="line">    return (void *) r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[]) &#123;</span><br><span class="line">    pthread_t p;</span><br><span class="line">    myret_t *m;</span><br><span class="line"></span><br><span class="line">    myarg_t args = &#123;10, 20&#125;;</span><br><span class="line">    Pthread_create(&amp;p, NULL, mythread, &amp;args);</span><br><span class="line">    Pthread_join(p, (void **) &amp;m);</span><br><span class="line">    printf(&quot;returned %d %d\n&quot;, m-&gt;x, m-&gt;y);</span><br><span class="line">    free(m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，创建了一个线程，传入了一些参数，在该线程返回之后，得到了它的返回值。当然，我们并不是总需要把参数和返回值包装成<code>struct</code>的。值得注意的是，不要返回指向在线程的调用栈上分配的内存的指针（而改为使用<code>malloc()</code>在堆上分配内存），因为在线程返回之后，它的栈就会被回收。</p>
<p>当然，在这个例子中，调用<code>pthread_create()</code>之后立刻调用<code>pthread_join()</code>的做法是没有什么意义的，因为函数调用也可以达到相同的效果。</p>
<p>并不是所有多线程程序都会用到<code>join</code>函数。有些多线程服务器可能会创建一些工作线程，然后让主线程不断接收请求并传递给其他线程。</p>
<h2 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h2>
<p>最基本的一对上锁/解锁API是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>
<p>较高级的API包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在无法获得锁时返回错误</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line">// 在试图获得锁而不成功一段时间后返回错误</span><br><span class="line">int pthread_mutex_timedlock(pthread_mutex_t *mutex,</span><br><span class="line">                            struct timespec *abs_timeout);</span><br></pre></td></tr></table></figure>
<h3 id="使用示例-2"><a class="markdownIt-Anchor" href="#使用示例-2"></a> 使用示例</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + 1; // or whatever your critical section is</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>上述代码的含义是：</p>
<ul>
<li>如果调用<code>pthread_mutex_lock()</code>时没有其他线程持有锁，则该线程可以获得锁并进入关键区</li>
<li>如果有其他的线程正在持有锁，则试图获得锁的进程将会阻塞，直到其他进程将锁释放，该进程获得锁为止</li>
</ul>
<p>注意几点：</p>
<ol>
<li>只有拥有锁的线程才能调用<code>pthread_mutex_unlock()</code></li>
<li>需要检查上锁和开锁时可能发生的错误，最简单的方法是assert返回值</li>
<li>除了静态初始化方法（使用<code>PTHREAD_MUTEX_INITIALIZER</code>进行默认初始化）</li>
</ol>
<p>修改为动态初始化的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock;</span><br><span class="line">int rc = pthread_mutex_init(&amp;lock, NULL);</span><br><span class="line">assert(rc == 0); // always check success!</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + 1; // or whatever your critical section is</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line">pthread_mutex_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</span><br><span class="line">int pthread_cond_signal(pthread_cond_t *cond);</span><br></pre></td></tr></table></figure>
<p>需要在线程之间传递信号的时候（比如某个线程等待另一个完成），条件变量是很重要的。条件变量需要一个与它相关的锁。调用上述函数的前提是持有该锁。</p>
<p><code>pthread_cond_wait()</code>函数的功能是，将调用该函数的线程睡眠，直到其他线程发出信号为止。通常的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">Pthread_mutex_lock(&amp;lock);</span><br><span class="line">while (ready == 0)</span><br><span class="line">Pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>上述代码在初始化之后，对<code>ready</code>变量进行检查，如果不满足要求，则继续睡眠，等待再次被唤醒。</p>
<p>在其他线程中唤醒该线程的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;lock);</span><br><span class="line">ready = 1;</span><br><span class="line">Pthread_cond_signal(&amp;cond);</span><br><span class="line">Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<ul>
<li>在发出信号和修改全局变量<code>ready</code>时，为了防止竞争条件，我们总是确保已经获得了锁</li>
<li><code>wait</code>函数的第二个参数是锁，但<code>signal</code>函数的参数没有锁。这是因为<code>wait</code>函数在使线程进入睡眠的同时也释放了锁（否则其他线程就不可能获得锁并唤醒该线程）；在被唤醒之前，wait函数会重新获得锁</li>
<li>等待的线程会通过<code>while</code>循环检查条件是否满足，而不是<code>if</code>语句；这样做是最安全的，因为有些<code>pthread</code>的实现会使得条件未满足时线程仍被唤醒，因此唤醒只是一种提示</li>
</ul>
<p>作者指出，最好不要自己尝试造轮子来实现条件变量的功能。</p>
<h2 id="线程api使用指南"><a class="markdownIt-Anchor" href="#线程api使用指南"></a> 线程API使用指南</h2>
<ul>
<li>简化操作：线程之间复杂的互动会导致bug。</li>
<li>减少线程之间的互动</li>
<li>记得初始化锁和条件变量</li>
<li>检查返回值</li>
<li>小心传参的方式，不要返回指向线程栈上的指针</li>
<li>每个线程都拥有自己的栈，只有堆中的变量才是全局的</li>
<li>一定要通过条件变量在线程之间传递信号</li>
<li>多看手册</li>
</ul>
<h2 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h2>
<p>仍然没做，这次的作业比较复杂，似乎要用到valgrind，还要配置一些环境。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
              <p class="current">
                  1 / 2
              </p>
              
                  <a class="next" rel="next" href="/tags/OSTEP/page/2/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
