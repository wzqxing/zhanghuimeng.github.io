<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Tag: OS | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css'><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
    <script>
        window.subData= { title:'标签 : OS'}
    </script>




  <section class="post-list">
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-23-summary/">
              
                  《操作系统》第23讲：“I/O子系统”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-24
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<ul>
<li>常见设备I/O接口</li>
<li>进程的I/O方法</li>
<li>CPU与设备之间的I/O方法
<ul>
<li>连接方法</li>
<li>传输方法</li>
<li>通知方法</li>
</ul>
</li>
<li>I/O请求生存周期</li>
<li>一类具体的I/O设备：磁盘
<ul>
<li>磁盘的工作机制和传输时间</li>
<li>磁盘调度算法</li>
<li>磁盘缓存</li>
</ul>
</li>
</ul>
<h3 id="常见设备io接口"><a class="markdownIt-Anchor" href="#常见设备io接口"></a> 常见设备I/O接口</h3>
<p>常见的接口分为三类。</p>
<table>
<thead>
<tr>
<th>设备接口类型</th>
<th>例子</th>
<th>访问特征</th>
<th>I/O命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符设备</td>
<td>键盘、鼠标、串口</td>
<td>以字节为单位顺序访问</td>
<td>文件访问接口</td>
</tr>
<tr>
<td>块设备</td>
<td>磁盘驱动器、磁带驱动器、光驱</td>
<td>均匀的数据块访问</td>
<td>文件系统接口、内存映射</td>
</tr>
<tr>
<td>网络设备</td>
<td>以太网、无线、蓝牙</td>
<td>格式化报文交换</td>
<td>网络报文、网络协议</td>
</tr>
</tbody>
</table>
<h3 id="进程的io方法"><a class="markdownIt-Anchor" href="#进程的io方法"></a> 进程的I/O方法</h3>
<p>从进程的角度来看，I/O方法分为三种类型。</p>
<table>
<thead>
<tr>
<th>I/O类型</th>
<th>特点</th>
<th>读写方法</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞I/O</td>
<td>Wait</td>
<td>读写时，进程将进入等待状态，直到设备完成数据处理</td>
<td><img src="block-io.png" alt></td>
</tr>
<tr>
<td>非阻塞I/O</td>
<td>Don’t Wait</td>
<td>读写时立即从read或write系统调用返回，返回值为成功传输字节数；可能不成功</td>
<td><img src="unblock-io.png" alt></td>
</tr>
<tr>
<td>异步I/O</td>
<td>Tell Me Later</td>
<td>读写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区/处理数据并通知用户</td>
<td><img src="async-io.png" alt></td>
</tr>
</tbody>
</table>
<h3 id="cpu与设备之间的io方法"><a class="markdownIt-Anchor" href="#cpu与设备之间的io方法"></a> CPU与设备之间的I/O方法</h3>
<p><img src="kernel-io-structure.png" alt="内核I/O结构"></p>
<p>内核通过I/O子系统控制各种硬件。</p>
<h4 id="连接方法"><a class="markdownIt-Anchor" href="#连接方法"></a> 连接方法</h4>
<p>一般来说，北桥芯片连接的是高速I/O设备，如内存和显卡；南桥芯片连接的是普通I/O设备，如磁盘和网络。</p>
<p>设备上的设备控制器是CPU和I/O设备间的接口，它向CPU提供特殊指令和寄存器，也就是CPU用来控制I/O设备的I/O地址，分为两种：</p>
<ul>
<li>I/O指令：通过I/O端口号访问设备寄存器</li>
<li>内存映射I/O：设备的寄存器/存储空间被映射到内存物理地址空间中，通过内存load/store指令完成I/O操作</li>
</ul>
<h4 id="传输方法"><a class="markdownIt-Anchor" href="#传输方法"></a> 传输方法</h4>
<p>CPU与设备控制器之间的数据传输分为两种方式：</p>
<ul>
<li>程序控制I/O（PIO，Programmed I/O）
<ul>
<li>通过CPU的in/out或者load/store传输所有数据（内存映射）
<ul>
<li>特点：</li>
<li>硬件简单，编程容易</li>
<li>消耗的CPU时间和数据量成正比</li>
</ul>
</li>
<li>适用于简单的、小型的设备I/O</li>
</ul>
</li>
<li>直接内存访问（DMA）
<ul>
<li>设备控制器可直接访问系统总线</li>
<li>控制器直接与内存互相传输数据</li>
<li>特点：
<ul>
<li>设备传输数据不影响CPU</li>
<li>需要CPU参与设置（这是必然的）</li>
<li>适用于高吞吐量I/O</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="通过dma读取磁盘数据的例子"><a class="markdownIt-Anchor" href="#通过dma读取磁盘数据的例子"></a> 通过DMA读取磁盘数据的例子</h5>
<p><img src="dma-read-disk-data.png" alt></p>
<p>具体步骤如下：</p>
<ol>
<li>设备驱动收到读取磁盘数据到内存地址X的请求</li>
<li>设备驱动控制磁盘控制器从磁盘读取数据</li>
<li>磁盘控制器初始化DMA传送</li>
<li>磁盘控制器传送数据到DMA控制器</li>
<li>DMA控制器传送C字节数据到内存地址X</li>
<li>DMA控制器完成数据传送后，产生中断请求，通知CPU传送完成</li>
</ol>
<h4 id="通知方法"><a class="markdownIt-Anchor" href="#通知方法"></a> 通知方法</h4>
<p>设备通知CPU（I/O操作完成时间、I/O操作是否发生错误、设备状态等）主要分为两种方式：</p>
<ul>
<li>CPU主动轮询</li>
<li>设备中断</li>
</ul>
<h5 id="轮询"><a class="markdownIt-Anchor" href="#轮询"></a> 轮询</h5>
<p>处理流程：</p>
<ul>
<li>I/O设备在特定的状态寄存器中放置状态和错误信息</li>
<li>操作系统定期检测状态寄存器</li>
</ul>
<p>特点：</p>
<ul>
<li>简单</li>
<li>I/O操作频繁或不可预测时，开销大和延时长</li>
</ul>
<h5 id="设备中断"><a class="markdownIt-Anchor" href="#设备中断"></a> 设备中断</h5>
<p>处理流程：</p>
<ul>
<li>CPU在I/O之前设置任务参数</li>
<li>CPU在发出I/O请求后，继续执行其他任务</li>
<li>I/O设备处理I/O请求</li>
<li>I/O设备处理完成时，触发CPU中断请求</li>
<li>CPU接收中断，分发到相应中断处理例程</li>
</ul>
<p><img src="device-interrupt-io.png" alt="设备中断I/O处理流程图示"></p>
<p>特点：</p>
<ul>
<li>处理不可预测事件效果好（CPU在每两条指令中间处理一次中断请求）</li>
<li>开销相对较高</li>
</ul>
<h3 id="io请求生存周期"><a class="markdownIt-Anchor" href="#io请求生存周期"></a> I/O请求生存周期</h3>
<p><img src="io-request-life-cycle.png" alt="I/O请求生存周期"></p>
<p>显然，这是异步I/O请求。</p>
<h3 id="一类具体的io设备磁盘"><a class="markdownIt-Anchor" href="#一类具体的io设备磁盘"></a> 一类具体的I/O设备：磁盘</h3>
<h4 id="磁盘的工作机制和传输时间"><a class="markdownIt-Anchor" href="#磁盘的工作机制和传输时间"></a> 磁盘的工作机制和传输时间</h4>
<p><img src="disk-structure.png" alt="磁盘的组成"></p>
<p>磁盘的主要组成部分包括：</p>
<ul>
<li>磁盘轴</li>
<li>若干个盘片（围绕磁盘轴旋转）
<ul>
<li>磁道</li>
<li>扇区</li>
</ul>
</li>
<li>磁头（上面有读写头）</li>
</ul>
<p>在读取或写入时，磁头必须被定位在期望的磁道，并从所期望的柱面和扇区开始读写。在这一过程中，花时间最长的是磁头的移动。我们称<strong>寻道时间</strong>为定位到期望的磁道所花费的时间，<strong>旋转延迟</strong>为从0扇区开始处到达目的地花费的时间。一般来说，<strong>平均旋转延迟时间</strong> 是磁盘旋转一周时间的一半。</p>
<p>磁盘I/O传输一般分为以下5个步骤：</p>
<ol>
<li>等待设备可用</li>
<li>等待通道（PIO或DMA通道）可用</li>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ol>
<p>后四个步骤被称为“设备忙”状态，所占用的时间一般认为是传输时间，公式为</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a = T_s+ \frac{1}{2r} + \frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>公式各个部分的含义：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：传输时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：寻道时间（和磁头移动距离有关，花费的时间最多）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>：旋转延迟（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>=旋转一周的时间）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b}{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>：传输时间
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>：传输的比特数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>：磁道上的比特数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>：磁盘转速</li>
</ul>
</li>
</ul>
<p>显然，最需要优化的是寻道时间。磁盘调度算法解决的就是这一问题。</p>
<h4 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h4>
<p>磁盘调度算法的目的：通过优化磁盘访问请求顺序来提高磁盘访问性能</p>
<p>进行磁盘调度的原因：</p>
<ul>
<li>寻道时间是磁盘访问最耗时的部分</li>
<li>同时会有多个在同一磁盘上的I/O请求（所以可以调整顺序）</li>
<li>随机处理磁盘访问请求的性能表现很差</li>
</ul>
<p>下列算法中使用的例子：</p>
<ul>
<li>磁盘访问序列：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li>
<li>初始磁头位置：<code>53</code></li>
</ul>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>做法</th>
<th>特征</th>
<th>例子</th>
<th>移动距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>先进先出（FIFO）算法</td>
<td>按顺序处理请求</td>
<td>能够保证公平；性能较差</td>
<td><code>53-&gt;98-&gt;183-&gt;37-&gt;122-&gt;14-&gt;124-&gt;65-&gt;67</code></td>
<td>640</td>
</tr>
<tr>
<td>最短服务时间优先（SSTF）算法</td>
<td>选择从磁臂当前位置需要移动最少的I/O请求</td>
<td>很不公平</td>
<td><code>53-&gt;65-&gt;67-&gt;14-&gt;98-&gt;122-&gt;124-&gt;183</code></td>
<td>236</td>
</tr>
<tr>
<td>扫描（SCAN）算法</td>
<td>磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的<strong>磁道</strong>；然后调换方向</td>
<td>判断简单；不公平，偏好中间位置磁道</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;65-&gt;67-&gt;98-&gt;122-&gt;124-&gt;183-&gt;199</code></td>
<td>236</td>
</tr>
<tr>
<td>循环扫描（C-SCAN）算法</td>
<td>对SCAN算法的改进：限制仅在一个方向上扫描；当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</td>
<td>比SCAN算法更公平</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;199-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>386</td>
</tr>
<tr>
<td>C-LOOK算法</td>
<td>对C-SCAN算法的改进：不走到磁盘的头，而是只走到最远的请求</td>
<td>同样能保证公平性</td>
<td><code>53-&gt;37-&gt;14-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>326</td>
</tr>
<tr>
<td>N步扫描（N-step-SCAN）算法</td>
<td>将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列；再用扫描算法处理每个队列</td>
<td>防止磁头粘着现象</td>
<td><code>53-&gt;37-&gt;183-&gt;98-&gt;14-&gt;124-&gt;122-&gt;67-&gt;65</code></td>
<td>500</td>
</tr>
<tr>
<td>双队列扫描（FSCAN）算法</td>
<td>将磁盘请求队列分成两个子队列，交替使用扫描算法处理每一个队列；处理一个队列时，所有新生成的磁盘I/O请求都被放入另一队列中</td>
<td>比N步扫描更简单</td>
<td><code>53-&gt;37-&gt;183-&gt;122-&gt;98-&gt;67-&gt;65-&gt;14-&gt;124</code></td>
<td>441</td>
</tr>
</tbody>
</table>
<p>一些细节：</p>
<ul>
<li>认为SCAN、C-SCAN、C-LOOK和N步扫描算法都是先向低编号移动</li>
<li>N步扫描算法的N为3，使用的是C-LOOK扫描方法</li>
<li>FSCAN算法中假设后四个请求位于下一个队列，使用的也是C-LOOK扫描算法</li>
<li>课件上没有指出C-SCAN算法返回时到底是返回到另外一端还是“另外一端最靠边的请求”。鉴于有C-LOOK的改进，我就认为C-SCAN傻得直接走到另一端了。类似地，我也认为C-LOOK算法反转时只会走到另一端最远的请求，而不是另一端。</li>
</ul>
<h4 id="磁盘缓存"><a class="markdownIt-Anchor" href="#磁盘缓存"></a> 磁盘缓存</h4>
<p><strong>缓存</strong>是数据传输双方访问速度差异较大时，引入的速度匹配中间层。<strong>磁盘缓存</strong> 是磁盘扇区在内存中的缓冲区。磁盘缓存的调度算法很类似虚拟存储调度算法（不过倒了过来，虚拟存储是把内存缓存到磁盘，磁盘缓存是把磁盘缓存到内存==）。</p>
<h5 id="单缓存与双缓存"><a class="markdownIt-Anchor" href="#单缓存与双缓存"></a> 单缓存与双缓存</h5>
<p>根据缓冲区个数分类：</p>
<ul>
<li>单缓存（Single Buffer Cache）：I/O设备写入时，CPU不能进行读操作（类似生产者-消费者问题）</li>
<li>双缓存（Double Buffer Cache）：有两个缓冲区，可以同时分别读写；结束之后可以交换</li>
</ul>
<h5 id="访问频率置换frequency-based-replacement算法"><a class="markdownIt-Anchor" href="#访问频率置换frequency-based-replacement算法"></a> 访问频率置换（Frequency-based Replacement）算法</h5>
<p>问题：在一段密集磁盘访问后，LFU算法的引用计数变化无法反映当前的引用情况</p>
<p>算法思路：</p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li>
</ul>
<p><img src="fbr-stack.png" alt="访问频率置换算法的特殊栈"></p>
<p>算法具体步骤：</p>
<ul>
<li>把LRU算法中的特殊栈分成3部分，并为每个缓存块增加一个引用计数
<ul>
<li>新区域（New Section）：栈顶</li>
<li>中间区域（Middle Section）</li>
<li>旧区域（Old Section）：栈底</li>
</ul>
</li>
<li>每次访问时：
<ul>
<li>栈中被访问的缓存块移到栈顶（这个是LRU的原始要求）；如果该块原来在新区域，引用计数不变（这个是符合LRU的）；否则引用计数+1
<ul>
<li>在新区域中引用计数不变的目的是避免密集访问对引用计数产生不利影响</li>
<li>在中间区域和旧区域中引用计数+1是为了使用LFU算法</li>
</ul>
</li>
<li>未缓存数据块读入后放在栈顶，引用计数为1</li>
<li>在旧区域中引用计数最小的缓存块被置换（这是LFU的要求；但并不会在整个栈里找计数最小的）
<ul>
<li>中间区域的定义是为了避免新读入的缓存块在第一次离开新区域时马上被置换，有一个过渡期</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：懒得想了，不写了</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/10-1-quiz.md" target="_blank" rel="noopener">lec23 IO设备 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/10-1-spoc-discussion.md" target="_blank" rel="noopener">IO设备(lec 23) spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>字符设备包括（）</strong></p>
<ul>
<li><strong>键盘</strong></li>
<li><strong>鼠标</strong></li>
<li><strong>并口</strong></li>
<li><strong>串口</strong></li>
</ul>
<p>都是。因为它们的访问特征都是以字节为单位顺序访问。</p>
<hr>
<p><strong>块设备包括（）</strong></p>
<ul>
<li><strong>硬盘</strong></li>
<li><strong>软盘</strong></li>
<li><strong>光盘</strong></li>
<li><strong>U盘</strong></li>
</ul>
<p>都是。因为它们的访问特征都是均匀的数据块访问。</p>
<hr>
<p><strong>网络设备包括（）</strong></p>
<ul>
<li><strong>以太网卡</strong></li>
<li><strong>wifi网卡</strong></li>
<li><strong>蓝牙设备</strong></li>
<li>网盘设备</li>
</ul>
<p>网络设备的访问特征是格式化报文交换。而网盘在模拟实现上应该算块设备。</p>
<hr>
<p><strong>关于CPU与设备的通信方式包括（）</strong></p>
<ul>
<li><strong>轮询</strong></li>
<li><strong>设备中断</strong></li>
<li><strong>DMA</strong></li>
<li>PIPE</li>
</ul>
<p>PIPE是用于进程间通信的。虽然DMA听起来是直接把数据写入到内存，不过还是需要CPU参与设置的。</p>
<hr>
<p><strong>关于IO数据传输的阐述正确的是（）</strong></p>
<ul>
<li><strong>程序控制I/O(PIO, Programmed I/O)通过CPU的in/out或者load/store传输所有数据</strong></li>
<li><strong>DMA设备控制器可直接访问系统总线并直接与内存互相传输数据</strong></li>
<li>DMA机制适合字符设备</li>
<li>PIO机制适合块设备</li>
</ul>
<p>DMA机制适合块设备，PIO机制适合简单，低速的字符设备等。最后两个选项反了。</p>
<hr>
<p><strong>常用移臂调度算法包括（）</strong></p>
<ul>
<li><strong>先来先服务（FIFO）算法</strong></li>
<li><strong>最短寻道时间优先（SSTF）算法</strong></li>
<li><strong>电梯调度（SCAN）算法</strong></li>
<li><strong>单向扫描（C-SCAN）算法</strong></li>
</ul>
<p>都对。除此之外还有CLOOK和N-step-SCAN算法。</p>
<hr>
<p><strong>在设备管理子系统中，引入缓冲区的目的主要有()</strong></p>
<ul>
<li><strong>缓和CPU与I/O设备间速度不匹配的矛盾</strong></li>
<li><strong>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</strong></li>
<li><strong>解决基本数据单元大小（即数据粒度）不匹配的问题</strong></li>
<li><strong>提高CPU和I/O设备之间的并行性</strong></li>
</ul>
<p>都对。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>字符设备的特点是什么？</strong></p>
<p>以字节为单位顺序访问。</p>
<hr>
<p><strong>块设备的特点是什么？</strong></p>
<p>以均匀的数据块为单位随机访问。</p>
<hr>
<p><strong>网络设备的特点是什么？</strong></p>
<p>以格式化报文为单位的复杂交互访问。</p>
<hr>
<p><strong>阻塞I/O、非阻塞I/O和异步I/O这三种I/O方式有什么区别？</strong></p>
<ul>
<li>阻塞I/O：数据读写操作后，进程将进入等待状态，直到完成操作时返回；</li>
<li>非阻塞I/O：数据读写操作后，进程将立即返回；</li>
<li>异步I/O：数据读写操作后，进程将立即返回；内核在完成操作时通知进程；</li>
</ul>
<p>区别：</p>
<ul>
<li>进程发出操作命令后，进程是否等待；</li>
<li>操作结果反馈方式</li>
</ul>
<hr>
<p><strong>请描述I/O请求到完成的整个执行过程。</strong></p>
<p>CPU通过总线与设备相连；CPU通过主动的I/O端口和映射内存读写操作与设备进行信息交互；设备通过中断请求来响应CPU的操作；在CPU的控制下，DMA可直接在设备接口与内存间的数据传输。</p>
<ol>
<li>进程通过系统调用发送对设备的抽象操作命令</li>
<li>内核把抽象的设备操作命令转换成具体的设备I/O端口和映射内存读写序列，并在设备驱动中实施读写操作</li>
<li>当这个读写序列较长时，CPU会控制DMA进行内存与设备接口的直接数据传送</li>
<li>设备在收到控制序列后，执行操作动作，并在完成时向CPU发出中断请求</li>
<li>CPU通过中断服务例程响应设备的中断请求，并进行后续处理，直到系统调用返回，从而完成整个I/O操作过程。</li>
</ol>
<hr>
<p><strong>IO数据传输有哪几种？</strong></p>
<ul>
<li>程序控制I/O：
<ul>
<li>CPU通过显式的IO指令，如x86的in, out等传输数据</li>
<li>memory读写方式，即把device的寄存器，内存等映射到物理内存中</li>
</ul>
</li>
<li>直接内存访问（DMA）：在CPU的控制下，DMA控制器直接在内存与设备接口间传输数据</li>
</ul>
<hr>
<p><strong>轮询方式的特点是什么？</strong></p>
<ul>
<li>简单</li>
<li>I/O操作频繁或不可预测时，开销大和延时长</li>
</ul>
<hr>
<p><strong>中断方式的特点是什么？</strong></p>
<ul>
<li>处理不可预测事件效果好</li>
<li>开销相对较高</li>
</ul>
<hr>
<p><strong>DMA方式的特点是什么？</strong></p>
<ul>
<li>直接在内存与设备接口间进行数据传输</li>
<li>适合高速和简单的数据传输</li>
<li>CPU的开销小</li>
</ul>
<hr>
<p><strong>请简要阐述磁盘的工作过程。</strong></p>
<ul>
<li>磁头移动到期望的磁道</li>
<li>盘片旋转定位到期望的柱面和扇区</li>
<li>开始读写</li>
</ul>
<hr>
<p><strong>请描述磁盘I/O操作时间组成。</strong></p>
<p>磁盘I/O操作一般分成五个步骤：</p>
<ul>
<li>等待设备可用</li>
<li>等待通道（PIO或DMA通道）可用</li>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ul>
<p>其中后四个步骤被称为“设备忙”状态，一般认为是传输时间，公式为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a = T_s+ \frac{1}{2r} + \frac{b}{rN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<hr>
<p><strong>请说明磁盘调度算法的评价指标。</strong></p>
<ul>
<li>总的I/O时间开销（显然）</li>
<li>公平性</li>
<li>平均等待时间（似乎这对磁盘调度不是很重要）</li>
</ul>
<hr>
<p><strong>请描述FIFO、SSTF、SCAN、CSCAN、LOOK、C-LOOK、N-step-SCAN和FSCAN等磁盘调度算法的工作原理。</strong></p>
<p>磁盘调度算法就是优化磁盘数据块的访问顺序。</p>
<ul>
<li>先进先出（FIFO）算法：按请求顺序访问</li>
<li>最短寻道时间优先（SSTF）算法：从当前位置找当前最近的访问数据块位置</li>
<li>扫描（SCAN）算法：保持磁头移动方向到最远处，并顺序访问需要访问的数据块</li>
<li>循环扫描（C-SCAN）算法：只在一个方向上移动时访问数据的SCAN算法</li>
<li>LOOK算法：保持磁头移动方向到已有的最后一个请求，并顺序访问需要访问的数据块</li>
<li>C-LOOK算法：只在一个方向上移动时访问数据的LOOK算法；</li>
<li>N步扫描（N-step-SCAN）算法：
<ol>
<li>将磁盘请求队列分成长度为N的子队列</li>
<li>按FIFO算法依次处理所有子队列</li>
<li>按扫描算法处理每个队列</li>
</ol>
</li>
<li>双队列扫描（FSCAN）算法：
<ol>
<li>把磁盘I/O请求分成两个队列，交替使用扫描算法处理一个队列</li>
<li>新生成的磁盘I/O请求放入另一队列中</li>
</ol>
</li>
</ul>
<hr>
<p><strong>磁盘缓存的作用是什么？</strong></p>
<p>磁盘缓存是磁盘扇区在内存中的缓存区。作用是通过缓存访问，减少磁盘访问。</p>
<hr>
<p><strong>请描述单缓存(Single Buffer Cache)的工作原理。</strong></p>
<p>只有一个缓存区，用户进程和I/O设备只能交替访问缓存区。</p>
<hr>
<p><strong>请描述双缓存(Double Buffer Cache)的工作原理。</strong></p>
<p>设置两个缓存区，任何时刻用户进程和I/O设备可同时访问不同的缓存区。</p>
<hr>
<p><strong>请描述访问频率置换算法(Frequency-based Replacement)的基本原理。</strong></p>
<p>思路：</p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>短周期内采用LRU，长周期内采用LFU</li>
</ul>
<p>做法：</p>
<ul>
<li>把栈分成三个区域：新区域（栈顶）、中间区域、旧区域（栈底）</li>
<li>新区域中数据块的引用，不计数</li>
<li>中间区域和旧区域中数据块的引用，引用计数加</li>
<li>淘汰只在旧区域中找引用计数最小的数据块</li>
</ul>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>请以键盘输入、到标准输出设备stdout的printf输出、串口输出、磁盘文件复制为例，描述ucore操作系统I/O从请求到完成的整个执行过程，并分析I/O过程的时间开销。</strong></p>
<p>没做，现在还没做完lab8，感觉实在过于麻烦了。</p>
<hr>
<p><strong>完成磁盘访问与磁盘寻道算法的作业，然后实现CSCAN、LOOK、C-LOOK、FSCAN等磁盘调度算法中的一个。具体帮助和要求信息请看<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-disks.pdf" target="_blank" rel="noopener">Chapter 37: Hard Disk Drives</a>、<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.md" target="_blank" rel="noopener">disksim指导信息</a>和<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.py" target="_blank" rel="noopener">disksim参考代码</a></strong></p>
<p>看起来不难，但现在做起来意义不大，所以不做了。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2014-final-exam-analysis/">
              
                  《操作系统》2014年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="一-信号12分"><a class="markdownIt-Anchor" href="#一-信号12分"></a> 一 信号（12分）</h2>
<p>在Linux/Unix中，一个用户从shell中执行了一个运行时间较长且不知何时能够结束的程序，Linux/UNIX可以让用户根据个人需求随时通过敲击Ctrl-C组合键来终止这个程序的执行。请回答如下问题。要求设计应该具有通用性，列出的设计实现不超过6点，每点不超过 4行。问题的执行流程描述不超过8行。</p>
<ol>
<li>如果要在ucore中实现Linux/UNIX同样的功能，请问应该如何修改ucore来支持此功能？</li>
<li>uCore的shell也是一个程序，我们希望避免这个shell在执行中被用户敲入的Ctrl-C所终止，请问在保证1的要求前提下，如何修改ucore和shell来支持此功能？</li>
<li>说明在你的设计下，shell和某一可被终止程序在执行过程中，用户敲击Ctrl-C后，uCore和shell的执行流程。</li>
</ol>
<hr>
<ol>
<li>很显然，应该通过信号机制来实现相应的功能。我觉得可以修改编译器，使得编译时为每个程序自动加入信号处理例程，进程启动时将相应的信号处理函数注册到内核，发生SIGKILL（Ctrl+C组合）时将信号分发给进程，进程执行信号处理例程并退出。</li>
<li>shell可以在程序中屏蔽Ctrl+C信号</li>
<li>ucore和shell的执行流程：</li>
<li>ucore接收到键盘中断</li>
<li>ucore识别出按下的键是Ctrl+C，发送信号</li>
<li>中断返回时检查到进程有未处理的信号，转入信号处理（这一步我们大概没有细讲……总之就是进入了正在执行的程序的信号处理例程）</li>
<li>信号处理例程使进程退出</li>
<li>shell继续wait</li>
</ol>
<h2 id="二-ipc机制"><a class="markdownIt-Anchor" href="#二-ipc机制"></a> 二 IPC机制</h2>
<p>在具备了执行用户态进程的能力之后，uCore要为这些进程提供的一个重要服务，是用户进程之间的消息传递机制（Inter-Process Communication，简写为 IPC）。现在，我们要为uCore实现以下两个系统调用，以实现一种同步的IPC机制（暂不考虑超时等功能）：</p>
<ul>
<li><code>int sys_send_event(int pid, int event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 该消息的目标进程的进程号；</li>
</ul>
</li>
</ul>
</li>
<li>event – 消息内容，用一个整型表示。</li>
<li>返回值：消息成功发送时，返回0；否则，返回相应的错误代码。</li>
<li><code>int sys_recv_event(int *pid, int *event);</code>
<ul>
<li>参数：
<ul>
<li>pid - 函数返回时，<code>*pid</code>保存发出消息的进程的进程号，可以为NULL；</li>
<li>event – 函数返回时，<code>*event</code>保存消息内容，可以为NULL。</li>
</ul>
</li>
<li>返回值：消息成功接收时，返回 0；否则，返回相应的错误代码。</li>
</ul>
</li>
</ul>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>以下是一个基于上述IPC机制求质数的用户程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int total = 1000;</span><br><span class="line"></span><br><span class="line">void primeproc(void)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0, this, num, pid = 0;</span><br><span class="line">top:</span><br><span class="line">    recv_event(NULL, &amp;this);</span><br><span class="line">    cprintf(&quot;%d is a primer.\n&quot;, this);</span><br><span class="line"></span><br><span class="line">    while (recv_event(NULL, &amp;num) == 0) &#123;</span><br><span class="line">        if ((num % this) == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            if (index + 1 == total) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((pid = fork()) == 0) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                goto top;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pid &lt; 0) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (send_event(pid, num) != 0) &#123;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    cprintf(&quot;[%04d] %d quit.\n&quot;, getpid(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, pid;</span><br><span class="line">    unsigned int time = gettime_msec();</span><br><span class="line">    if ((pid = fork()) == 0) &#123;</span><br><span class="line">        primeproc();</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pid &gt; 0);</span><br><span class="line"></span><br><span class="line">    for (i = 2;; i++) &#123;</span><br><span class="line">        if (send_event(pid, i) != 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(&quot;use %d msecs.\n&quot;, gettime_msec() - time);</span><br><span class="line">    cprintf(&quot;primer3 pass.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简述这个程序是如何判断并输出前五个质数的。</p>
<hr>
<p>主进程（称为P1）首先fork出一个子进程，子进程开始执行<code>primeproc()</code>函数（称为P2）。主进程从<code>i = 2</code>开始不断向P1发送内容为<code>i</code>的自然数，直到发送不成功为止。</p>
<p>P1进程不断循环：</p>
<ul>
<li>接收P0发送的消息，将这个整数保存下来，作为质数<code>this</code></li>
<li>不断接收P0发送的消息，保存为<code>num</code>；如果接收不成功，退出并打印信息</li>
<li>若<code>num</code>可以被<code>this</code>整除，显然<code>num</code>不是质数，跳出此次循环，继续等待消息</li>
</ul>
<p>。。。不会了</p>
<p>学长答案说：</p>
<blockquote>
<p>每个进程是一个输出一个素数，负责检验传进来的数是否整除这个素数，如果都过了在新建一个进程</p>
</blockquote>
<p>我觉得从理论上来说确实是这样，但是不够详细。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>给出一种基于等待队列的上述IPC机制的实现方案。</p>
<hr>
<p>在我的妄想中这个是这样实现的：</p>
<ul>
<li>建立两个等待队列：发送等待队列和接收等待队列</li>
<li>当进程发送消息时，检查目标进程是否在接收等待队列中，如果不在，则加入发送等待队列；如果在，则将目标进程取出，发送对应的消息</li>
<li>当进程接收消息时，检查发送等待队列中是否有进程发送的目标是它，如果有，则将该进程取出，接收对应的消息；否则加入接收等待队列</li>
</ul>
<h2 id="三-ucore中的信号量实现10分"><a class="markdownIt-Anchor" href="#三-ucore中的信号量实现10分"></a> 三 ucore中的信号量实现（10分）</h2>
<p>在uCore中，信号量的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line"> int value;</span><br><span class="line"> wait_queue_t wait_queue;</span><br><span class="line">&#125; semaphore_t;</span><br><span class="line"></span><br><span class="line">// __up 函数是信号量 V 操作的具体实现函数</span><br><span class="line">static __noinline void __up(semaphore_t *sem, uint32_t wait_state) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        wait_t *wait;</span><br><span class="line">        if ((wait=wait_queue_first(&amp;(sem-&gt;wait_queue)))==NULL) &#123;</span><br><span class="line">            ________;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> （1）</h3>
<p>补全程序中的空行________。</p>
<hr>
<p><code>sem-&gt;value++;</code></p>
<h3 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> （2）</h3>
<p>信号量的value值&gt;0时，表示________的数量；value值&lt;0时，表示________的数量。</p>
<hr>
<ol>
<li>剩余资源</li>
<li>等待队列中进程</li>
</ol>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p><code>local_intr_save</code>和<code>local_intr_restore</code>这两个函数的功能分别是什么？为什么要调用这两个函数？</p>
<hr>
<p>关中断和开中断；为了保证执行过程的原子性。</p>
<h2 id="四-学生看mooc同步问题15分"><a class="markdownIt-Anchor" href="#四-学生看mooc同步问题15分"></a> 四 学生看MOOC同步问题（15分）</h2>
<p>假设一个MOOC网站有1、2、3三种不同的课程视频可由学生选择学习，网站播放课程视频的规则为：</p>
<ol>
<li>任一时刻最多只能播放一种课程视频，正在播放的课程视频是自动循环播放的，最后一个学生主动离开时结束当前课程视频的播放；</li>
<li>选择当前正在播放的课程视频的学生可立即进入播放页面，允许同时有多位选择同一种课程视频的学生观看，同时观看的学生数量不受限制；</li>
<li>等待观看其它课程视频的学生按到达顺序排队，当一种新的课程视频开始放映时，所有等待观看该课程视频的学生可依次序进入播放页面同时观看。</li>
</ol>
<p>用一个进程代表一个学生，要求：用信号量的P、V操作实现上述规则，并给出信号量的<br>
定义和初始值。</p>
<hr>
<p>我认为这个问题有点像读者-写者问题。下面是我的实现方法（虽然我也觉得有一些问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#define COURSE 3</span><br><span class="line"></span><br><span class="line">semaphore mutex; // 保护互斥变量的锁</span><br><span class="line">semaphore wait[COURSE];  // 等待观看视频的学生队列</span><br><span class="line">int count[COURSE];  // 共享变量：等待/正在观看某视频的学生数量</span><br><span class="line">int cur;  // 当前正在播放的视频</span><br><span class="line"></span><br><span class="line">/* INITIALIZATION */</span><br><span class="line">void initialize() &#123;</span><br><span class="line">    mutex = new semaphore(1);</span><br><span class="line">    cur = -1;</span><br><span class="line">    for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">        wait[i] = new semaphore(0);</span><br><span class="line">        count[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Student Thread */</span><br><span class="line">void Student(int choice) &#123;</span><br><span class="line">    // 尝试开始观看</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]++;  // 更新等待人数</span><br><span class="line">    if (cur != choice) &#123;</span><br><span class="line">        if (cur &gt; 0) &#123;  // 当前播放的视频不符合要求，在期望视频的等待队列上睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">            wait[choice].P();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cur = choice;  // 当前未播放视频，直接睡眠</span><br><span class="line">            mutex.V();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        mutex.V();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Start to watch</span><br><span class="line"></span><br><span class="line">    // End watching</span><br><span class="line">    mutex.P();</span><br><span class="line">    count[choice]--;  // 更新等待人数</span><br><span class="line">    if (count[choice] &gt; 0) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count[choice]; i++) // 唤醒所有准备观看此视频的学生</span><br><span class="line">            wait[choice].V();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cur = -1;  // 寻找下一个播放的视频</span><br><span class="line">        for (int i = 0; i &lt; COURSE; i++) &#123;</span><br><span class="line">            if (count[i] &gt; 0) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                for (int j = 0; j &lt; count[i]; j++)</span><br><span class="line">                    wait[i].V();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学长的实现是这样的，说实话，我也不是很明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">avaid=1</span><br><span class="line">A=0,B=0,C=0</span><br><span class="line">waitA=waitB=waitC=0;</span><br><span class="line"></span><br><span class="line">观看:</span><br><span class="line">waitA+=1;</span><br><span class="line">P(avaid)</span><br><span class="line">if (countA+countB+countC==0)</span><br><span class="line"> V(A);</span><br><span class="line">V(avaid)</span><br><span class="line">P(A);</span><br><span class="line">waitA-=1;</span><br><span class="line">P(avaid)</span><br><span class="line">countA+=1;</span><br><span class="line">V(avaid)</span><br><span class="line">V(A);</span><br><span class="line"></span><br><span class="line">看完:</span><br><span class="line">P(avaid)</span><br><span class="line">countA-=1;</span><br><span class="line">if (countA==0) &#123;</span><br><span class="line"> V(avaid)</span><br><span class="line"> P(A);</span><br><span class="line"> if (waitB&gt;0) V(B);</span><br><span class="line"> else if (waitC&gt;0)  V(C);</span><br><span class="line">&#125; else</span><br><span class="line">V(avaid)</span><br></pre></td></tr></table></figure>
<h2 id="五-stride调度算法12分"><a class="markdownIt-Anchor" href="#五-stride调度算法12分"></a> 五 Stride调度算法（12分）</h2>
<p>在lab6中，我们实现了Stride Scheduling调度算法，并声称它对“进程的调度次数正比于其优先级”。对于优先级为2、3、5、7的4个进程，选取210为MAX_STRIDE，则：</p>
<ol>
<li>简要描述Stride Scheduling调度算法。</li>
<li>四个进程的步长分别为：<strong><strong><strong><strong>、</strong></strong></strong></strong>、<strong><strong><strong><strong>、</strong></strong></strong></strong>。</li>
<li>假设四个进程的初始stride值均为0，证明：总有一个时刻，四个进程的stride值都是210，且此时四个进程被调度的次数正比于其优先级。</li>
</ol>
<hr>
<p>Stride调度算法：</p>
<ul>
<li>每个进程有一个priority（优先级），pass和stride</li>
<li>stride = BigStride / priority</li>
<li>每次调度时选择pass值最小的进程，更新该进程的pass：pass += stride</li>
</ul>
<p>步长分别为105、70、42和30。</p>
<p>下列模拟过程假设在进程的pass值相等时，选择进程编号最小的执行。</p>
<p><img src="stride-sheet.png" alt="进程执行顺序表"></p>
<p><img src="stride-pass-fig.png" alt="各进程的Pass值变化过程"></p>
<p>此时，A被调度了2次，B被调度了3次，C被调度了5次，D被调度了7次，恰好与优先级成正比。之所以会这么规整，主要还是因为BigStride的值能够正好被各个优先级的值整除。</p>
<h2 id="六-银行家算法12分"><a class="markdownIt-Anchor" href="#六-银行家算法12分"></a> 六 银行家算法（12分）</h2>
<p>死锁是操作系统中资源共享时面临的一个难题。请回答下列与死锁相关的问题。</p>
<h3 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> （1）</h3>
<p>设系统中有下述解决死锁的方法：</p>
<ol>
<li>银行家算法；</li>
<li>检测死锁，终止处于死锁状态的进程，释放该进程占有的资源；</li>
<li>资源预分配。<br>
简述哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进？请按“并发性”从大到小对上述三种办法进行排序。</li>
</ol>
<hr>
<p>排序：2 &gt; 1 &gt; 3</p>
<p>原因：</p>
<ol>
<li>银行家算法每满足一个资源请求时都会进行安全状态检查。因为安全状态中实际上包含了一部分不会发生死锁的状态，所以它会拒绝一些本来可以接受的请求，所以降低了一点并发性。</li>
<li>显然在这种做法下所有进程都可以无等待地推进，直到真的出现了死锁再进行处理。</li>
<li>直觉上来说，资源预分配的并发性比银行家算法更低，因为银行家算法至少保留了一些动态性能，而资源预分配完全牺牲了动态性。</li>
</ol>
<h3 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> （2）</h3>
<p>假设一个使用银行家算法的系统，当前有5个进程P0, P1, P2, P3, P4，系统中有三类资源A、B、C，假设在某时刻有如下状态：</p>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Max矩阵：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Available向量：[1, 4, 0]</p>
<p>请问当前系统是否处于安全状态？如果系统中的可利用资源为（0, 6, 2），系统是否安全？如果系统处在安全状态，请给出安全序列；如果系统处在非安全状态，请简要说明原因。</p>
<hr>
<p>首先计算Need矩阵：Need = Max - Allocation</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>然后进行安全状态检测：</p>
<ol>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5] = [2, 7, 5]，Finish[P2] = true</li>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [2, 7, 8]，Finish[P0] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 0, 0] = [3, 7, 8]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [3, 7, 10]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [3, 7, 11]，Finish[P4] = true</li>
<li>发现系统处于安全状态。</li>
</ol>
<p>如果将Available向量修改为[0, 6, 2]，重新进行安全状态检测：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 3] = [0, 6, 5]，Finish[P0] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 0, 2] = [0, 6, 7]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1] = [0, 6, 5]，Finish[P4] = true</li>
<li>此时找不到满足条件的进程了，因此系统处于不安全状态。</li>
</ol>
<h2 id="七-sfs文件系统12分"><a class="markdownIt-Anchor" href="#七-sfs文件系统12分"></a> 七 SFS文件系统（12分）</h2>
<p>uCore实现了一个简单的文件系统Simple FS，假设该文件系统现已经装载到一个硬盘中（disk0），该硬盘的大小为20M，目前有三个文件A.txt，B.txt和C.txt存放在该硬盘中，三个文件的大小分别是48K，1M和4M。</p>
<h3 id="1-4"><a class="markdownIt-Anchor" href="#1-4"></a> （1）</h3>
<p>简要描述SFS文件系统中文件数据的组织结构（即：SFS文件的数据的存放位置组织方式）。</p>
<hr>
<p>以下答案来自<a href="https://github.com/chyyuu/os_course_exercise_library/blob/master/9/846.md" target="_blank" rel="noopener">os_course_exercise_library</a>，总之这个仓库让我感觉十分惊诧。</p>
<blockquote>
<p>一个superblock维护基本信息（1’），<br>
多个freemap（数量由分区大小确定，1’），<br>
一个根目录inode（1’）；<br>
目录和文件均由一个inode和具体数据块组成，其中inode包含文件的基本属性、12个直接索引和一级/二级索引表的块地址（1’），<br>
目录的数据块中存放（文件名 、inode地址）的数组（1’），<br>
文件的数据块中存放文件的具体内容（1’）。</p>
</blockquote>
<p>呃，有标答了哦。不过，要是我自己来回答，会这样说：</p>
<p><img src="disk-structure.png" alt="硬盘上按顺序排列着4类数据"></p>
<p>……然后就懒得说了，反正我还没做完Lab8，标答比我能总结出来的东西还是要强的。</p>
<h3 id="2-4"><a class="markdownIt-Anchor" href="#2-4"></a> （2）</h3>
<p>请根据Simple FS的设计实现情况，画出该文件系统当前在disk0上的布局情况，需要给出相应结构的名称和起始块号。</p>
<hr>
<p>答案来源同上。</p>
<blockquote>
<p>（除了0、1、2以外，其它块地址均可变，言之有理即可） （2分）<br>
0 superblock<br>
1 根目录inode<br>
2 freemap（640K，只需要1块）<br>
3 根目录的数据块（包含A.txt、B.txt、C.txt的inode的地址） （1分）<br>
4 A.txt的inode（包含12个直接索引块的地址）<br>
5-16 A.txt的数据块 （2分）<br>
17 B.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
18-29 B.txt的直接索引数据<br>
30 B.txt的一级间接索引（包含244个数据块地址）<br>
31-274 B.txt的一级间接索引块 （1分）<br>
275 C.txt的inode（包含12个直接索引块和1个一级间接索引）<br>
276-287 C.txt的一级间接索引块<br>
288 C.txt的一级间接索引（包含1012个数据块地址）<br>
289-1300 C.txt的一级间接索引块</p>
</blockquote>
<p>这个硬盘的块大小是4KB（虽然不知道为什么），因此整个硬盘共有5120块，因此freemap的大小应该为5Kbit。第0块是superblock，第1块是根目录inode，第2块是freemap，用1块就够了。后面就开始链式存储具体的文件和目录内容。</p>
<ul>
<li>3：根目录的数据块</li>
<li>4：A的inode。因为A的大小为48KB，因此12个直接索引块恰好能够装下，不需要一级索引。</li>
<li>5-16：A的数据块</li>
<li>17：B的inode。因为B的大小为1M，所以需要12个直接索引、1个一级索引块和244个间接索引。</li>
<li>18-29：B的直接索引数据块</li>
<li>30：B的一级索引块</li>
<li>31-274：B的间接索引数据块</li>
<li>275：C的inode。因为C的大小为4M，所以需要12个直接索引、1个一级索引块和1012个间接索引。</li>
<li>276-287：C的直接索引数据块</li>
<li>288：C的一级索引块</li>
<li>289-1300：C的间接索引数据块</li>
</ul>
<h2 id="八-vfs文件系统12分"><a class="markdownIt-Anchor" href="#八-vfs文件系统12分"></a> 八 VFS文件系统（12分）</h2>
<p>uCore的文件管理主要由以下四个部分组成：通用文件系统访问接口层，文件系统抽象层(VFS)，具体文件系统层以及外设接口层，其中VFS层的作用是用来管理不同的文件系统并向上提供一致的接口给内核其他部分访问。在ucore中我们已经实现了一个具体的文件系统：Simple FS，并将该文件系统装载到了disk0上，假设ucore又实现了一个文件系统FAT32，并将这个新的文件系统装载到了disk1上。</p>
<h3 id="1-5"><a class="markdownIt-Anchor" href="#1-5"></a> （1）</h3>
<p>请简单描述一下如何修改VFS层的数据结构使其可以有效的管理上述已安装的具体文件系统。涉及VFS层的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;                                                   </span><br><span class="line">    bool readable;                                         </span><br><span class="line">    bool writable;   </span><br><span class="line">    int fd;                                                     </span><br><span class="line">    off_t pos;                                               </span><br><span class="line">    struct inode *node;                             </span><br><span class="line">    atomic_t open_count;                           </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">    union &#123;                                                                 </span><br><span class="line">        struct device __device_info;                   </span><br><span class="line">        struct sfs_inode __sfs_inode_info;       </span><br><span class="line">    &#125; in_info;  /* info */</span><br><span class="line">    enum &#123;</span><br><span class="line">        inode_type_device_info = 0x1234,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;  /* info */                                   </span><br><span class="line">    atomic_t ref_count;</span><br><span class="line">    atomic_t open_count;                               </span><br><span class="line">    struct fs *in_fs;                                     </span><br><span class="line">    const struct inode_ops *in_ops;                     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct fs &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct sfs_fs __sfs_info;                                     </span><br><span class="line">    &#125; fs_info; /* info */</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type; /* info */</span><br><span class="line"></span><br><span class="line">    int (*fs_sync)(struct fs *fs);                                                   </span><br><span class="line">    struct inode *(*fs_get_root)(struct fs *fs);     </span><br><span class="line">    int (*fs_unmount)(struct fs *fs);                                     </span><br><span class="line">    void (*fs_cleanup)(struct fs *fs);                                   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inode_ops &#123;</span><br><span class="line">    unsigned long vop_magic;</span><br><span class="line">    int (*vop_open)(struct inode *node, uint32_t open_flags);</span><br><span class="line">    int (*vop_close)(struct inode *node);</span><br><span class="line">    int (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_create)(struct inode *node, const char *name,</span><br><span class="line">    bool excl, struct inode **node_store);</span><br><span class="line">    int (*vop_lookup)(struct inode *node, char *path,</span><br><span class="line">    struct inode **node_store);</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>对VFS必要的修改并不多，原因很简单：这是<strong>V</strong>FS。需要在以下位置添加必要信息：</p>
<ul>
<li>在<code>inode.in_info</code>对应的匿名union中添加<code>struct fat32_inode __fat32_inode_info;</code></li>
<li>在<code>inode.in_type</code>对应的匿名<code>enum</code>中添加<code>inode_type_fat32_inode_info,</code></li>
<li>在<code>fs.fs_info</code>对应的匿名<code>union</code>中添加<code>struct fat32_fs __fat32_info;</code></li>
<li>在<code>fs.fs_type</code>对应的匿名<code>enum</code>中添加<code>fs_type_fat32_info,</code></li>
</ul>
<h3 id="3-2"><a class="markdownIt-Anchor" href="#3-2"></a> （3）</h3>
<p>两个具体文件系统均已实现了对数据文件的4种基本操作。现在有某个用户态进程执行了一个<code>copy(source_path, dest_path, ...)</code>函数，该函数是把disk1根目录下的一个文件A.txt拷贝到了disk0的根目录下（不用考虑文件的大小），请结合ucore中对数据文件的操作流程描述一下这个函数的执行过程。</p>
<hr>
<p>以下内容来自学长答案。</p>
<ol>
<li>根据源文件目录调用<code>vop_lookup</code>查找文件的inode，这将调用FAT32的查找实现</li>
<li>根据目的文件路径调用<code>vop_lookup</code>查找文件的inode，这将调用SFS的查找实现</li>
<li>判断合法性</li>
<li>可能需要创建文件</li>
<li>open文件</li>
<li>建立buffer，对A调用<code>vop_read</code>，对B调用<code>vop_write</code></li>
<li>关闭文件</li>
</ol>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-ucore-lab-4-report/">
              
                  《操作系统》ucore实验四“内核线程管理”报告
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h2>
<ul>
<li>了解内核线程创建/执行的管理过程</li>
<li>了解内核线程的切换和基本调度过程</li>
</ul>
<h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<p>实验2/3完成了物理和虚拟内存管理，这给创建内核线程（ 内核线程是一种特殊的进程） 打下了提供内存管理的基础。当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（ 这里用线程或进程表示） “感到”它们各自拥有“自己”的CPU。</p>
<p>本次实验将首先接触的是内核线程的管理。内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li>内核线程只运行在内核态</li>
<li>用户进程会在在用户态和内核态交替运行</li>
<li>所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间</li>
<li>而用户进程需要维护各自的用户内存空间</li>
</ul>
<p>相关原理介绍可看附录B：【原理】进程/线程的属性与特征解析。</p>
<h3 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h3>
<p>本实验依赖实验1/2/3。请把你做的实验1/2/3的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。</p>
<hr>
<ul>
<li>Lab1：
<ul>
<li><code>kdebug.c:print_stackframe</code></li>
<li><code>trap.c:idt_init</code></li>
<li><code>trap.c:trap_dispatch</code></li>
</ul>
</li>
<li>Lab2：
<ul>
<li><code>default_pmm.c:default_init</code></li>
<li><code>default_pmm.c:default_init_memmap</code></li>
<li><code>default_pmm.c:default_alloc_pages</code></li>
<li><code>default_pmm.c:default_free_pages</code></li>
<li><code>pmm.c:get_pte</code></li>
<li><code>pmm.c:page_remove_pte</code></li>
</ul>
</li>
<li>Lab3：
<ul>
<li><code>vmm.c:do_pgfault</code></li>
<li><code>swap_fifo.c:__fifo_map_swappable</code></li>
<li><code>swap_fifo.c:__fifo_swap_out_victim</code></li>
</ul>
</li>
</ul>
<h3 id="练习1分配并初始化一个进程控制块需要编码"><a class="markdownIt-Anchor" href="#练习1分配并初始化一个进程控制块需要编码"></a> 练习1：分配并初始化一个进程控制块（需要编码）</h3>
<p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p>
<blockquote>
<p>【提示】在alloc_proc函数的实现中，需要初始化的proc_struct结构中的成员变量至少包括：state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。</p>
</blockquote>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>请说明<code>proc_struct</code>中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</li>
</ul>
<hr>
<h4 id="11-具体实现"><a class="markdownIt-Anchor" href="#11-具体实现"></a> 1.1 具体实现</h4>
<p>注释中给出了以下域的说明，其中有些是不需要在这个函数中进行分配的：</p>
<ul>
<li><code>enum proc_state state</code>：表示进程状态，在此函数中应赋值为<code>PROC_UNINIT</code>，表示该进程的初始化尚未完成（对进程状态的修改在<code>do_fork</code>函数的最后，通过调用<code>sched.c:wakeup_proc</code>函数完成）</li>
<li><code>int pid</code>：初始赋值为-1，表示尚未分配（<code>pid</code>在<code>do_fork</code>函数中通过调用<code>get_pid</code>进行分配）</li>
<li><code>int runs</code>：已运行次数，此处赋值为0</li>
<li><code>uintptr_t kstack</code>：内核堆栈起始地址，此时堆栈尚未分配，因此置为0；实际在<code>do_fork</code>函数中通过调用<code>setup_kstack</code>进行分配</li>
<li><code>volatile bool need_resched</code>：当前进程是否需要调度；初始化为不需要（0）</li>
<li><code>struct proc_struct *parent</code>：当前进程的父进程，初始化为<code>NULL</code>；在<code>do_fork</code>中初始化为调用<code>do_fork</code>的当前进程</li>
<li><code>struct mm_struct *mm</code>：内存管理，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_mm</code>进行初始化（虽然实际上直接使用了内核的mm，因为是内核线程）</li>
<li><code>struct context context</code>：在Lab5中发现context需要清零，但在此处似乎不初始化也能正常运行；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>struct trapframe *tf</code>：当前的中断帧，初始化为<code>NULL</code>；在<code>do_fork</code>中通过调用<code>copy_thread</code>函数进行初始化</li>
<li><code>uintptr_t cr3</code>：当前进程的页表基地址；直接初始化为kernel的页表基地址<code>boot_cr3</code></li>
<li><code>uint32_t flags</code>：当前进程属性，因为是初始化，所以置为0了</li>
<li><code>char name[PROC_NAME_LEN + 1]</code>：进程的名称，此处初始化似乎不是很重要，不过还是清零了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// alloc_proc - alloc a proc_struct and init all fields of proc_struct</span><br><span class="line">static struct proc_struct *</span><br><span class="line">alloc_proc(void) &#123;</span><br><span class="line">    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));</span><br><span class="line">    if (proc != NULL) &#123;</span><br><span class="line">    //LAB4:EXERCISE1 YOUR CODE</span><br><span class="line">    	proc-&gt;state = PROC_UNINIT;  // 正在创建和初始化状态中</span><br><span class="line">    	proc-&gt;pid = -1;  // 参考了答案：未初始化的进程id为-1</span><br><span class="line">    	proc-&gt;runs = 0;  // 还没有运行过</span><br><span class="line">    	proc-&gt;kstack = 0;  // 参考了答案：初始化内核堆栈似乎是在do_fork()中进行的？</span><br><span class="line">    	proc-&gt;need_resched = 0;  // 初始化为不需要调度</span><br><span class="line">    	proc-&gt;parent = NULL;</span><br><span class="line">    	proc-&gt;mm = NULL;  // 之后也不会分配，因为都是内核态线程，所以直接使用内核的mm</span><br><span class="line">    	memset(&amp;(proc-&gt;context), 0, sizeof(struct context));  // 在LAB5中发现，忘了清零context了</span><br><span class="line">    	// proc-&gt;tf = kmalloc(sizeof(struct trapframe));  // tf似乎不需要在此处设置</span><br><span class="line">    	proc-&gt;cr3 = boot_cr3;  // 参考了答案：内核态线程不需要分配新的页表地址；这对于正确执行是必需的</span><br><span class="line">    	proc-&gt;flags = 0;  // 参考了答案：标志位置为0</span><br><span class="line">    	memset(proc-&gt;name, 0, PROC_NAME_LEN);  // 参考了答案：将进程名清零，不过不是必需的</span><br><span class="line">    &#125;</span><br><span class="line">    return proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-context和trapframe的含义和用途"><a class="markdownIt-Anchor" href="#12-context和trapframe的含义和用途"></a> 1.2 <code>context</code>和<code>trapframe</code>的含义和用途</h4>
<p>实验指导书中指出：</p>
<ul>
<li><code>context</code>：进程的上下文，用于进程切换（参见<code>switch.S</code>）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用<code>context</code>保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用<code>context</code>进行上下文切换的函数是<code>kern/process/switch.S:switch_to</code></li>
<li><code>tf</code>：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时<code>tf</code>总是能够指向当前的<code>trapframe</code>，uCore 在内核栈上维护了<code>tf</code>的链，可以参考<code>trap.c::trap</code>函数做进一步的了解。</li>
</ul>
<p>经过阅读代码，我认为，<code>switch_to</code>的主要工作是把被切换的进程的各个通用寄存器（eip、esp、ebx、ecx、edx、esi、edi、ebp，但不包括段寄存器，因为kernel进程使用的段是相同的）保存到进程的<code>context</code>结构中，然后加载即将开始运行的进程的<code>context</code>结构中保存的通用寄存器。而<code>trapframe</code>就是我们在Lab1中已经了解的中断保存现场。对于内核线程，<code>trapframe</code>的意义似乎并不大，因为不需要进行用户空间到内核空间的切换。</p>
<hr>
<p>今天我的某个叫wenj的同学指出了一个很有趣的问题，这使得我重新翻出了实验报告：<code>context</code>和<code>trapframe</code>中为何都存储了EIP？这两种结构的功能是否重复了？翻了翻实验指导书，发现其实这个问题已经有比较明确的解答了：<code>trapframe</code>一般来说是用户态切换到内核态用的，而<code>context</code>是内核态自己切换上下文用的（因为特权级不变，所以不需要存储页表基地址、段寄存器等内容）；不过用户态跳转到内核态的时候也需要保存<code>context</code>中的通用寄存器，因为<code>trapframe</code>不存通用寄存器。</p>
<p>以及，lab4中构建进程的过程是这样的：</p>
<ul>
<li>“硬”构造出第一个内核线程idleproc</li>
<li>调用<code>do_fork</code>函数，fork idleproc，生成initproc</li>
</ul>
<p>事实上initproc返回时会假装自己是通过系统调用<code>do_fork</code>生成的，所以返回过程会比较复杂：</p>
<blockquote>
<p>uCore会执行进程切换，让initproc执行。在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>，这样，当执行<code>switch_to</code>函数并返回后，initproc将执行其实际上的执行入口地址forkret。而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行，具体代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line"># restore registers from stack</span><br><span class="line">popal</span><br><span class="line"># restore %ds and %es</span><br><span class="line">popl %es</span><br><span class="line">popl %ds</span><br><span class="line"># get rid of the trap number and error code</span><br><span class="line">addl $0x8, %esp</span><br><span class="line">iret</span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line"># set stack to this new process&apos;s trapframe</span><br><span class="line">movl 4(%esp), %esp //把esp指向当前进程的中断帧</span><br><span class="line">jmp __trapret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，forkrets函数首先把esp指向当前进程的中断帧，从_trapret开始执行到iret前，esp指向了current-&gt;tf.tf_eip，而如果此时执行的是initproc，则current-&gt;tf.tf_eip=kernel_thread_entry，initproc-&gt;tf.tf_cs = KERNEL_CS，所以当执行完iret后，就开始在内核中执行kernel_thread_entry函数了，而initproc-&gt;tf.tf_regs.reg_ebx = init_main，所以在kernl_thread_entry中执行“call %ebx”后，就开始执行initproc的主体了。Initprocde的主体函数很简单就是输出一段字符串，然后就返回到kernel_tread_entry函数，并进一步调用do_exit执行退出操作了。本来do_exit应该完成一些资源回收工作等，但这些不是实验四涉及的，而是由后续的实验来完成。至此，实验四中的主要工作描述完毕。</p>
</blockquote>
<h3 id="练习2为新创建的内核线程分配资源需要编码"><a class="markdownIt-Anchor" href="#练习2为新创建的内核线程分配资源需要编码"></a> 练习2：为新创建的内核线程分配资源（需要编码）</h3>
<p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号<br>
请在实验报告中简要说明你的设计实现过程。请回答如下问题：</li>
<li>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</li>
</ul>
<hr>
<h4 id="21-具体代码实现"><a class="markdownIt-Anchor" href="#21-具体代码实现"></a> 2.1 具体代码实现</h4>
<p>函数的大致执行步骤与题目中列出的相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) &#123;</span><br><span class="line">    int ret = -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    //    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    if (proc == NULL) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;  // 参考了答案</span><br><span class="line">    //    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">    if (setup_kstack(proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    //    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">    // CLONE_VM表示分享；实际上因为都在内核态所以什么都没做，只是assert NULL了</span><br><span class="line">    if (copy_mm(clone_flags, proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">    	goto bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    //    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">    copy_thread(proc, stack, tf);</span><br><span class="line">    //    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">    // 参考了答案：关中断的原因是，进程号要求唯一性，此操作需要为原子操作，防止被打断而重复添加</span><br><span class="line">    // 所以参考答案是很有必要的。但是我认为在实验指导书中也应该说明一下。</span><br><span class="line">    bool intr_flag;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">    	proc-&gt;pid = get_pid();</span><br><span class="line">		hash_proc(proc);</span><br><span class="line">		nr_process++;  // 参考答案添加在此处（我本来以为用了get_pid()就不需要这句了</span><br><span class="line">		list_add_before(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">    //    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    //    7. set ret vaule using child proc&apos;s pid</span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-能否为每个新线程赋值唯一id"><a class="markdownIt-Anchor" href="#22-能否为每个新线程赋值唯一id"></a> 2.2 能否为每个新线程赋值唯一ID</h4>
<p>阅读代码可以得知，<code>idleproc</code>的PID是由<code>proc_init</code>函数设置的，但<code>initproc</code>的PID应该怎么设置呢？我的解决方法是把分配PID的过程移到<code>do_fork</code>函数中，这样至少能通过测试了。参考答案的做法也类似，不过在分配PID和将进程插入队列的过程中进行了关中断处理，保证原子操作。</p>
<p>PID的唯一性是通过关中断和<code>get_pid</code>函数保证的，该函数查看当前的全部进程，在不发生中断的情况下，可以保证新分配的PID与之前的PID是不冲突的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// get_pid - alloc a unique pid for process</span><br><span class="line">static int</span><br><span class="line">get_pid(void) &#123;</span><br><span class="line">    static_assert(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    list_entry_t *list = &amp;proc_list, *le;</span><br><span class="line">    static int next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    if (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = 1;</span><br><span class="line">        goto inside;</span><br><span class="line">    &#125;</span><br><span class="line">    if (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = list;</span><br><span class="line">        while ((le = list_next(le)) != list) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            if (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                if (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    if (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    goto repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"><a class="markdownIt-Anchor" href="#练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的-无编码工作"></a> 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）</h3>
<p>请在实验报告中简要说明你对proc_run函数的分析。并回答如下问题：</p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用？请说明理由。</li>
</ul>
<p>完成代码编写后，编译并运行代码：<code>make qemu</code></p>
<p>如果可以得到如附录A所示的显示内容（仅供参考，不是标准答案输出），则基本正确。</p>
<hr>
<h4 id="31-内核线程"><a class="markdownIt-Anchor" href="#31-内核线程"></a> 3.1 内核线程</h4>
<p>分析一下<code>proc_init</code>函数的调用过程：</p>
<ul>
<li>初始化<code>proc_list</code>和<code>hash_list</code></li>
<li>调用<code>alloc_proc</code>函数分配<code>idleproc</code>所需的TCB块，检验是否分配成功</li>
<li>对<code>idleproc</code>进行基本设置（所以<code>alloc_proc</code>函数其实不需要干啥？）：
<ul>
<li>PID=0</li>
<li>state=PROC_RUNNABLE</li>
<li>kstack=bootstack</li>
<li>need_resched=1</li>
<li>name=“idle”</li>
</ul>
</li>
<li>将<code>current</code>变量置为<code>idleproc</code></li>
<li>调用<code>kernel_thread</code>函数，用<code>init_main</code>函数创建一个内核线程
<ul>
<li>创建所需的<code>trapframe</code></li>
<li>调用<code>do_fork</code>函数，创建新进程
<ul>
<li>调用<code>alloc_proc</code>，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
</li>
</ul>
</li>
<li>验证创建<code>initproc</code>线程成功（PID不为0）</li>
</ul>
<p><code>proc_init</code>函数是由<code>kern_init</code>函数调用的。在<code>kern_init</code>完成其余初始化之后，它调用<code>cpu_idle</code>函数，使得当前的<code>idle_proc</code>进程让出控制权，交给<code>initproc</code>线程，进行上下文的切换；执行完之后，回到<code>kernel_thread_entry</code>，退出。</p>
<p>由以上分析可知，在本实验的执行过程中，一共只创建了两个内核线程（<code>idleproc</code>和<code>initproc</code>）。</p>
<h4 id="32-关中断的必要性"><a class="markdownIt-Anchor" href="#32-关中断的必要性"></a> 3.2 关中断的必要性</h4>
<p>以下回答来自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=309" target="_blank" rel="noopener">Piazza</a>：</p>
<blockquote>
<p>由于进程号要求唯一性，进程号分配时可能需要查看进程列表中全部进程以避免发生冲突。若进程号已分配而进程尚未添加进进程列表时被中断，则该进程号可能会被重复分配，故进程号分配与进程添加应为原子操作。因而在进行上述操作时需关闭中断。</p>
</blockquote>
<h3 id="33-proc_run函数如何完成进程切换"><a class="markdownIt-Anchor" href="#33-proc_run函数如何完成进程切换"></a> 3.3 <code>proc_run</code>函数如何完成进程切换</h3>
<p>对进程切换的控制是通过<code>sched.c:schedule</code>函数完成的。一旦当前进程的<code>need_resched</code>变量被置为1，就调用<code>schedule</code>函数选择下一个要运行的进程，调用<code>proc_run</code>函数开始运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">schedule(void) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    list_entry_t *le, *last;</span><br><span class="line">    struct proc_struct *next = NULL;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = 0;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line">        do &#123;</span><br><span class="line">            if ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                if (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (le != last);</span><br><span class="line">        if (next == NULL || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        if (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就进入了<code>proc_run</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc != current) &#123;</span><br><span class="line">        bool intr_flag;</span><br><span class="line">        struct proc_struct *prev = current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的执行过程如下：</p>
<ol>
<li>关闭中断，保证原子操作</li>
<li>调用<code>load_esp0</code>函数，设置任务状态段<code>ts</code>中特权态0下的栈顶指针<code>esp0</code>为要切换到的内核线程的内核栈的栈顶，即<code>next-&gt;kstack + KSTACKSIZE</code>（建立指针的目的是，进行特权态切换时能够正确定位处于特权态0时进程的内核栈的栈顶）</li>
<li>设置CR3寄存器的值为要切换到的内核线程的页目录表起始地址，这实际上是完成进程间的页表切换，不过在内核中的内存切换下其实用不到</li>
<li>由 <code>switch_to</code>函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当<code>switch_to</code>函数执行完<code>ret</code>指令后，就切换到 <code>initproc</code>执行了</li>
</ol>
<p>在切换现场时，倒数第二条汇编指令<code>pushl 0(%eax)</code>其实把<code>context</code>中保存的下一个进程要执行的指令地址<code>context.eip</code>放到了堆栈顶，这样接下来执行最后一条指令<code>ret</code>时，会把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了。</p>
<p>事实上，在对initproc进行初始化时，设置了<code>initproc-&gt;context.eip = (uintptr_t)forkret</code>（见<code>copy_thread</code>函数），这样，当执行<code>switch_to</code>函数并返回后，将进入实际的执行入口地址<code>forkret</code>。而<code>forkret</code>会调用位于<code>kern/trap/trapentry.</code>S中的<code>forkrets</code>（参数是切换之后的进程的中断帧地址，该地址位于内核中线程对应的栈中，如果我没理解错的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&apos;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>forkrets</code>函数首先把<code>esp</code>指向当前进程的中断帧，然后跳转到<code>__trapret</code>，从中恢复中断帧的各个寄存器。这些寄存器是在<code>kernel_thread</code>函数中设置的，包括：</p>
<ul>
<li><code>tf.tf_cs = KERNEL_CS</code>：和内核使用同一代码段（这是合理的，因为<code>initproc</code>对应的代码也是内核的一部分）</li>
<li><code>tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS</code>：和内核使用同一数据（堆栈）段</li>
<li><code>tf.tf_regs.reg_ebx = (uint32_t)fn</code>：寄存器中的<code>ebx</code>为函数起始地址</li>
<li><code>tf.tf_regs.reg_edx = (uint32_t)arg</code>：寄存器中的<code>edx</code>指向函数参数地址</li>
<li><code>tf.tf_eip = (uint32_t)kernel_thread_entry</code>：中断后的实际起始地址是<code>kernel_thread_entry</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>对于<code>initproc</code>，<code>current-&gt;tf.tf_eip=kernel_thread_entry</code>，<code>initproc-&gt;tf.tf_cs = KERNEL_CS</code>，所以执行完<code>iret</code>后，就开始在内核中执行<code>kernel_thread_entry</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl kernel_thread_entry</span><br><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread</span><br></pre></td></tr></table></figure>
<p>首先把进程的参数入栈，然后调用起始地址（现在是实际的起始地址了，对于<code>initproc</code>，这个起始地址就是<code>init_main</code>函数的开头）。所以执行<code>call %ebx</code>后，就开始执行<code>initproc</code>的主体了。</p>
<p>执行结束后，返回到<code>kernel_tread_entry</code>函数，它会进一步调用<code>proc.c:do_exit</code>函数，执行退出操作。目前这个函数除了打印一点字符串没有做别的工作。</p>
<h3 id="扩展练习challenge实现支持任意大小的内存分配算法"><a class="markdownIt-Anchor" href="#扩展练习challenge实现支持任意大小的内存分配算法"></a> 扩展练习Challenge：实现支持任意大小的内存分配算法</h3>
<p>这不是本实验的内容，其实是上一次实验内存的扩展，但考虑到现在的slab算法比较复杂，有必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的slab如何调用基于页的内存分配算法（注意，不是要你关注slab的具体实现）来实现first-fit/best-fit/worst-fit/buddy等支持任意大小的内存分配算法。</p>
<p>【注意】下面是相关的Linux实现文档，供参考<br>
SLOB<br>
<a href="http://en.wikipedia.org/wiki/SLOB" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SLOB</a> <a href="http://lwn.net/Articles/157944/" target="_blank" rel="noopener">http://lwn.net/Articles/157944/</a><br>
SLAB<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></p>
<hr>
<p>没写。</p>
<h2 id="分析参考答案"><a class="markdownIt-Anchor" href="#分析参考答案"></a> 分析参考答案</h2>
<ul>
<li><code>alloc_proc</code>：和参考答案的实现类似，参考了答案中的一些我忘了写的部分，如初始化内核堆栈和将context清零</li>
<li><code>do_fork</code>：参考了答案，添加了一些错误处理，以及分配pid时关中断</li>
</ul>
<h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 知识点</h2>
<ul>
<li>进程状态</li>
<li>进程控制块</li>
<li>内核栈和用户栈</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/ucore/"><i class="fas fa-hashtag fa-fw"></i>ucore</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2015-final-exam-analysis/">
              
                  《操作系统》2015年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-23
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href></a>。这个卷子实在过于长了，不仅莫名有一个完整的缓冲区问题的实现，还有一堆ucore代码需要阅读和填空。</p>
<h2 id="一10分"><a class="markdownIt-Anchor" href="#一10分"></a> 一（10分）</h2>
<p>在用<code>do_execve</code>启动一个用户态进程时，ucore需要完成很多准备工作，这些工作有的在内核态完成，有的在用户态完成。请判断下列事项是否是ucore在正常完成<code>do_execve</code>中所需要的，如果是，指出它完成于内核态还是用户态（通过修改<code>trapframe</code>，在<code>iret</code>时改变寄存器的过程被认为是在内核态完成）。</p>
<ol>
<li>初始化进程所使用的栈</li>
<li>在栈上准备argc和argv的内容</li>
<li>将argc和argv作为用户main函数的参数放到栈上</li>
<li>设置EIP为用户main函数的地址</li>
<li>设置系统调用的返回值</li>
</ol>
<hr>
<ol>
<li>需要；内核态</li>
<li>需要；内核态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li><del>需要；内核态</del>不需要；用户态</li>
<li>不需要</li>
</ol>
<p>这个题出的很没有意义啊，系统调用返回之后几乎就要立即跳转到用户进程指令的第一条了。</p>
<p>以下内容摘自ucore docs Lab5：</p>
<blockquote>
<p>最终通过<code>do_execve</code>函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
</blockquote>
<ul>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。<br>
……<br>
load_icode函数的工作：</li>
</ul>
<ol>
<li>初始化mm</li>
<li>分配和设置页目录表</li>
<li>解析ELF文件，建立vma，初始化进程的用户态虚拟地址空间</li>
<li>分配物理内存空间，建立页表映射关系，拷贝程序内容</li>
<li>设置用户栈</li>
<li>将页目录表基地址加载到CR3寄存器中</li>
<li>重设进程中断帧，准备切换到用户态<br>
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句） 后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。</li>
</ol>
<p>2018.5.25 UPD：<br>
tsz同学指出，事实上这道题和第六大题的代码内容直接相关。从中可以看出，<code>user/libs/initcode.S</code>做的就是在用户态为<code>main</code>函数设置参数的工作。所以3和4的答案应该修改一下。事实证明，想当然是不好的。</p>
<h2 id="二-vsfs18分"><a class="markdownIt-Anchor" href="#二-vsfs18分"></a> 二 VSFS（18分）</h2>
<p>这道题和<a href="/post/os-mooc-final-exam-analysis">MOOC期末考试题</a>中的第20题一模一样，所以略。</p>
<h2 id="三-进程状态变化16分"><a class="markdownIt-Anchor" href="#三-进程状态变化16分"></a> 三 进程状态变化（16分）</h2>
<p>在ucore中<code>enum proc_state</code>的定义包含以下四个值：</p>
<ul>
<li><code>PROC_UNINIT</code></li>
<li><code>PROC_SLEEPING</code></li>
<li><code>PROC_RUNNABLE</code></li>
<li><code>PROC_ZOMBIE</code><br>
请解释每一种状态的含义，以及各状态之间可能的迁移。</li>
</ul>
<hr>
<ul>
<li><code>PROC_UNINIT</code>：刚申请完进程控制块，进程还未被初始化</li>
<li><code>PROC_SLEEPING</code>：进程处于等待状态</li>
<li><code>PROC_RUNNABLE</code>：进程处于就绪或运行状态</li>
<li><code>PROC_ZOMBIE</code>：僵尸状态，进程已经退出，等待父进程进一步回收资源</li>
</ul>
<p>以下内容（进程的正常生命周期）摘自ucore docs Lab6：</p>
<blockquote>
<p>进程的正常生命周期如下：</p>
</blockquote>
<ul>
<li>进程首先在cpu初始化或者<code>sys_fork</code>的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入<code>uninit</code>态(在<code>proc.c</code>中<code>alloc_proc</code>)。</li>
<li>当进程完全完成初始化之后，该进程转为<code>runnable</code>态。</li>
<li>当到达调度点时，由调度器<code>sched_class</code>根据运行队列<code>rq</code>的内容来判断一个进程是否应该被运行，即把处于<code>runnable</code>态的进程转换成<code>running</code>状态，从而占用CPU执行。</li>
<li><code>running</code>态的进程通过<code>wait</code>等系统调用被阻塞，进入<code>sleeping</code>态。</li>
<li><code>sleeping</code>态的进程被<code>wakeup</code>变成<code>runnable</code>态的进程。</li>
<li><code>running</code>态的进程主动<code>exit</code>变成<code>zombie</code>态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为<code>unused</code>。</li>
<li>所有从<code>runnable</code>态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ul>
<p>以下内容摘自<a href="https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-4/process_status_change.html" target="_blank" rel="noopener">进程运行状态转变过程</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process state changing:</span><br><span class="line"></span><br><span class="line">  alloc_proc                                 RUNNING</span><br><span class="line">      +                                   +--&lt;----&lt;--+</span><br><span class="line">      +                                   + proc_run +</span><br><span class="line">      V                                   +--&gt;----&gt;--+</span><br><span class="line">PROC_UNINIT -- proc_init/wakeup_proc --&gt; PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --&gt; PROC_SLEEPING --</span><br><span class="line">                                           A      +                                                           +</span><br><span class="line">                                           |      +--- do_exit --&gt; PROC_ZOMBIE                                +</span><br><span class="line">                                           +                                                                  +</span><br><span class="line">                                           -----------------------wakeup_proc----------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="四-stride调度算法15分"><a class="markdownIt-Anchor" href="#四-stride调度算法15分"></a> 四 Stride调度算法（15分）</h2>
<p>假设在lab6测试stride scheduling的过程中，采用如下默认配置：BigStride为0x7FFFFFFF，CPU时间片为50ms，测试过程包含五个进程，其初始<del>stride</del>pass均为1，优先级分别为1、2、3、4、5，测试时间为10s。下面给出了五种修改上述配置的方式，试讨论：对于每一种改动，测试结果相比改动之前是否会发生明显的变化？如果是，结果会变得更接近于理想情况，还是远离理想情况？</p>
<ol>
<li>BigStride改为120</li>
<li>CPU时间片改为5ms</li>
<li>五个进程的初始pass改为100</li>
<li>五个进程的优先级设为2、4、6、8、10</li>
<li>测试时间延长到20s</li>
</ol>
<hr>
<p>在测试时间10s的情况下，时间片总个数为200。</p>
<ol>
<li>如果将BigStride改为120，则stride最大为120，不会溢出，而且120能够整除1、2、3、4、5，更能够保证进程的pass按优先级推进，因此会更接近于理想情况</li>
<li>时间片总个数变成2000，因为进程stride有偏差，因此会远离理想情况</li>
<li>因为100这个值相比各个进程的stride太小了，所以应该不会有明显变化</li>
<li>不会有明显变化</li>
<li>同2，更远离理想情况</li>
</ol>
<p>这个题目中不同学长的答案大相径庭，所以我选了一种我觉得合理的。事实上，Stride调度算法的论文中讨论了一下误差问题：在stride和优先级精确地成反比的情况下，各个线程之间按比例分配到的时间片数量的误差不超过1，也就是说，总误差是O(nc)（nc是线程数量）。所以大概stride计算不准确造成的影响是比较大的。</p>
<h2 id="五-生产者-消费者问题10分"><a class="markdownIt-Anchor" href="#五-生产者-消费者问题10分"></a> 五 生产者-消费者问题（10分）</h2>
<p>生产者-消费者问题是指，一组生产者进程和一组消费者进程共享一个初始为空、大小为3（不如说是BUFFER_SIZE）的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个生产者放入消息，或者一个消费者从中取出消息。</p>
<p>下面是生产者-消费者问题的一个实现和测试结果。请回答下面问题：</p>
<ol>
<li>请用伪码给出信号量的PV操作实现。</li>
<li>这个实现正确吗？如果不正确，给出你的正确实现。</li>
<li>这两个测试用例能发现该实现中的可能错误吗？如果不能，请给出你的尽可能完整的测试用例。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">==== producer-consumer.cpp ====</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;new&gt; // ::operator new[]</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define BUFFER_SIZE 3</span><br><span class="line">#define SLEEP_SPAN 5</span><br><span class="line">#define WORK_SPAN 4</span><br><span class="line"></span><br><span class="line">#define PRODUCER 0</span><br><span class="line">#define CONSUMER 1</span><br><span class="line"></span><br><span class="line">int iflag = 0;</span><br><span class="line">int oflag = 0;</span><br><span class="line">sem_t empty, full, mutex;</span><br><span class="line">int empty_count, full_count;</span><br><span class="line">int data_num = 0;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">int buffer[BUFFER_SIZE] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int p_task_done = -1;</span><br><span class="line">int c_task_done = -1;</span><br><span class="line"></span><br><span class="line">struct arg_struct &#123;</span><br><span class="line">    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent) &#123;&#125;</span><br><span class="line">    arg_struct(int _id): id(_id), start(0), work(0), indent(string(&quot;&quot;)) &#123;&#125;</span><br><span class="line">    int id;</span><br><span class="line">    int start;</span><br><span class="line">    int work;</span><br><span class="line">    string indent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void* producer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;empty);  /* 顺序错了 */</span><br><span class="line">    printf(&quot;%saEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    int time = rand() % SLEEP_SPAN;</span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    p_task_done++;</span><br><span class="line">    printf(&quot;%sProd %d\n&quot;, indent, p_task_done);</span><br><span class="line"></span><br><span class="line">    buffer[iflag] = p_task_done;</span><br><span class="line"></span><br><span class="line">    if (empty_count == 0) printf(&quot;Error: Produce while no empty\n&quot;);</span><br><span class="line">    iflag = (iflag + 1) % BUFFER_SIZE;</span><br><span class="line">    empty_count--;</span><br><span class="line">    full_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;full);</span><br><span class="line">    printf(&quot;%srFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* consumer(void* argv)&#123;</span><br><span class="line">    arg_struct arg = *(arg_struct*)argv;</span><br><span class="line">    int id = arg.id;</span><br><span class="line">    const char* indent = arg.indent.c_str();</span><br><span class="line"></span><br><span class="line">    sleep(arg.start);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sSTART\n&quot;, indent);</span><br><span class="line">    sem_wait(&amp;full);</span><br><span class="line">    printf(&quot;%saFULL\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;mutex);</span><br><span class="line">    printf(&quot;%saMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sENTER\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sleep(arg.work);</span><br><span class="line"></span><br><span class="line">    ++c_task_done;</span><br><span class="line">    if (full_count == 0) printf(&quot;Error: Consume while no full\n&quot;);</span><br><span class="line"></span><br><span class="line">    int tmp = buffer[oflag];</span><br><span class="line">    printf(&quot;%sCons %d\n&quot;, indent, tmp);</span><br><span class="line"></span><br><span class="line">    oflag = (oflag + 1) % BUFFER_SIZE;</span><br><span class="line">    if (c_task_done != tmp) printf(&quot;Error: Consume data wrong\n&quot;);</span><br><span class="line">    if (c_task_done &gt; p_task_done) printf(&quot;Error: Over-consume!\n&quot;);</span><br><span class="line"></span><br><span class="line">    full_count--;</span><br><span class="line">    empty_count++;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%sEXIT\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;mutex);</span><br><span class="line">    printf(&quot;%srMUTEX\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;empty);</span><br><span class="line">    printf(&quot;%srEMPTY\n&quot;, indent);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define N 3</span><br><span class="line">void testcase_producer_consumer(int ThreadNumber, int inst[2 * N][3]) &#123;</span><br><span class="line">    pthread_t * p_consumer = new pthread_t[ThreadNumber];</span><br><span class="line">    pthread_t * p_producer = new pthread_t[ThreadNumber];</span><br><span class="line"></span><br><span class="line">    int c_count = 0, p_count = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;testcase_producer_consumer:\n&quot;);</span><br><span class="line">    /* For managed creation of &apos;ThreadNumber&apos; threads */</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    /* Print the first line */</span><br><span class="line">    int tmp_c = 0, tmp_p = 0;</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER) &#123;</span><br><span class="line">            printf(&quot;P%d\t&quot;, tmp_p++);</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER) &#123;</span><br><span class="line">            printf(&quot;C%d\t&quot;, tmp_c++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* Create Producers and Consumers according to $inst*/</span><br><span class="line">    int rc;</span><br><span class="line">    string indent(&quot;&quot;);</span><br><span class="line">    for (int i = 0; i &lt; ThreadNumber; i++) &#123;</span><br><span class="line">        if (inst[i][0] == PRODUCER)  &#123;</span><br><span class="line">            rc = pthread_create(p_producer + p_count, NULL, producer, new arg_struct(p_count, inst[i][1],</span><br><span class="line">            inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            p_count++;</span><br><span class="line">        &#125; else if (inst[i][0] == CONSUMER)&#123;</span><br><span class="line">            rc = pthread_create(p_consumer + c_count, NULL, consumer, new arg_struct(c_count, inst[i][1],             inst[i][2], indent));</span><br><span class="line">            if (rc) printf(&quot;ERROR\n&quot;);</span><br><span class="line">            c_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        indent += &apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* wait until every thread finishes*/</span><br><span class="line">    for (int i = 0; i &lt; p_count; i++) &#123;</span><br><span class="line">        pthread_join(p_producer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; c_count; i++) &#123;</span><br><span class="line">        pthread_join(p_consumer[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] p_producer;</span><br><span class="line">    delete[] p_consumer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line"></span><br><span class="line">    memset(buffer, 0, sizeof(int) * BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex, 0, 1);</span><br><span class="line">    sem_init(&amp;empty, 0, BUFFER_SIZE);</span><br><span class="line">    sem_init(&amp;full, 0, 0);</span><br><span class="line"></span><br><span class="line">    empty_count = BUFFER_SIZE;</span><br><span class="line">    full_count = 0;</span><br><span class="line"></span><br><span class="line">    /* For managed creation of 2 * N threads */</span><br><span class="line">    int ThreadNumber = 2 * N ;</span><br><span class="line">    int st_time = 0;</span><br><span class="line">    int inst[2 * N][3] = &#123;</span><br><span class="line">        /* &#123; Consumer or Producer to be create?,</span><br><span class="line">        When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">        How long does it work after it enters critical zone? &#125; */</span><br><span class="line">        &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst);</span><br><span class="line">    st_time = 0;</span><br><span class="line"></span><br><span class="line">    int inst2[2 * N][3] = &#123;</span><br><span class="line">        &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">        &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">        &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    testcase_producer_consumer(ThreadNumber, inst2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例的执行输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">xyong@ubuntu-xyong:~/work$ gcc producer-consumer.cpp -lpthread -lstdc++</span><br><span class="line">xyong@ubuntu-xyong:~/work$ ./a.out</span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">C0    C1    C2    P0    P1    P2</span><br><span class="line">START</span><br><span class="line">      START</span><br><span class="line">            START</span><br><span class="line">                  START</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  aEMPTY</span><br><span class="line">                  ENTER</span><br><span class="line">                  Prod 0</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rFULL</span><br><span class="line">aFULL</span><br><span class="line">aMUTEX</span><br><span class="line">ENTER</span><br><span class="line">                        START</span><br><span class="line">Cons 0</span><br><span class="line">EXIT</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">rMUTEX</span><br><span class="line">rEMPTY</span><br><span class="line">                        Prod 1</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">      aFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      ENTER</span><br><span class="line">      Cons 1</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 2</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">            aFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">            Cons 2</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line"></span><br><span class="line">testcase_producer_consumer:</span><br><span class="line">P0    P1    C0    C1    P2    C2</span><br><span class="line">START</span><br><span class="line">aMUTEX</span><br><span class="line">aEMPTY</span><br><span class="line">ENTER</span><br><span class="line">      START</span><br><span class="line">Prod 3</span><br><span class="line">EXIT</span><br><span class="line">rMUTEX</span><br><span class="line">rFULL</span><br><span class="line">      aMUTEX</span><br><span class="line">      aEMPTY</span><br><span class="line">      ENTER</span><br><span class="line">            START</span><br><span class="line">            aFULL</span><br><span class="line">      Prod 4</span><br><span class="line">      EXIT</span><br><span class="line">      rMUTEX</span><br><span class="line">      rFULL</span><br><span class="line">            aMUTEX</span><br><span class="line">            ENTER</span><br><span class="line">                  START</span><br><span class="line">                  aFULL</span><br><span class="line">            Cons 3</span><br><span class="line">            EXIT</span><br><span class="line">            rMUTEX</span><br><span class="line">            rEMPTY</span><br><span class="line">                  aMUTEX</span><br><span class="line">                  ENTER</span><br><span class="line">                  Cons 4</span><br><span class="line">                  EXIT</span><br><span class="line">                  rMUTEX</span><br><span class="line">                  rEMPTY</span><br><span class="line">                        START</span><br><span class="line">                        aMUTEX</span><br><span class="line">                        aEMPTY</span><br><span class="line">                        ENTER</span><br><span class="line">                        Prod 5</span><br><span class="line">                        EXIT</span><br><span class="line">                        rMUTEX</span><br><span class="line">                        rFULL</span><br><span class="line">                              START</span><br><span class="line">                              aFULL</span><br><span class="line">                              aMUTEX</span><br><span class="line">                              ENTER</span><br><span class="line">                              Cons 5</span><br><span class="line">                              EXIT</span><br><span class="line">                              rMUTEX</span><br><span class="line">                              rEMPTY</span><br><span class="line">xyong@ubuntu-xyong:~/work$</span><br></pre></td></tr></table></figure>
<hr>
<p>这道题真是又臭又长……</p>
<p>信号量PV操作的伪代码：这个是十分简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">P() &#123;</span><br><span class="line">    sem--;</span><br><span class="line">    if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    if (sem &lt;= 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是否正确？答案是不正确。producer线程的实现中获取<code>mutex</code>和<code>empty</code>信号量的顺序反了。总的来说，把这两个换一下就好了。</p>
<p>题目中给出的两个测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int inst[2 * N][3] = &#123;</span><br><span class="line">    /* &#123; Consumer or Producer to be create?,</span><br><span class="line">    When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C</span><br><span class="line">    How long does it work after it enters critical zone? &#125; */</span><br><span class="line">    &#123;CONSUMER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我给出的测试样例是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int inst2[2 * N][3] = &#123;</span><br><span class="line">    &#123;PRODUCER, st_time += 0, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 1, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 2, 2&#125;,</span><br><span class="line">    &#123;PRODUCER, st_time += 3, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 4, 2&#125;,</span><br><span class="line">    &#123;CONSUMER, st_time += 5, 2&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目中并没有要求Producer和Consumer的数量必须为3个。从理论上来说，只要Producer比Consumer大的个数在3个（也就是缓冲区的大小）以内，都能正常结束。但是在错误实现中会发生这样的问题：P1-P3生产完之后，P4获得<code>mutex</code>后开始在<code>empty</code>信号量上等待。但是，由于它占据了<code>mutex</code>，因此C1和C2无法进入临界区进行消费，于是也不会对<code>empty</code>信号量执行V操作，发生死锁。</p>
<h2 id="六-ucore用户进程16分"><a class="markdownIt-Anchor" href="#六-ucore用户进程16分"></a> 六 ucore用户进程（16分）</h2>
<p>下面是关于ucore中用户程序的生命历程的代码。请完成下面填空和代码补全。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h3>
<p>在<code>sh</code>的命令行上输入<code>args 1</code>启动用户程序<code>args</code>，则<code>sh</code>会调用（<strong>1</strong>）创建新进程并调用（<strong>2</strong>）将<code>args</code>加载到该进程的地址空间中。（回答系统调用名称即可）</p>
<ol>
<li><code>SYS_fork</code></li>
<li><code>SYS_exec</code></li>
</ol>
<hr>
<p>这一题使我觉得我应该复习一下ucore里的各种系统调用、实现方法及其作用。</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h3>
<p>将<code>args</code>从硬盘加载主要由<code>load_icode</code>完成，请补全以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">// load_icode - called by sys_exec--&gt;do_execve</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">load_icode(int fd, int argc, char **kargv) &#123;</span><br><span class="line">    /* LAB8:EXERCISE2 YOUR CODE HINT:how to load the file with handler fd in to process&apos;s memory? how to setup argc/argv?</span><br><span class="line">    * MACROs or Functions:</span><br><span class="line">    * mm_create - create a mm</span><br><span class="line">    * setup_pgdir - setup pgdir in mm</span><br><span class="line">    * load_icode_read - read raw data content of program file</span><br><span class="line">    * mm_map - build new vma</span><br><span class="line">    * pgdir_alloc_page - allocate new memory for TEXT/DATA/BSS/stack parts</span><br><span class="line">    * lcr3 - update Page Directory Addr Register -- CR3</span><br><span class="line">    */</span><br><span class="line">    /* (1) create a new mm for current process</span><br><span class="line">    * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span><br><span class="line">    * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span><br><span class="line">    * (3.1) read raw data content in file and resolve elfhdr</span><br><span class="line">    * (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span><br><span class="line">    * (3.3) call mm_map to build vma related to TEXT/DATA</span><br><span class="line">    * (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span><br><span class="line">    * and copy them into the new allocated pages</span><br><span class="line">    * (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span><br><span class="line">    * (4) call mm_map to setup user stack, and put parameters into user stack</span><br><span class="line">    * (5) setup current process&apos;s mm, cr3, reset pgidr (using lcr3 MARCO)</span><br><span class="line">    * (6) setup uargc and uargv in user stacks</span><br><span class="line">    * (7) setup trapframe for user environment</span><br><span class="line">    * (8) if up steps failed, you should cleanup the env.</span><br><span class="line">    */</span><br><span class="line">    assert(argc &gt;= 0 &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    if (current-&gt;mm != NULL) &#123;</span><br><span class="line">        panic(&quot;load_icode: current-&gt;mm must be empty.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = -E_NO_MEM;</span><br><span class="line">    struct mm_struct *mm;</span><br><span class="line">    if ((mm = mm_create()) == NULL) &#123;</span><br><span class="line">        goto bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    if (setup_pgdir(mm) != 0) &#123;</span><br><span class="line">        goto bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Page *page;</span><br><span class="line"></span><br><span class="line">    struct elfhdr __elf, *elf = &amp;__elf;</span><br><span class="line">    /* 2a */</span><br><span class="line">    if ((ret = load_icode_read(fd, elf, _(2a)_, 0)) != 0) &#123;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        goto bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr __ph, *ph = &amp;__ph;</span><br><span class="line">    uint32_t vm_flags, perm, phnum;</span><br><span class="line">    for (phnum = 0; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;</span><br><span class="line">        off_t phoff = elf-&gt;e_phoff + sizeof(struct proghdr) * phnum;</span><br><span class="line">        if ((ret = load_icode_read(fd, ph, sizeof(struct proghdr), phoff)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            /* 2b */</span><br><span class="line">            _(2b)_</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ph-&gt;p_filesz == 0) &#123;</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = 0, perm = PTE_U;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        if (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        if (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        if ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">            goto bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        off_t offset = ph-&gt;p_offset;</span><br><span class="line">        size_t off, size;</span><br><span class="line">        uintptr_t start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != 0) &#123;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line"></span><br><span class="line">        if (start &lt; la) &#123;</span><br><span class="line">            /* ph-&gt;p_memsz == ph-&gt;p_filesz */</span><br><span class="line">            if (start == end) &#123;</span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                goto bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            if (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(page2kva(page) + off, 0, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    /* 2c */</span><br><span class="line">    if ((ret = mm_map(mm, _(2c)_, USTACKSIZE, vm_flags, NULL)) != 0) &#123;</span><br><span class="line">        goto bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    //setup argc, argv</span><br><span class="line">    uint32_t argv_size=0, i;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">    char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">    argv_size = 0;</span><br><span class="line">    for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        /* 2d */</span><br><span class="line">        _(2d)_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">    /* 2e */</span><br><span class="line">    *(int *)stacktop = _(2e)_;</span><br><span class="line"></span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    memset(tf, 0, sizeof(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = 0;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sizeof(struct elfhdr)</code>（读一个<code>elfhdr</code>大小的文件数据）</li>
<li><code>goto bad_cleanup_mmap;</code>（这个很简单：已经设置了<code>pgdir</code>和<code>mm</code>了，因此如果失败需要清理；而且周围都是跳转到这里）</li>
<li><code>USTACKTOP - USTACKSIZE</code>（这段大概是映射用户栈空间，不过我并不是很明白）</li>
<li><code>argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</code>（得到当前的参数的长度）</li>
<li><code>argc</code>（把argc放到栈顶；之所以是栈顶，是因为gcc是从右向左压栈的）</li>
</ol>
<hr>
<p>这种默写代码的题目实在是无聊死了。</p>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> （3）</h3>
<p>完成加载后会从内核态回到用户态，请补全此时的用户栈图示。（假定为写入部分全部初始化为0，注意使用小尾端）</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>(3a)</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>(3b)</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>(3c)</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>(3d)</td>
</tr>
</tbody>
</table>
<p>此时并不会直接进入main函数，而是执行以下代码，请简述其作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//////// user/libs/initcode.S //////////</span><br><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line"></span><br><span class="line">    movl (%esp), %ebx</span><br><span class="line">    lea 0x4(%esp), %ecx</span><br><span class="line"></span><br><span class="line">    subl $0x20, %esp</span><br><span class="line"></span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line"></span><br><span class="line">    call umain</span><br><span class="line">1: jmp 1b</span><br><span class="line"></span><br><span class="line">////////// user/libs/umain.c ////////////</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;file.h&gt;</span><br><span class="line">#include &lt;stat.h&gt;</span><br><span class="line">int main(int argc, char *argv[]);</span><br><span class="line">static int</span><br><span class="line">initfd(int fd2, const char *path, uint32_t open_flags) &#123;</span><br><span class="line">    int fd1, ret;</span><br><span class="line">    if ((fd1 = open(path, open_flags)) &lt; 0) &#123;</span><br><span class="line">        return fd1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (fd1 != fd2) &#123;</span><br><span class="line">        close(fd2);</span><br><span class="line">        ret = dup2(fd1, fd2);</span><br><span class="line">        close(fd1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char *argv[]) &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if ((fd = initfd(0, &quot;stdin:&quot;, O_RDONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdin&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((fd = initfd(1, &quot;stdout:&quot;, O_WRONLY)) &lt; 0) &#123;</span><br><span class="line">        warn(&quot;open &lt;stdout&gt; failed: %e.\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = main(argc, argv);</span><br><span class="line">    exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<!--
恕我直言，我一开始不知道这道题在说什么。大概调用用户程序`args`的时候会有两个参数：`int argc`和`char** argv`，其中`argc = 2`，`argv = ['args', '1']`。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述内容执行完之后，得到<code>argv_size = 6</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">	uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">	argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argc;</span><br></pre></td></tr></table></figure>
<p>然后学长答案是这样：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xb0000000</td>
<td>-</td>
</tr>
<tr>
<td>0xaffffffc</td>
<td>00 31 00 00</td>
</tr>
<tr>
<td>0xaffffff8</td>
<td>61 72 67 73 // ‘args’</td>
</tr>
<tr>
<td>0xaffffff4</td>
<td>fd ff ff ff</td>
</tr>
<tr>
<td>0xaffffff0</td>
<td>f8 ff ff ff</td>
</tr>
<tr>
<td>0xafffffec</td>
<td>02 00 00 00</td>
</tr>
<tr>
<td>0xafffffe8</td>
<td>00 00 00 00</td>
</tr>
</tbody>
</table>
<p>恕我直言，我也看不懂。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢tsz和xzh同学关于此题的讨论）</p>
<p>不妨把填充栈帧的代码段拿出来细看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//setup argc, argv</span><br><span class="line">uint32_t argv_size=0, i;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在栈中预留函数参数的位置</span><br><span class="line">uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);</span><br><span class="line">// 在栈中预留函数参数指针的位置</span><br><span class="line">char** uargv=(char **)(stacktop - argc * sizeof(char *));</span><br><span class="line"></span><br><span class="line">argv_size = 0;</span><br><span class="line">for (i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">    // 从低地址到高地址填各参数指针，顺便把参数内容拷进去</span><br><span class="line">    uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">    // argv_size += 长度</span><br><span class="line">    argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把argc放入栈中</span><br><span class="line">stacktop = (uintptr_t)uargv - sizeof(int);</span><br><span class="line">*(int *)stacktop = argv;</span><br></pre></td></tr></table></figure>
<p>事实上，这段代码的目的，就是从栈底到栈顶，依次存参数内容（所有参数拼起来）、各参数的指针（<code>char **argv</code>）和argc存进去。实际上，被调用的进程<code>args</code>有两个实际参数：进程名<code>&quot;argc&quot;</code>和参数<code>&quot;1&quot;</code>（注意这两者都是字符串）。于是结果变成了这样：</p>
<ul>
<li>参数<code>&quot;1\0&quot;</code>存在<code>0xaffffffd</code>开始的2个字节中</li>
<li>参数<code>&quot;args\0&quot;</code>存在<code>0xaffffff8</code>开始的5个字节中</li>
<li>参数<code>&quot;1\0&quot;</code>所在的地址<code>0xaffffffd</code>存在<code>0xaffffff4</code>开始的4个字节中（注意大小端）</li>
<li>参数<code>&quot;args\0&quot;</code>所在的地址<code>0xaffffff8</code>存在<code>0xaffffff0</code>开始的4个字节中（注意大小端）</li>
<li><code>argc</code>存放在<code>0xafffffec</code>开始的4个字节中（注意大小端）</li>
</ul>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0xb0000000</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>0xaffffffc</code></td>
<td><code>00 31 00 00</code></td>
<td>字符串&quot;1&quot;（和&quot;args&quot;的<code>\0</code>）</td>
</tr>
<tr>
<td><code>0xaffffff8</code></td>
<td><code>61 72 67 73</code></td>
<td>字符串&quot;args&quot;</td>
</tr>
<tr>
<td><code>0xaffffff4</code></td>
<td><code>fd ff ff af</code></td>
<td>&quot;1&quot;的地址</td>
</tr>
<tr>
<td><code>0xaffffff0</code></td>
<td><code>f8 ff ff af</code></td>
<td>&quot;args&quot;的地址</td>
</tr>
<tr>
<td><code>0xafffffec</code></td>
<td><code>02 00 00 00</code></td>
<td><code>argv = 2</code></td>
</tr>
<tr>
<td><code>0xafffffe8</code></td>
<td><code>00 00 00 00</code></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>后面代码的作用据说是为umain函数压入argc和argv，调整esp，打开stdin/stdout，然后调用main。总之，打开stdin/stdout这个部分我好像看懂了；压入argc和argv的本质就是利用gcc调用了函数。</p>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> （4）</h3>
<p>虽然main函数以<code>return 0;</code>结束，但此后程序仍在用户态，经过（<strong>4a</strong>）进入内核态，参考<code>do_exit</code>代码，其主要完成了页表和文件描述符的释放、设置进程状态和返回值、唤醒等待中的父进程、（<strong>4b</strong>）。（<code>while</code>循环部分）</p>
<p><code>do_exit</code>中该进程占用的内存并未完全释放，例如（<strong>4c</strong>），它们将在（<strong>4d</strong>）中被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_exit(int error_code) &#123;</span><br><span class="line">	if (current == idleproc) &#123;</span><br><span class="line">    	panic(&quot;idleproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (current == initproc) &#123;</span><br><span class="line">		panic(&quot;initproc exit.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">	if (mm != NULL) &#123;</span><br><span class="line">		lcr3(boot_cr3);</span><br><span class="line">		if (mm_count_dec(mm) == 0) &#123;</span><br><span class="line">			exit_mmap(mm);</span><br><span class="line">			put_pgdir(mm);</span><br><span class="line">			mm_destroy(mm);</span><br><span class="line">		&#125;</span><br><span class="line">		current-&gt;mm = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	put_fs(current); //for LAB8</span><br><span class="line">	current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">	current-&gt;exit_code = error_code;</span><br><span class="line"></span><br><span class="line">	bool intr_flag;</span><br><span class="line">	struct proc_struct *proc;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">		proc = current-&gt;parent;</span><br><span class="line">		if (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">			wakeup_proc(proc);</span><br><span class="line">		&#125;</span><br><span class="line">		while (current-&gt;cptr != NULL) &#123;</span><br><span class="line">			proc = current-&gt;cptr;</span><br><span class="line">			current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">			proc-&gt;yptr = NULL;</span><br><span class="line">			if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) &#123;</span><br><span class="line">				initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proc-&gt;parent = initproc;</span><br><span class="line">			initproc-&gt;cptr = proc;</span><br><span class="line">				if (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">					if (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">						wakeup_proc(initproc);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">	panic(&quot;do_exit will not return!! %d.\n&quot;, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ol>
<li><code>exit</code>系统调用</li>
<li>把子进程逐个放入initproc的子进程中，如果发现子进程已经为僵尸状态且initproc进入WT_CHILD状态，则唤醒initproc回收子进程</li>
<li>进程控制块</li>
<li>父进程的<code>do_wait</code>（或者说被唤醒的执行了wait或wait_pid的父进程）</li>
</ol>
<p>这道题反而比较简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parent:           proc-&gt;parent  (proc is children)</span><br><span class="line">children:         proc-&gt;cptr    (proc is parent)</span><br><span class="line">older sibling:    proc-&gt;optr    (proc is younger sibling)</span><br><span class="line">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span><br></pre></td></tr></table></figure>
<h2 id="七-磁盘调度15分"><a class="markdownIt-Anchor" href="#七-磁盘调度15分"></a> 七 磁盘调度（15分）</h2>
<p>一磁盘逆时针旋转，磁盘有3个磁道和一个磁头，每个磁道有12个扇区。最外侧磁道0包含扇区0<sub>11，中间侧磁道1包含扇区12</sub>23，最内侧磁道包含扇区24~35。如下图所示，可以看到磁头初始位置在外侧磁道的扇区6的中间位置，扇区10与扇区6在一个磁道上。</p>
<p><img src="simple-disk.png" alt="磁盘示意图" /></p>
<p>完成一次磁盘扇区的访问请求时间包括：</p>
<ul>
<li>寻道时间（seek time）</li>
<li>旋转时间（rotational time）</li>
<li>传输时间（transfer time）</li>
</ul>
<p>如，ucore发出访问请求序列为[‘10’]，即只有一次对扇区10的访问请求，则磁盘花费的访问请求时间如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">TOTALS  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br></pre></td></tr></table></figure>
<p>表示寻道时间是0个时间单位，旋转时间是105个时间单位，总共的磁盘访问请求的时间是135。注意，相邻磁头移动一个磁道的时间是40个时间单位；从扇区6到扇区9，旋转了90度；而为了进行传输，需要从扇区9<sub>10的中间位置开始，从扇区10</sub>11的中间位置结束。所以需要再旋转15度，即旋转了105度，而每旋转1度花费1个时间单位，所以旋转花费了105个实践单位。</p>
<ol>
<li>若采用FIFO磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
<li>若采用SSFT磁盘调度策略，访问请求序列为[‘10’, ‘12’, ‘24’, ‘1’]，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。</li>
</ol>
<hr />
<!--
FIFO策略：
* 10
  * 磁道不变
  * 旋转：105
  * 传输：30
* 12
  * 寻道：40
  * 旋转：60
  * 传输：30
* 24
  * 寻道：40
  * 旋转：360
  * 传输：30
* 1
  * 寻道：80
  * 旋转：30
  * 传输：30

以及恕我无法理解学长答案。他给出的计算结果是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>SSFT策略：</p>
<ul>
<li>10
<ul>
<li>磁道不变</li>
<li>旋转：105</li>
<li>传输：30</li>
</ul>
</li>
<li>1
<ul>
<li>磁道不变</li>
<li>旋转：90</li>
<li>传输：30</li>
</ul>
</li>
<li>12
<ul>
<li>寻道：40</li>
<li>旋转：330</li>
<li>传输：30</li>
</ul>
</li>
<li>24
<ul>
<li>寻道：40</li>
<li>旋转：360</li>
<li>传输：30</li>
</ul>
</li>
</ul>
<p>经过查证，我发现这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。但是我认为程序说明自相矛盾，无法理解。<br />
–&gt;</p>
<p>2018.5.25 UPD：（感谢zp、wj等人关于这道题的讨论）</p>
<p>这个题目用的似乎是OSTEP中的模拟程序（<a href="https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8">https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8</a>）。事实上，需要注意的一点是：磁盘在旋转过程中可以进行寻道。</p>
<p>FIFO策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td><img src="disk-fifo-1.png" alt="" /></td>
</tr>
<tr>
<td>12</td>
<td>30</td>
<td>40</td>
<td>30</td>
<td>70</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>320</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>30</td>
<td>80</td>
<td>30</td>
<td>110</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>SSFT策略：</p>
<table>
<thead>
<tr>
<th>请求</th>
<th>旋转时间</th>
<th>寻道时间</th>
<th>传输时间</th>
<th>总时间</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>105</td>
<td>0</td>
<td>30</td>
<td>135</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>60</td>
<td>0</td>
<td>30</td>
<td>90</td>
<td>-</td>
</tr>
<tr>
<td>12</td>
<td>300</td>
<td>40</td>
<td>30</td>
<td>330</td>
<td>-</td>
</tr>
<tr>
<td>24</td>
<td>330</td>
<td>40</td>
<td>30</td>
<td>360</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>这个答案仍然和学长给出的不尽相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REQUESTS [&apos;10&apos;]</span><br><span class="line">Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135</span><br><span class="line">Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420</span><br><span class="line">Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360</span><br><span class="line">Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390</span><br></pre></td></tr></table></figure>
<p>可能之后有时间的时候还需要进行分析吧。</p>
-->
        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2017-final-exam-analysis/">
              
                  《操作系统》2017年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-22
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring/FinalExam" target="_blank" rel="noopener">2017年春季学期操作系统课期末考试</a>。</p>
<h2 id="填空题30分"><a class="markdownIt-Anchor" href="#填空题30分"></a> 填空题（30分）</h2>
<p>同学们认真完成了从lab0～lab8的所有实验，在实验实践过程中了解和学到了很多知识。下面是他们从最开始到近期的实验心得，请补充完整。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3>
<p>lab0: 小强发现完成实验需要在Linux下操作很多命令行工具，于是他认真学习了 lab0中的知识，了解到Linux中在命令行模式下可以通过执行命令(<strong>1.1</strong>)来显示当前目录的文件，如果编写的程序有语法错误，编译器(<strong>1.2</strong>)会报错，根据错误信息，可以修改程序，并可以通过硬件模拟器工具(<strong>1.3</strong>)来执行 ucore 操作系统。</p>
<ol>
<li>ls</li>
<li>gcc</li>
<li>qemu</li>
</ol>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3>
<p>lab1: 小晔在bootloader的代码中添加了一条打印语句，但发现编译生成lab项目出错，原来在ucore中只要bootloader的执行代码段+数据段的长度超过了(<strong>2.1</strong>)字节，就无法形成合法有效的bootloader。开始写实验报告时，本来准备提交MS Word文档格式的实验报告，但仔细看过实验报告的提交要求，原来实验指导书中明确要求同学用(<strong>2.2</strong>)文档格式来提交实验报告，小晔之前没学过这个文档格式，不过上网一查，花很短时间就掌握了编写方法，迅速完成了lab1。</p>
<ol>
<li><del>446</del>510</li>
<li>Markdown</li>
</ol>
<hr>
<p>根据<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95</a>，主引导扇区中代码区的大小最多为446字节。</p>
<p>2018.5.24 UPD：经过tsz同学的提醒，我查证了一下<code>lab1/tools/sign.c</code>（用于生成磁盘主引导扇区的代码），发现里面是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line"><span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(ifp);</span><br><span class="line">buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br></pre></td></tr></table></figure>
<p>所以虽然维基说的没问题，但是ucore没有管什么“标准MBR分区表规划”，直接把<code>0x55AA</code>之外的510字节全用上了。</p>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3>
<p>lab2: 小晖需要了解x86的内存大小与布局，页机制，页表结构等。硬件模拟器提供了 128MB的内存，并设定一个页目录项（PDE）占用(<strong>3.1</strong>)个Byte，一个页表项（PTE）占用(<strong>3.2</strong>)个 Byte。在lab2中可通过(<strong>3.3</strong>)和(<strong>3.4</strong>)两种方式获取系统内存大小，并且由于空闲的RAM空间不连续，所以bootloader简化处理，从物理内存地址(<strong>3.5</strong>)起始填充ucore os kernel的代码段和数据段。在ucore建立完页表并进入页模式后，ucore代码段的起始物理地址对应的虚拟地址为(<strong>3.6</strong>)。</p>
<ol>
<li>4</li>
<li>4</li>
<li>BIOS中断调用</li>
<li>直接探测</li>
<li>0x00100000</li>
<li>0xC0100000</li>
</ol>
<hr>
<p>这块不愧是令人比较困惑。我可能需要复习一下ucore的内存映射方式了。</p>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3>
<p>lab3: 小彤发现ucore在完成页机制建立后，内核某内存单元的虚拟地址va为 0xC2345678，且此时硬件模拟器模拟的的cr3寄存器的值为0x221000，则此va对应的页目录表的起始物理地址是(<strong>4.1</strong>)，此va对应的PDE的物理地址是(<strong>4.2</strong>)。如果一个页（4KB/页）被置换到了硬盘某8个连续扇区（0.5KB/扇区），该页对应的页表项（PTE）的最低位–present 位应该为(<strong>4.3</strong>) ，表示虚实地址映射关系不存在，而原来用来表示页帧号的高(<strong>4.4</strong>)位，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。</p>
<ol>
<li>0x00221000</li>
<li>0x00221C20</li>
<li>0</li>
<li>20</li>
</ol>
<hr>
<p>该va对应的页号和偏移量：</p>
<ul>
<li>0xC2345678 = b11000010001101000101011001111000</li>
<li>页目录号 = b1100001000 = 0x308</li>
<li>页表号 = b1101000101 = 0x345</li>
<li>偏移量 = b011001111000 = 0x678</li>
</ul>
<p>PDE地址 = CR3 + 4*页目录号 = 0x00221000 + 0xC20 = 0x00221C20</p>
<h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3>
<p>lab4: 小颖在理解进程管理中，仔细分析了ucore源码中的进程控制块数据结构(<strong>5.1</strong>)，且其中的关键域（也称field，字段）数据结构(<strong>5.2</strong>)用于保存被中断打断的运行现场，关键域数据结构(<strong>5.3</strong>)用于进行进程/线程上下文切换的保存与回复。</p>
<ol>
<li><code>proc_struct</code></li>
<li><code>trap_frame</code></li>
<li><code>context</code></li>
</ol>
<h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h3>
<p>lab5: 小辰对用户进程的创建有了更深入的了解：用户进程在用户态下执行时，CS 段寄存器最低第两位的值为(<strong>6.1</strong>)。当ucore os kernel建立完毕第一个用户进程的执行环境后，通过执行x86机器指令(<strong>6.2</strong>)后，将从内核态切换到用户态，且将从用户进程的第一条指令处继续执行。当用户进程执行sys_exit系统调用后，ucore会回收当前进程所占的大部分资源，并把当前进程的状态设置为(<strong>6.3</strong>)。</p>
<ol>
<li>3</li>
<li>IRET</li>
<li>ZOMBIE</li>
</ol>
<hr>
<p>用户态下，CS段的RPL的值应该为3.</p>
<h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h3>
<p>lab6: 小磊通过阅读代码，了解了ucore的调度框架和RR调度算法等，体会到调度本质上体现了对(<strong>7.1</strong>)资源的抢占，操作系统通过(<strong>7.2</strong>)来避免用户态进程长期运行，并获得控制权。</p>
<ol>
<li>处理机执行能力（时间片？）</li>
<li>时钟中断</li>
</ol>
<hr>
<p>之所以1的回答是“处理机执行能力”，主要是因为第15讲里说，“处理机调度是管理处理机执行能力的资源”。我觉得答CPU之类的也可以。</p>
<h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h3>
<p>lab7: 小航发现课本中阐述的同步互斥原理对实现细节简化了很多。在ucore中，通过利用x86机器指令(<strong>8.1</strong>)简洁地实现了入临界区代码，通过利用x86指令(<strong>8.2</strong>)简洁地实现了出临界区代码。通过分析ucore中管程的数据结构，可知道ucore中的管程机制是基于(<strong>8.3</strong>)机制和(<strong>8.4</strong>)机制来实现的。</p>
<ol>
<li>CLI</li>
<li>STI</li>
<li>信号量</li>
<li>等待队列</li>
</ol>
<hr>
<p>有时候分不清楚CLI和STI。事实上，CLI的意思是“Clean IF”，即将IF置零，屏蔽中断；STI的意思是“Set IF”，即将IF置1，不屏蔽中断。姑且这样记一下吧。</p>
<h3 id="9"><a class="markdownIt-Anchor" href="#9"></a> 9</h3>
<p>lab8: 小行了解到ucore中的文件系统架构包含四类主要的数据结构， (<strong>9.1</strong>)：它主要从文件系统的全局角度描述特定文件系统的全局信息。 (<strong>9.2</strong>)：它主要从文件系统中单个文件的角度描述了文件的各种属性和数据所在位置。 (<strong>9.3</strong>)：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。 (<strong>9.4</strong>)： 它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。</p>
<ol>
<li>超级块（SuperBlock）</li>
<li>索引节点（inode）</li>
<li>目录项（dentry）</li>
<li>文件（file）</li>
</ol>
<hr>
<p>Lab8中的各种结构好多，完全不知道该回答什么啊。</p>
<p>2018.5.24 UPD：今天tsz同学提醒我，这个问题是实验指导书中的原话<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<blockquote>
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构，它们分别是：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从文件系统的单个文件的角度描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。它的作用范围是整个OS空间。</li>
<li>文件（file）：它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
</blockquote>
<h2 id="问答题70分"><a class="markdownIt-Anchor" href="#问答题70分"></a> 问答题（70分）</h2>
<h3 id="10-同步互斥10分"><a class="markdownIt-Anchor" href="#10-同步互斥10分"></a> 10. 同步互斥（10分）</h3>
<p>下面列出的n个线程互斥机制的伪代码实现有误，请指出错误处，给出错误原因分析，描述错误会带来的后果（即给出反例：无法正确执行n线程有效互斥运行行为的执行序列）。最后请修正错误，使得伪代码正确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared <span class="keyword">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = <span class="number">0</span>;</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<hr>
<p>这道题和<a href="/post/os-mooc-2016-final-exam-analysis">2016年期末</a>的26.2题几乎一模一样，唯一的区别是此处初始化时将<code>num[j]</code>初始化为<code>j</code>，而不是<code>0</code>。这一点显然违背了“空闲则入”的原则：假如线程<code>n-1</code>想要进入临界区，它必须等待编号比它小的线程全部进入过临界区，这可能会导致饥饿，所以还是应该初始化为<code>0</code>。因此，在线程i执行ENTRY PROTOCOL之前，<code>num[i]</code>必然为0。</p>
<p>在我的理解中，共享数组<code>num[n]</code>有两个含义：</p>
<ul>
<li><code>num[i] &gt; 0</code>表示线程i正在等待或已经进入临界区；<code>num[i] = 0</code>表示线程i离开了临界区且并没有等待进入临界区</li>
<li><code>num[i] &gt; 0</code>时，表示线程i等待的优先级，数字越大，优先级越低</li>
</ul>
<p>基于以上的讨论，我认为，<code>num</code>数组中非0的值必须是互不相同的。从ENTRY PROTOCOL的实现可以看出，如果<code>num[i] = MAX(num[0], ..., num[n-1]) + 1</code>这一操作是原子的，则上述结论显然；如果这一操作不是原子的，则可能会出现两个线程i和j的优先级相同的情况。不妨设i&lt;j，且其他线程的<code>num</code>均为0。假如线程i在<code>num[i]</code>没有完成赋值之前被打断，切换到线程j，则j会发现其他线程的<code>num</code>均为0，于是进入临界区。之后切换回线程i，i检查时虽然发现<code>num[i] == num[j]</code>，但由于<code>i &lt; j</code>，于是也进入临界区，破坏了“忙则等待”要求。</p>
<p>假如能够保证<code>num[i] = MAX(num[0], ..., num[n-1]) + 1</code>这一操作是原子的，则上述实现是正确的，且可以删去<code>(num[j] == num[i]) &amp;&amp; (j &lt; i)</code>这一判断条件。在检查条件过程中被打断并不会影响算法的正确性，因为，即使已经被检查过的线程的优先级发生了变化，它也只可能变成0（它不再进入临界区，没有影响）或者优先级比当前线程变得更大（它退出临界区之后又想重新进入，需要取max），不需要重新进行等待。</p>
<p>但是现在的问题是怎么实现取max操作的原子性。如果直接加个互斥锁，不免太过智熄。（那我们还实现软件方法的N线程互斥干啥……）那就直接加个共享变量作为自旋锁好了，而且需要保证赋值过程是原子的。……虽然这样也完全没有意义，难道要直接改成Eisenberg &amp; McGuire算法么……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared <span class="keyword">int</span> num[n];</span><br><span class="line">    shared <span class="keyword">bool</span> choose[n];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;  <span class="comment">// do this atomically</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = <span class="number">0</span>;</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>
<p>2018.5.24 UPD：tsz同学给出了一种想法，我还没有仔细思考过它的正确性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------</span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    num[i] = MAX(num[<span class="number">0</span>], ..., num[n<span class="number">-1</span>]) + <span class="number">1</span>;  <span class="comment">// do this atomically</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num[j] &gt; <span class="number">0</span>) &amp;&amp; ((num[j] &lt; num[i]) || (num[j] == num[i]) &amp;&amp; (j &lt; i)) || flag[j] &amp;&amp; (j &lt; i)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[j] &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-管程10分"><a class="markdownIt-Anchor" href="#11-管程10分"></a> 11. 管程（10分）</h3>
<p>下面是一类管程机制的实现伪代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENTATION:</span><br><span class="line">monitor mt &#123;</span><br><span class="line">    -----variable in monitor-----------</span><br><span class="line">    semaphore mutex;</span><br><span class="line">    semaphore next;</span><br><span class="line">    <span class="keyword">int</span> next_count;</span><br><span class="line">    condvar &#123;<span class="keyword">int</span> count, sempahore sem&#125; cv[N];</span><br><span class="line">    other shared variables in mt;</span><br><span class="line">    ----condvar wait implementation----</span><br><span class="line">    cond_wait (cv) &#123;</span><br><span class="line">        cv.count ++;</span><br><span class="line">        <span class="keyword">if</span>(mt.next_count&gt;<span class="number">0</span>)</span><br><span class="line">            V(mt.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(mt.mutex);</span><br><span class="line">        P(cv.sem);</span><br><span class="line">        cv.count --;</span><br><span class="line">    &#125;</span><br><span class="line">    ----condvar signal implementation----</span><br><span class="line">    cond_signal(cv) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            mt.next_count ++;</span><br><span class="line">            V(cv.sem);</span><br><span class="line">            P(mt.next);</span><br><span class="line">            mt.next_count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ----routine examples in monitor----</span><br><span class="line">    Routines_in_mt () &#123;</span><br><span class="line">        P(mt.mutex);</span><br><span class="line">        real bodies of routines, may access shared variables, call cond_wait OR cond_signal</span><br><span class="line">        <span class="keyword">if</span>(next_count&gt;<span class="number">0</span>)</span><br><span class="line">        V(mt.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        V(mt.mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述伪码中，如果有3个线程a,b,c需要访问管程，并会使用管程中的2个条件变量 cv[0],cv[1]。请问cv[i]-&gt;count含义是什么？cv[i]-&gt;count是否可能&lt;0, 是否可能&gt;1？请说明原因，并给出相应的3个线程同步互斥执行实例和简要解释。请问 mt-&gt;next_count含义是什么？mt-&gt;next_count是否可能&lt;0, 是否可能&gt;1？请说明原因，并给出相应的3个线程同步互斥执行过程实例和简要解释。</p>
<hr>
<p>这道题和<a href="/post/os-mooc-2016-final-exam-analysis">2016年期末</a>的27题一模一样，连笔误都一样，不解释了。</p>
<h3 id="12-理发师问题20分"><a class="markdownIt-Anchor" href="#12-理发师问题20分"></a> 12. 理发师问题（20分）</h3>
<p>理发店里有m位理发师、m把理发椅和n把供等候理发的顾客坐的椅子。理发师为一位顾客理完发后，查看是否有顾客等待，如有则唤醒一位为其理发；如果没有顾客，理发师便在理发椅上睡觉。一个新顾客到来时，首先查看理发师在干什么，如果理发师在理发椅上睡觉，他必须叫醒理发师，然后理发师理发，顾客被理发；如果理发师正在理发，则新顾客会在有空椅子可坐时坐下来等待，否则就会离开。请用信号量机制实现理发师问题的正确且高效的同步与互斥活动：请说明所定义的信号量的含义和初始值，描述需要进行互斥处理的各种行为，描述需要进行同步处理的各种行为；要求用类C语言的伪代码实现，并给出必要的简明代码注释。</p>
<hr>
<p>感觉这个的初步实现到处都是，比如<a href="http://whatbeg.com/2017/03/06/semaphore.html#%E9%97%AE%E9%A2%988%EF%BC%9A%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">http://whatbeg.com/2017/03/06/semaphore.html#问题8：理发师问题</a>。但是我现在都要困死了，实在思考不了这种高思维含量的东西。</p>
<p>2018.5.24 UPD：今天tsz同学给出了一种做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waitCnt &gt; n)</span><br><span class="line">        <span class="keyword">return</span> FAIL;</span><br><span class="line">    waitLock.P();</span><br><span class="line">    waitCnt++;</span><br><span class="line">    waitLock.V();</span><br><span class="line">    waitList.P();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// haircut</span></span><br><span class="line"></span><br><span class="line">    waitLock.P();</span><br><span class="line">    waitCnt--;</span><br><span class="line">    waitLock.V();</span><br><span class="line">    <span class="keyword">return</span> SUCCEED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Barber</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Barber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (waitCnt == <span class="number">0</span>);</span><br><span class="line">        waitList.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我还没有仔细想过这个做法的正确性。</p>
<h3 id="13-spn算法8分"><a class="markdownIt-Anchor" href="#13-spn算法8分"></a> 13. SPN算法（8分）</h3>
<p>请给出平均周转时间的定义，请给出短进程优先算法的描述，请证明：短进程优先算法具有最小平均周转时间。</p>
<hr>
<ul>
<li>周转时间：进程从初始化到结束（包括等待）的总时间</li>
<li>平均周转时间：所有进程周转时间的平均数</li>
<li>短进程优先（SPN）算法：总是选择就绪队列中执行时间最短的进程占用CPU进入运行状态</li>
</ul>
<p>证明：<br>
假设就绪队列中共有N个进程，它们的执行时间分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">t_1, t_2, ..., t_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><msub><mi>t</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">t_1 \leq t_2 \leq ... \leq t_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则SPN算法的总周转时间为</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>T</mi><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><msub><mi>t</mi><mn>3</mn></msub><mo>)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub><mo>)</mo><mo>=</mo><mi>N</mi><mo>∗</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T = t_1 + (t_1 + t_2) + (t_1 + t_2 + t_3) + ... + (t_1 + t_2 + ... + t_N) = N * t_1 + (N-1) * t_2 + ... + t_N
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<p>假设我们交换了第i和j（i&lt;j）个进程的执行顺序，则此时，总周转时间会变为</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>=</mo><mi>N</mi><mo>∗</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><msub><mi>t</mi><mi>N</mi></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T&#x27; = N * t_1 + (N-1) * t_2 + ... + (N-i+1) * t_j + ... + (N-j+1) * t_i + t_N
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><msup><mi>T</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>−</mo><mi>T</mi><mo>=</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msub><mi>t</mi><mi>j</mi></msub><mo>=</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>)</mo><mo>∗</mo><mo>(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mi>j</mi></msub><mo>)</mo><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}
T&#x27; - T = (N-i+1) * t_j + (N-j+1) * t_i - (N-i+1) * t_i - (N-j+1) * t_j = (i-j) * (t_i - t_j) &gt;= 0
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">&gt;</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span>
<p>由于任何进程执行顺序都可以通过对顺序排列的进程进行若干次交换而得到，上述证明表明，任何其他执行顺序得到的平均周转时间都不可能比SPN算法更优。因此，SPN算法具有最小平均周转时间。</p>
<h3 id="14-lfu算法14分"><a class="markdownIt-Anchor" href="#14-lfu算法14分"></a> 14. LFU算法（14分）</h3>
<p>LFU是最近最不常用页面置换算法(Least Frequently Used)，小白听到两个LFU定义的说法，有些糊涂：</p>
<ol>
<li>采用LFU算法的OS在碰到进程访问的物理内存不够时，换出进程执行期内被访问次数最少的内存页，当此页被换出后，其访问次数n会被记录下来，当此页被再次访问并被换入时，此页的访问次数为n+1。</li>
<li>采用LFU算法的OS在碰到进程访问的物理内存不够时，换出进程执行期内被访问次数最少的内存页，当此页被换出后，其访问次数清零，当此页被再次访问并被换入时，此页的访问次数为1。</li>
</ol>
<p>请问你认为那种LFU的定义是正确的？请分别回答第一种/第二种LFU定义是否有Belady 异常现象。如没有，请给出证明，如有，请给出会引起Belady异常现象的的页数/页帧数设置以及访问序列。</p>
<hr>
<p>呃，我不会啊……但我认为做法1显然不太可取。LFU算法比较严重的一个问题是计数器的劣化（这个名字是我随便起的）：之前被大量访问，但以后不再被使用的页不容易被换出。为了解决这个问题，计数器可以定期右移之类的。现在页计数器根本不会减小，怕不是要出事……不过被换出的页大概被访问次数是很少的，所以我也不知道1有什么用。</p>
<p>2大概有Belady现象。1不知道。看来需要仔细研究一下Piazza上给出的例子了。</p>
<p>2018.5.24 UPD：<br>
今天zp同学提醒我，<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1031" target="_blank" rel="noopener">Piazza</a>上有一个帖子讨论了这一内容。我们一般说的LFU的定义是第2种，而非第1种；该帖子指出，第1种定义下LFU不会出现Belady问题（虽然没有给出证明），而第2种定义下LFU会出现Belady问题，并举出了例子。</p>
<p>令访问序列为[0 0 1 1 1 2 2 0 0 2 2 3 1 3 1 3 1 3 1 3 1 3 1 … （之后无限循环3 1 3 1）]。在有2个物理页帧的情况下，访问过程是这样的（括号里是访问计数）：</p>
<table>
<thead>
<tr>
<th>访存</th>
<th>物理页a</th>
<th>物理页b</th>
<th>缺页</th>
<th>换出</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0(1)</td>
<td>-</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(1)</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2(1)</td>
<td>1(3)</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(1)</td>
<td>1(3)</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>2(1)</td>
<td>1(3)</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(1)</td>
<td>1(3)</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3(1)</td>
<td>1(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(2)</td>
<td>1(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>3(2)</td>
<td>1(5)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>3(3)</td>
<td>1(5)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>3(3)</td>
<td>1(6)</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>可以看出，一共只会缺页6次，在之后的循环过程中不会缺页。</p>
<p>但是，如果物理页帧数量增加到3，访问过程会变成这样：</p>
<table>
<thead>
<tr>
<th>访存</th>
<th>物理页a</th>
<th>物理页b</th>
<th>物理页c</th>
<th>缺页</th>
<th>换出</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0(1)</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(1)</td>
<td>-</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(2)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>0(2)</td>
<td>1(3)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(2)</td>
<td>1(3)</td>
<td>2(1)</td>
<td>2</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(2)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(3)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(2)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>0(4)</td>
<td>1(3)</td>
<td>2(4)</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>0(4)</td>
<td>3(1)</td>
<td>2(4)</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0(4)</td>
<td>1(1)</td>
<td>2(4)</td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>可以看出，现在已经缺页9次了，而且之后每访问一次都会发生缺页。</p>
<p>上述讨论可以说明一般的LFU算法有Belady问题。那么为什么修改过的（有记忆的）LFU算法可以没有Belady问题呢？<a href="https://stackoverflow.com/questions/21289990/does-the-lfu-page-reclamation-algorithm-suffer-from-beladys-anomaly" target="_blank" rel="noopener">stackoverflow</a>上是这么说的：</p>
<blockquote>
<p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-358.pdf" target="_blank" rel="noopener">http://www.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-358.pdf</a> section 1.3 defines the stack algorithm and finishes by working through an example of this for LFU. Basically you can maintain a stack as you follow through a trace of memory fetches such that the top i entries of the stack are the entries that will be held in memory if you have capacity for i entries in your memory. Since you can maintain such a stack a larger memory must always hold all of the entries kept in core for any smaller memory and so Belady’s anomaly is not possible.<br>
Of course this assumes an exact implementation of LFU with counters of infinite capacity.</p>
</blockquote>
<p>上面的内容大概是说，修改过的LFU算法实际上相当于维护了一个很大的访问次数栈，栈中的页按访问次数排序，顶端的N个页驻留在内存中。因此，它本质上是一种栈算法，所以不存在Belady问题。具体证明我现在没时间去看了，欢迎大家自己去看论文。</p>
<h3 id="15-小明文件系统8分"><a class="markdownIt-Anchor" href="#15-小明文件系统8分"></a> 15. 小明文件系统（8分）</h3>
<p>小明为更好理解lab8，设计了一个简化文件系统Xiao Miang File System, 简称 xmfs。</p>
<p><strong>xmfs的系统调用接口包括：</strong></p>
<ul>
<li>mkdir() - 创建一个新目录</li>
<li>creat() - 创建一个空文件</li>
<li>open(), write(), close() - 打开文件，写文件，关闭文件</li>
<li>link() - 对文件创建一个硬链接（ hard link）</li>
<li>unlink() - 对文件取消一个硬链接 (如果文件的链接数为0，则删除文件）</li>
<li><strong>注意</strong>：通过 write()对文件写一个数据buffer时，常规文件的最大size是一个 data block，所以第二次写（写文件的语义是在上次写的位置后再写一个data block）会报错（文件大小满了）。如果data block 也满了，也会报错。</li>
</ul>
<p><strong>xmfs在硬盘上的总体组织结构如下：</strong></p>
<ul>
<li>superblock：记录可用inode数量，可用data block数量</li>
<li>inode bitmap：已用/空闲inode的分配图（基于bitmap）</li>
<li>inodes：inode的存储区域</li>
<li>data bitmap：data block的分配图（基于bitmap）</li>
<li>data：data block的存储区域</li>
</ul>
<p><strong>xmfs的关键数据结构–inode数据结构如下：</strong></p>
<ul>
<li>inode：包含3个fields（file type，data block addr of file content，reference count）,用list表示：</li>
<li>file type: f -&gt; 常规文件： regular file, d -&gt; 目录文件： directory</li>
<li>data block addr of file content: -1 -&gt; file is empty</li>
<li>reference count: file/directory 的引用计数，注意directory的引用计数是指在此目录中的inode的个数</li>
<li><strong>注意</strong>：比如，刚创建的一个空文件inode：[f a:-1 r:1]，一个有1个硬链接的文件inode：[f a:10 r:2]</li>
</ul>
<p><strong>xmfs的关键数据结构–数据块（data block）结构如下：</strong></p>
<ul>
<li>一般文件的内容表示：只是包含单个字符的 list，即占一个 data block，比如[‘a’], [‘b’] …</li>
<li>目录的内容表示：多个两元组（name, inode_number）形成的list，比如，根目录 [(.,0) (…,0)]，或者包含了一个’f’文件的根目录[(.,0) (…,0) (f,1)]。</li>
<li><strong>注意</strong>：一个目录的目录项的个数是有限的。block.maxUsed = 32</li>
<li><strong>注意</strong>：data block 的个数是有限的,为fs.numData</li>
<li><strong>注意</strong>：inode 的个数是有限的,为fs.numInodes</li>
</ul>
<p><strong>完整xmfs文件系统的参考实例：</strong></p>
<p>fs.ibitmap: inode bitmap 11110000<br>
fs.inodes: [d a:0 r:5] [f a:1 r:1] [f a:-1 r:1] [d a:2 r:2] [] …<br>
fs.dbitmap: data bitmap 11100000<br>
fs.data: [(.,0) (…,0) (y,1) (z,2) (x,3)] [u] [(.,3) (…,0)] [] …</p>
<p><strong>对上述xmfs参考实例的解释</strong>：有8个inode空间,8个data blocks.其中，根目录包含5个目录项，“.”，“…”，“y”，“z”，“x”。而“y”是常规文件,并有文件内容，包含一个data block，文件内容为“u”。“z”是一个空的常规文件。“x”是一个目录文件，是空目录。</p>
<p><strong>如果xmfs初始状态为：</strong><br>
<em>inode bitmap 10000000</em><br>
inodes [d a:0 r:2] [] [] [] [] [] [] []<br>
data bitmap 10000000<br>
data [(.,0) (…,0)] [] [] [] [] [] [] []</p>
<p>在执行了系统调用mkdir(&quot;/t&quot;)后，<strong>xmfs的当前状态为：</strong><br>
<em>inode bitmap 11000000</em><br>
inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1)] [(.,1) (…,0)] [] [] [] [] [] []</p>
<p>请问接下来的4个状态变化所对应系统调用是什么？ 要求回答格式象上面“mkdir(&quot;/t&quot;)”一样。</p>
<p>（1）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:2] [f a:-1 r:1] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0)] [] [] [] [] [] []</p>
<p>（2）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:3] [f a:-1 r:2] [] [] [] [] []<br>
data bitmap 11000000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0) (c,2)] [] [] [] [] [] []</p>
<p>（3）<br>
<em>inode bitmap 11100000</em><br>
inodes [d a:0 r:4] [d a:1 r:3] [f a:2 r:2] [] [] [] [] []<br>
data bitmap 11100000<br>
data [(.,0) (…,0) (t,1) (y,2)] [(.,1) (…,0) (c,2)] [o] [] [] [] [] []</p>
<p>（4）<br>
<em>inode bitmap 11110000</em><br>
inodes [d a:0 r:5] [d a:1 r:3] [f a:2 r:2] [d a:3 r:2] [] [] [] []<br>
data bitmap 11110000<br>
data [(.,0) (…,0) (t,1) (y,2) (v,3)] [(.,1) (…,0) (c,2)] [o] [(.,3) (…,0)] [] [] [] []</p>
<hr>
<ol>
<li>create(&quot;/y&quot;)</li>
<li>link(&quot;/y&quot;, “/t/c”)</li>
<li>fd=open(&quot;/y&quot;), write(fd), close(fd)</li>
<li>mkdir(&quot;/v&quot;)</li>
</ol>
<p>这道题的形式非常类似于<a href="/post/os-mooc-final-exam-analysis">MOOC上的期末试题</a>中的第20题。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://objectkuan.gitbooks.io/ucore-docs/lab8/lab8_3_1_ucore_fs_introduction.html" target="_blank" rel="noopener">uCore Lab Documents - ucore 文件系统总体介绍 - ucore文件系统总体结构</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-final-exam-analysis/">
              
                  《操作系统》MOOC期末考试题分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-20
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>以下内容来自学堂在线《操作系统》在线课程的期末考试。因为只有单选题，所以没有什么难的。</p>
<hr>
<ol>
<li>某基于动态分区存储管理的计算机系统，其主存容量为55MB（初始为空），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB，分配30MB，释放15MB，分配8MB，分配7MB，则此时主存中最大空闲分区的大小是（ ）</li>
</ol>
<ul>
<li>7MB</li>
<li><strong>8MB</strong></li>
<li>9MB</li>
<li>10MB</li>
</ul>
<p>分配过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|----------------55MB--------------------|</span><br><span class="line">|===15MB====|---------40MB---------------|</span><br><span class="line">|===15MB====|======30MB======|---10MB----|</span><br><span class="line">|---15MB----|======30MB======|---10MB----|</span><br><span class="line">|---15MB----|======30MB======|=8MB=|-2MB-|</span><br><span class="line">|=7MB=|-8MB-|======30MB======|=8MB=|-2MB-|</span><br></pre></td></tr></table></figure>
<p><strong>EXPLANATION</strong></p>
<p>下面是分配过程的表示。<br>
0： 55<br>
15： (15), 40<br>
30： (15), (30), 10<br>
~15: 15, (30), 10<br>
8: 15, (30), (8), 2<br>
7: (7), 8, (30), (8), 2</p>
<hr>
<ol start="2">
<li>在一个采用单地址方案（逻辑地址与物理地址是一一对应的）的分段存储系统中，内存地址长度为32位，其中段号占10位，则最大段长为（ ）</li>
</ol>
<ul>
<li>2^8字节</li>
<li>2^14字节</li>
<li><strong>2^22字节</strong></li>
<li>2^24字节</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>在段访问机制中，如果采用的是单地址方案，则段号的位数+段内偏移的位数=地址长度，所以段内偏移占了32 - 10 = 22 比特。</p>
<hr>
<ol start="3">
<li>某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2<sup>10字节，页表项大小为4字节，逻辑地址结构为“|一级页号|二级页号|页内偏移量|”，逻辑地址空间大小为2</sup>16页，则表示整个逻辑地址空间的一级页表中包含表项的个数至少为（ ）</li>
</ol>
<ul>
<li>64</li>
<li>128</li>
<li><strong>256</strong></li>
<li>512</li>
</ul>
<p>由于逻辑地址空间大小为2<sup>16页，页大小为2</sup>10字节，因此逻辑地址总长度为26，其中页内偏移量长度为10。我猜测一张页表最多占满一页，所以最多能够包含2<sup>10/4=2</sup>8=256个页表项。事实上，2<sup>8*2</sup>8恰好等于2^16（页），因此其实只有一种分配方法，就是一级页号长度=二级页号长度=8，每张页表都有256个页表项。</p>
<p><strong>EXPLANATION</strong></p>
<p>页大小为2<sup>10B，页表项大小为4B，一页可以存放2</sup>8个页表项，逻辑地址空间大小为2<sup>16页，需要2</sup>16个页表项，需要2<sup>16/2</sup>8 = 2^8 = 256个表项保存页表项。所以页目录表中包含的表项至少为256</p>
<hr>
<ol start="4">
<li>在CPU中具有TLB和高速缓存(CACHE)的分页式存储管理系统中时，每次CPU取指令或取操作数，至少要访问（）次主存</li>
</ol>
<ul>
<li><strong>0</strong></li>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<p>一般取指令或取操作数需要经过以下过程：</p>
<ul>
<li>查TLB
<ul>
<li>TLB miss
<ul>
<li>从CR3寄存器中读出一级页表基地址，在一级页表中查出二级页表基地址</li>
<li>在二级页表中查出页帧物理地址
<ul>
<li>如果该页在内存中则直接查到</li>
<li>否则发生Page Fault，将对应页换入，重新执行上述过程</li>
</ul>
</li>
</ul>
</li>
<li>TLB hit
<ul>
<li>直接得到虚拟地址对应的物理地址</li>
</ul>
</li>
</ul>
</li>
<li>从物理地址中读数据</li>
</ul>
<p>如果运气好的话，TLB hit，且对应的物理内存块缓存在cache中，则一次主存都不用访问。如果运气坏的话……我也想不起在ucore中最多会访问多少次主存了。</p>
<p><strong>EXPLANATION</strong></p>
<p>0次。因为CPU访问的页表项和要访问的内存单元可能会有缓存在TLB和cache中。</p>
<hr>
<ol start="5">
<li>对于下列3种操作：<br>
（1）整数除以0；<br>
（2）cos数学函数调用；<br>
（3）read系统调用；</li>
</ol>
<p>会导致用户进程从用户态切换到内核态的操作是</p>
<ul>
<li>1、2</li>
<li><strong>1、3</strong></li>
<li>2、3</li>
<li>1、2、3</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>函数调用并不会切换到内核态，而除零操作引发中断，中断和系统调用都会切换到内核态进行相应处理</p>
<hr>
<ol start="6">
<li>在缺页处理过程中，操作系统执行的操作可能是下列操作：<br>
（1）修改页表(page table)<br>
（2）磁盘I/O<br>
（3）分配页框（page frame）<br>
中的（ ）</li>
</ol>
<ul>
<li>仅1、2</li>
<li>仅2、3</li>
<li>仅1、3</li>
<li><strong>1、2、3</strong></li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>如果还有可分配给程序的内存，那么会分配新的页框，修改页表，从磁盘读取内容放入到分配的页框中。</p>
<hr>
<ol start="7">
<li>一个虚拟存储器系统中，主存容量16MB，辅存容量2GB，地址寄存器位数32位。那么虚存最大容量为（ ）</li>
</ol>
<ul>
<li>2GB</li>
<li>16MB</li>
<li>2GB + 16MB</li>
<li><strong>4GB</strong></li>
</ul>
<p>这是常见的障眼法了。群里有人曾经提问过，虚存4GB连主存+辅存都放不下，那怎么能说虚存最大为4GB呢？老师的回答是这样的：虚存大小不会受到硬盘的大小限制，因为这是虚存。因为是虚存，所以实际用到多少鬼知道。而且，甚至可以没有硬盘——比如无盘工作站、分布式系统、透明计算……虚存最后不一定需要对应到实际的物理存储的。所以虚存大小只和地址位数有关。（如果以上内容逻辑混乱，那是因为老师在微信里的回答比较零散。）</p>
<p><strong>EXPLANATION</strong></p>
<p>虚拟存储器的最大容量跟虚拟地址空间有关，是2^32。</p>
<hr>
<ol start="8">
<li>某进程的页面访问顺序为1、3、2、4、2、3、1、2，系统最多分配3个物理页面，那么采用LRU算法时，进程运行过程中会发生（ ）缺页</li>
</ol>
<ul>
<li>三次</li>
<li>四次</li>
<li><strong>五次</strong></li>
<li>六次</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>访问页面</th>
<th>是否缺页</th>
<th>换出</th>
<th>栈顶（MRU）</th>
<th></th>
<th>栈底（LRU）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>是</td>
<td>-</td>
<td>1</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>是</td>
<td>-</td>
<td>3</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>是</td>
<td>-</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>是</td>
<td>1</td>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>否</td>
<td>-</td>
<td>2</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>否</td>
<td>-</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>是</td>
<td>4</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>否</td>
<td>-</td>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>EXPLANATION</strong></p>
<p>解释：1（缺页） - 3（缺页） - 2（缺页） - 4（缺页，换出1） - 2 - 3 - 1（缺页，换出4） - 2</p>
<hr>
<ol start="9">
<li>设两个进程共用一个临界区资源对应的互斥信号量mutex。当一个进程进入了临界区，另一个进程等待时，mutex应该等于多少（）</li>
</ol>
<ul>
<li><strong>-1</strong></li>
<li>0</li>
<li>1</li>
<li>2</li>
</ul>
<p>在一般的实现下，如果信号量的值为负数，则它的相反数=等待进程个数。</p>
<p><strong>EXPLANATION</strong></p>
<p>两个进程共用一个临界区的互斥信号量mutex，那么mutex的取值范围应该是1到-1，1表示没有进程进入临界区并且也没有进程等待，0表示有一个进程进入临界区，-1表示有一个进程进入临界区并且另一个进程等待。</p>
<hr>
<ol start="10">
<li>(1)多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（ ）</li>
</ol>
<ul>
<li>1</li>
<li>2</li>
<li><strong>3</strong></li>
<li>4</li>
</ul>
<ol start="10">
<li>(2)如10.(1)所描述的情况,信号量S的初值是（）</li>
</ol>
<ul>
<li><strong>1</strong></li>
<li>2</li>
<li>3</li>
<li>4</li>
</ul>
<p>等待进程数量为3。初值-6+2=-3，因此初值=1。</p>
<p><strong>EXPLANATION</strong></p>
<p>-3+6-2=1</p>
<hr>
<ol start="11">
<li>用于互斥的二值信号量可以初始化为（）</li>
</ol>
<ul>
<li><strong>0或1</strong></li>
<li>0或-1</li>
<li>只能为1</li>
<li>任意值</li>
</ul>
<p>事实上，用于互斥作用的信号量初值应该置1，用于条件等待作用的信号量初值应该置0。</p>
<p><strong>EXPLANATION</strong></p>
<p>通常操作系统区分计数信号量与二值信号量，二进制信号量的值只能为0或1</p>
<hr>
<ol start="12">
<li>设与某资源关联的信号量Sem初值为4，当前值为2。若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（）</li>
</ol>
<ul>
<li>0、1</li>
<li>1、0</li>
<li>1、2</li>
<li><strong>2、0</strong></li>
</ul>
<p>显然可用个数为2，没有进程在等待。</p>
<p><strong>EXPLANATION</strong></p>
<p>信号量表示当前可用的相关资源数。当信号量Sem&gt;0时，表示还有Sem个相关资源可用；而当信号量Sem&lt;=0时，表示有|Sem|个进程在等待该资源。所以该资源可用数是2，等待该资源的进程数是0。</p>
<hr>
<ol start="13">
<li>有两个并发执行的进程P1和P2，共享初值为1的变量x。加1和减1操作的指令序列分别如下所示。</li>
</ol>
<p>P1：对x执行加一操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load R1,x</span><br><span class="line">inc R1</span><br><span class="line">store R1,x</span><br></pre></td></tr></table></figure>
<p>P2：对x执行减一操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load R2,x</span><br><span class="line">dec R2</span><br><span class="line">store R2,x</span><br></pre></td></tr></table></figure>
<p>两个操作完成后，x的值（ ）</p>
<ul>
<li>可能为-1或3</li>
<li>只能为1</li>
<li><strong>可能为0、1或2</strong></li>
<li>可能为-1、0、1、1或2</li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>依次执行P1-1，P1-2，P1-3，P2-1，P2-2，P2-3，得到的结果是1；依次执行P1-1，P1-2，P2-1，P2-2，P2-3，P1-3，得到的结果是2；依次执行P2-1，P2-2，P1-1，P1-2，P1-3，P2-3得到的结果是0</p>
<hr>
<ol start="14">
<li>资源的有序分配策略可以破坏死锁的（）条件</li>
</ol>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li><strong>循环等待</strong></li>
</ul>
<p><strong>EXPLANATION</strong></p>
<p>资源的有序分配策略属于死锁预防的一种，死锁预防是通过破坏4个必要条件中的1个或者多个以确保系统不会发生死锁。采用资源有序分配法是破坏了“环路”条件，即破坏了循环等待。</p>
<hr>
<ol start="15">
<li>若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此进程的叙述中，正确的是（）</li>
</ol>
<p>I. 若文件的数据不在内存中，则该进程进入睡眠等待状态<br>
II. 请求read系统调用会导致CPU从用户态切到核心态<br>
III. read系统调用的参数应包含文件的名称</p>
<ul>
<li><strong>仅I、II</strong></li>
<li>仅I、III</li>
<li>仅II、III</li>
<li>I、II和III</li>
</ul>
<p>中间做错了，不是D。问题就在于，这个是read调用，不是open调用。</p>
<p><strong>EXPLANATION</strong></p>
<p>对于I，当所读文件的数据不在内存时，产生I/O请求，原进程进入阻塞状态，知道所需数据从外存调入内存后，才将该进程唤醒。对于II，read系统调用通过陷入将CPU从用户态进入核心态，从而获取操作系统提供的服务。对于III，读一个文件首先要用open系统调用打开该文件。open参数包含文件的路径名与文件名，read只需要open返回的文件描述符，不用文件名作为参数。read要求三个输入参数：1文件描述符fd；2buf缓冲区首地址；3传送的字节数n。read的功能试图从fd所指示的文件中读入n个字节的数据，并将它们送到buf所指示的缓冲区中。</p>
<hr>
<ol start="16">
<li>用户删除某文件的过程中，操作系统不可能执行的操作是（）</li>
</ol>
<ul>
<li><strong>删除文件所在的目录</strong></li>
<li>删除与此文件关联的目录项</li>
<li>删除与此文件对应的文件控制块</li>
<li>释放与此文件关联的内存缓冲区</li>
</ul>
<p>这个好像是常识。</p>
<p><strong>EXPLANATION</strong></p>
<p>删除文件不能删除文件所在的目录，而与此文件关联的目录项和文件控制块需要随着文件一同删除，同时释放文件关联的内存缓冲区。</p>
<hr>
<ol start="17">
<li>设文件A的当前引用计数值为1，先建立文件A的符号链接（软链接）文件B，再建立文件A的硬链接C，然后删除文件A。此时，文件B和文件C的引用计数分别是（）</li>
</ol>
<ul>
<li>0,1</li>
<li><strong>1,1</strong></li>
<li>1,2</li>
<li>2,1</li>
</ul>
<p>B是我随便选的，实际上我并不会算引用计数。</p>
<p><strong>EXPLANATION</strong></p>
<p>建立符号链接时，引用计数为1；建立硬链接时，引用计数加1。删除文件时，删除操作对于符号链接是不可见的，这并不影响符号链接文件；当以后通过符号链接访问文件时，发现文件不存在；但对于硬链接删除操作，引用计数值减1，若值大于0，则不会真正删除文件数据，因为还有其他的硬链接或文件索引指向此文件。当建立B时，A和B的引用计数值都为1.当建立C时，A和B的引用计数值分别为2和1。删除A时，C的引用计数值为2-1=1，B的引用计数值不变。</p>
<hr>
<ol start="18">
<li>在多用户操作系统中，某文件占用10个磁盘块，现在要把该文件磁盘块逐个读入主缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓冲区的时间为100μs，将缓冲区的数据传送到用户区的时间是50μs，CPU对一块数据进行分析的时间为50μs。在单缓冲区和双缓冲区结构下，读入并分析完该文件的时间分别是（ ）</li>
</ol>
<ul>
<li>1500μs，1000μs</li>
<li>1550μs，1100μs</li>
<li>1550μs，1550μs</li>
<li>2000μs，2000μs</li>
</ul>
<p>单缓冲区：(100+50) * 10 + 50 = 1550μs</p>
<p>双缓冲区：100 + 100*9 + 50 + 50 = 1100μs</p>
<p><strong>EXPLANATION</strong></p>
<p>单缓冲区下，当上一个磁盘块从缓冲区读入用户区完成时下一磁盘块才能开始读入，所以当最后一块磁盘块读入用户区完毕时，所用时间为150×10＝1500，加上处理最后一个磁盘块的cpu处理时间50，最后结果为1550。</p>
<p>双缓冲区下，读入第一个缓冲区之后可以立刻开始读入第二个缓冲区，读完第二个缓冲区之后，第一个缓冲区的数据已经传送到用户区，因此不存在等待磁盘块从缓冲区读入用户区的问题，也就是100×10＝1000，再加上最后一个缓冲区的数据传输到用户区并有CPU处理的时间50+50=100，总的时间是1000+100=1100。</p>
<hr>
<ol start="19">
<li>假设磁头当前位于第105道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为35，45，12，68，110，180，170，195。采用SCAN调度（电梯调度）算法得到的磁道访问序列是()</li>
</ol>
<ul>
<li><strong>110，170，180，195，68，45，35，12</strong></li>
<li>110，68，45，35，12，170，180，195</li>
<li>110，170，180，195，12，35，45，68</li>
<li>12，35，45，68，110，170，180，195</li>
</ul>
<p>A对应的是SCAN算法（磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道；然后调换方向）</p>
<p>我猜测B对应的是SSTF算法（选择从磁臂当前位置需要移动最少的I/O请求）；C对应的是CLOOK算法（限制仅在一个方向上扫描；当最后一个请求也被访问过了后，磁臂返回到磁盘的另外一端再次进行扫描）；D不知道是啥。</p>
<p><strong>EXPLANATION</strong></p>
<p>SCAN调度算法就是电梯调度算法，顾名思义就是如果开始时磁头往外就一直要到最外面，然后再返回向里（磁头编号一般是最外面为0号往里增加），就像电梯若往下则一直要下到最底层才会再上升一样。</p>
<hr>
<ol start="20">
<li>某操作系统中建立了一个基于索引节点(index node)结构的文件系统very simple file system, 简称vsfs。</li>
</ol>
<p>vsfs的用户操作包括(以函数形式表示):</p>
<ul>
<li>mkdir(“str”) - 创建一个新目录,目录名称为”str”</li>
<li>creat(“str”) - 创建一个空文件,空文件名称为“str”</li>
<li>fd=open(“str”), write(fd), close(fd) – 打开文件”str”,会返回一个整型数fd, 然后对文件写一个buffer,注意常规文件的最大size是一个data block,所以第二次写(写文件的语义是在上次写的位置后再写一个data block)会报错(文件大小满了)。或者如果data block也满了,也会报错。</li>
<li>link(“a1”,”b1”) - 对文件”a1”创建一个硬链接(hard link)文件”b1”</li>
<li>unlink(“b1”) - 对文件“b1”取消一个硬链接,如果文件的链接数为0,则删除此文件</li>
</ul>
<p>vsfs在硬盘上的布局:</p>
<ul>
<li>superblock : 可用inode数量,可用data block数量</li>
<li>inode bitmap : inode的分配图(基于bitmap)</li>
<li>inodes : inode的存储区域</li>
<li>data bitmap : data block的分配图(基于bitmap)</li>
<li>data : data block的存储区域</li>
</ul>
<p>vsfs的关键数据结构:</p>
<ul>
<li>inode数据结构:
<ul>
<li>inode : 包含3个fields, 用 list 表示
<ul>
<li>file type: f -&gt; 常规文件:regular file, d -&gt; 目录文件:directory</li>
<li>data block addr of file content: -1 -&gt; file is empty</li>
<li>reference count: file/directory的引用计数,注意directory的引用计数是指在此目录中的inode的个数</li>
</ul>
</li>
<li>注意:比如,刚创建的一个空文件inode: [f a:-1 r:1], 一个有1个硬链接的文件inode: [f a:10 r:2]</li>
</ul>
</li>
<li>数据块内容结构:
<ul>
<li>一般文件的内容的表示:只是包含单个字符的list,即占一个data block,比如[‘a’], [‘b’] …</li>
<li>目录内容的表示: 多个两元组(name, inode_number)形成的list,比如, 根目录[(.,0) (…,0)], 或者包含了一个’f’文件的根目录[(.,0) (…,0) (f,1)] 。</li>
<li>注意:
<ul>
<li>一个目录的目录项的个数是有限的。 block.maxUsed = 32</li>
<li>data block的个数是有限的,为 fs.numData</li>
<li>inode的个数是有限的,为 fs.numInodes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完整文件系统的例子:</p>
<ul>
<li>fs.ibitmap:      inode bitmap 11110000</li>
<li>fs.inodes:       [d a:0 r:5] [f a:1 r:1] [f a:-1 r:1] [d a:2 r:2] [] …</li>
<li>fs.dbitmap:    data bitmap 11100000</li>
<li>fs.data:           [(.,0) (…,0) (y,1) (z,2) (x,3)] [u] [(.,3) (…,0)] [] …</li>
</ul>
<p>表明: 此文件系统有8个inode空间, 8个data blocks. 其中,根目录包含5个目录项，“.”,“…”,“y”,“z”,“x”。 而“y”是常规文件,并有文件内容,包含一个data block,文件内容为“u”。“z”是一个空的常规文件。“x”是一个目录文件，是空目录。</p>
<p>如果vsfs初始状态为:</p>
<ul>
<li>inode bitmap     10000000</li>
<li>inodes                 [d a:0 r:2] [] [] [] [] [] [] []</li>
<li>data bitmap       10000000</li>
<li>data                     [(.,0) (…,0)] [] [] [] [] [] [] []</li>
</ul>
<p>请问接下来的连续6个状态变化的对应用户操作是什么?据此回答以下6个问题</p>
<hr>
<ol start="20">
<li>(1)</li>
</ol>
<ul>
<li>inode bitmap 11000000</li>
<li>inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li><strong>mkdir(&quot;/c&quot;);</strong></li>
<li>unlink(&quot;/c&quot;);</li>
<li>creat(&quot;/c&quot;);</li>
<li>fd=open(“/c”), write(fd), close(fd)</li>
</ul>
<p>显然多了一个目录。</p>
<p><strong>EXPLANATION</strong></p>
<p>mkdir(&quot;/c&quot;);</p>
<hr>
<ol start="20">
<li>(2)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (h,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/h&quot;);</li>
<li>unlink(&quot;/c/h&quot;);</li>
<li><strong>creat(&quot;/c/h&quot;);</strong></li>
<li>fd=open(“/c/h”), write(fd), close(fd)</li>
</ul>
<p>在c目录下多了一个空文件h。</p>
<p><strong>EXPLANATION</strong></p>
<p>creat(&quot;/c/h&quot;);</p>
<hr>
<ol start="20">
<li>(3)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:4] [f a:-1 r:2] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (h,2) (p,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/p&quot;);</li>
<li>creat(&quot;/c/p&quot;);</li>
<li><strong>link(&quot;/c/h&quot;, “/c/p”);</strong></li>
<li>unlink(&quot;/c/h&quot;);</li>
</ul>
<p>文件<code>/c/h</code>和目录<code>/c</code>的引用记录增加了，<code>/c</code>目录下多了一个<code>p</code>文件。</p>
<p><strong>EXPLANATION</strong></p>
<p>link(&quot;/c/h&quot;, “/c/p”);</p>
<hr>
<ol start="20">
<li>(4)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (p,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/h&quot;);</li>
<li>unlink(&quot;/c/p&quot;);</li>
<li>link(&quot;/c/h&quot;, “/c/p”);</li>
<li><strong>unlink(&quot;/c/h&quot;);</strong></li>
</ul>
<p>文件<code>/c/h</code>和目录<code>/c</code>的引用记录减少了，文件<code>/c/h</code>被删除了。</p>
<p><strong>EXPLANATION</strong></p>
<p>unlink(&quot;/c/h&quot;);</p>
<hr>
<ol start="20">
<li>(5)</li>
</ol>
<ul>
<li>inode bitmap 11000000</li>
<li>inodes [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c&quot;);</li>
<li>unlink(&quot;/c&quot;);</li>
<li>creat(&quot;/c/p&quot;);</li>
<li><strong>unlink(&quot;/c/p&quot;);</strong></li>
</ul>
<p>文件<code>/c/p</code>也被删除了。</p>
<p><strong>EXPLANATION</strong></p>
<p>unlink(&quot;/c/p&quot;);</p>
<hr>
<ol start="20">
<li>(6)</li>
</ol>
<ul>
<li>inode bitmap 11100000</li>
<li>inodes [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [] [] [] [] []</li>
<li>data bitmap 11000000</li>
<li>data [(.,0) (…,0) (c,1)] [(.,1) (…,0) (f,2)] [] [] [] [] [] []</li>
</ul>
<p>对应用户操作是（ ）</p>
<ul>
<li>mkdir(&quot;/c/f&quot;);</li>
<li><strong>creat(&quot;/c/f&quot;);</strong></li>
<li>link(&quot;/c&quot;,&quot;/c/f“);</li>
<li>fd=open(“/c/f”), write(fd), close(fd)</li>
</ul>
<p>新建了一个文件f。</p>
<p><strong>EXPLANATION</strong></p>
<p>creat(&quot;/c/f&quot;);</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2016-final-exam-analysis/">
              
                  《操作系统》2016年期末考试分析
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-19
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>试题来自<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2016spring/FinalExam?action=AttachFile&amp;do=view&amp;target=20160524-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE-v1a.pdf" target="_blank" rel="noopener">20160524-期末考试题目-v1a.pdf</a>。</p>
<h2 id="判断题20分"><a class="markdownIt-Anchor" href="#判断题20分"></a> 判断题（20分）</h2>
<ol>
<li>在进程控制块数据结构中，必须为进程建立内核栈结构，确保进程可以得到操作系统的可靠服务和管理等支持。（√）</li>
</ol>
<p>以下解释摘自ucore docs Lab4：</p>
<blockquote>
<p>每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。uCore在创建进程时分配了2个连续的物理页（参见memlayout.h中KSTACKSIZE的定义） 作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好tss（可以回顾一下在实验一中讲述的 tss在中断处理过程中的作用），以便在进程切换以后再发生中断时能够使用正确的栈。其次，内核<br>
栈位于内核地址空间，并且是不共享的（ 每个线程都拥有自己的内核栈） ，因此不受到mm的管理，当进程退出的时候，内核能够根据kstack的值快速定位栈的位置并进行回收。</p>
</blockquote>
<hr>
<ol start="2">
<li>在进程切换过程中，进程上下文信息的保存与恢复过程必须在内核态完成。（√）</li>
</ol>
<p>以下内容摘自ucore docs Lab4：</p>
<blockquote>
<p>context：进程的上下文，用于进程切换（参见switch.S）。在uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等） 。使用context保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在<code>kern/process/switch.S</code>中定义的<code>switch_to</code>。</p>
</blockquote>
<p>进程的上下文信息除了context以外，还包括页表信息（CR3寄存器），访问和修改这些内容需要特权指令，因此必须在内核态完成。</p>
<hr>
<ol start="3">
<li>对于父进程而言，<code>fork()</code>的返回值只能是子进程的pid号。（×）</li>
</ol>
<p>如果<code>fork()</code>不成功，则会返回-1。</p>
<hr>
<ol start="4">
<li>对于分属不同进程的线程A和线程B之间进行切换，必须要切换页表。（√）</li>
</ol>
<p>同一进程的不同线程共享同一页表，但不同进程对应的页表一般是不同的。</p>
<hr>
<ol start="5">
<li>在用户空间中实现的线程模型可以有效的避开操作系统调度带来的时间开销。（?）</li>
</ol>
<p>我猜这是<a href="/post/os-mooc-lecture-11-summary">第11讲“进程和线程”</a>中的内容。用户线程的优点是同一进程内的用户线程切换快，但是内核并不了解用户线程，因此只能按进程分配CPU时间；而内核线程的创建、终止和切换的代价相对较大（因为需要在内核态实现），但可以以线程为单位进行CPU时间分配。总的来说，避免操作系统的调度是不太可能的，所以我认为此题的描述是错误的。</p>
<p>2018.5.25 UPD：tsz同学认为此题题意不清。我同意这一观点。用户态实现的线程切换的时候的确可以不通过OS的进程调度，但是当然，完全避开OS的调度是不太可能的。</p>
<p>2018.12.19 UPD：评论区<a href="https://disqus.com/by/disqus_PF6zRZnxXv/" target="_blank" rel="noopener">酒和弦</a>的回复提醒了我，“避开操作系统调度带来的时间开销”的意思不一定是真的要避开操作系统的调度，而是用用户线程调度替代OS线程调度。这的确可以节省时间开销。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>不过我仍然认为这道题的含义不明确，所以现在我把答案改成了？</p>
<hr>
<ol start="6">
<li>对于应用程序而言，编译器生成的程序地址是虚拟地址，由操作系统建立段/页表完成虚实地址转换。（√）</li>
</ol>
<p>好像确实是这么回事。</p>
<hr>
<ol start="7">
<li>对于采用段页式的x86而言，CPU访问一个虚拟地址时，如TLB访问缺失，则需先通过页表，再通过段表才能找到对应的物理地址。（×）</li>
</ol>
<p>反了，是先通过段表，再通过页表。</p>
<hr>
<ol start="8">
<li>通过动态链接库和操作系统的页表设置，可以让多个不同的应用程序运行时共用一个库函数（如<code>printf</code>等）的代码实现。（√）</li>
</ol>
<p>反正就是可以通过页表设置映射到同一块物理内存。OS本身的代码也是这么操作的。</p>
<hr>
<ol start="9">
<li>当设置好GDT（全局描述符表）的内容：然后CPU执行<code>lgdt</code>指令加载GDT；接着立刻执行<code>incl 0x80</code>指令时，CPU将查找GDT并完成虚拟地址<code>0x80</code>到线性地址的转换。（×）</li>
</ol>
<p>这道题的表述比较模糊不清。不过据说这个描述是错误的，因为里面没有提到对GDT项指向的段寄存器的更新。</p>
<hr>
<ol start="10">
<li>在32位计算机系统中，由于4GB内存普遍存在，导致虚拟内存管理已经不再有存在的必要。（×）</li>
</ol>
<p>这种说法显然有很多问题，比如：</p>
<ul>
<li>4GB仍然很不够用</li>
<li>虚拟内存管理的功能不止有增加“虚拟”内存，还有细粒度的对内存访问权限和内存共享的管理</li>
</ul>
<hr>
<ol start="11">
<li>对于实时系统中的优先级反转（反置）问题，可通过优先级继承算法或优先级天花板算法来解决。（√）</li>
</ol>
<p>这是<a href="/post/os-mooc-lecture-15-summary">第15讲“处理机调度”</a>中的内容。优先级继承算法的思路是，占有资源的低优先级进程继承申请资源的高优先级进程的优先级；而优先级天花板算法的思路是，占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同。</p>
<hr>
<ol start="12">
<li>信号量机制可实现基于条件变量的管程机制，反之亦然。（√）</li>
</ol>
<p>信号量和条件变量是等价的（也就是它们可以互相实现）。</p>
<hr>
<ol start="13">
<li>在多CPU系统中，仅通过CPU中断使能和屏蔽指令，就可实现对临界区代码的互斥保护。（×）</li>
</ol>
<p>因为有多个CPU，因此使能单个CPU的中断完全不能保证互斥保护。</p>
<hr>
<ol start="14">
<li>在银行家算法中，不安全状态不一定会造成死锁。（√）</li>
</ol>
<p><img src="safe-state-and-deadlock.png" alt="安全状态和死锁的关系"></p>
<hr>
<ol start="15">
<li>操作系统中的虚拟文件系统屏蔽了底层具体文件系统的差异性，给上层应用提供了统一的访问接口。（√）</li>
</ol>
<p>这是很原理性的话了。显然是对的。</p>
<hr>
<ol start="16">
<li>在Linux中，存在不需要把数据保存到磁盘上的文件系统，比如<code>/proc</code>文件系统，其作用是给应用程序提供一种内核信息的访问通道。（√）</li>
</ol>
<p>是的。以下内容摘自<a href="https://www.cnblogs.com/cute/archive/2011/04/20/2022280.html" target="_blank" rel="noopener">深入理解linux系统下proc文件系统内容</a>：</p>
<blockquote>
<p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。<br>
基于/proc文件系统如上所述的特殊性，其内的文件也常被称作虚拟文件，并具有一些独特的特点。例如，其中有些文件虽然使用查看命令查看时会返回大量信息，但文件本身的大小却会显示为0字节。此外，这些特殊文件中大多数文件的时间及日期属性通常为当前系统时间和日期，这跟它们随时会被刷新（存储于RAM中）有关。<br>
为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如/proc/scsi目录中存储的就是当前系统上所有SCSI设备的相关信息，/proc/N中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程（可以想象得到，在某进程结束后其相关目录则会消失）。<br>
大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如apm、free、lspci或top查看时却可以有着不错的表现。</p>
</blockquote>
<hr>
<ol start="17">
<li>在当前的计算机系统中，存在计算能力比CPU还快的外设。（√）</li>
</ol>
<p>我也不知道到底是什么外设……不过我大胆猜测这里指的是GPU。不过，即使是CPU和GPU的比较，这个说法仍然不见得是很严谨的。</p>
<blockquote>
<p>造成GPU和CPU根本差别的原因在于不同的目标需求：GPU假设运行其上的工作都是高度可并行的，而CPU需要同时很好的支持并行和顺序操作。于是，CPU需要大的片上缓存和复杂的控制逻辑，GPU则利用多线程并行运行节省了片上的大缓存，同时针对一簇线程执行同一套控制逻辑。因此，在高度并行化且数据规模巨大的应用下，GPU可以获得很高的浮点运算性能，然而如果问题无法良好映射到某个合适的并行模型或当数据规模较小时，SIMT就无法发挥并行的优势，CPU与GPU之间的数据交换也会大大降低运算效率。不过，后一个问题在刚刚发布的CUDA4.0中已经通过GPUDirect2.0得到了改进)。<br>
作者：王洋子豪<br>
链接：<a href="https://www.zhihu.com/question/19584781/answer/12292363" target="_blank" rel="noopener">https://www.zhihu.com/question/19584781/answer/12292363</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<hr>
<ol start="18">
<li>DMA机制允许外设不经过CPU进行数据传输。（√）</li>
</ol>
<p>以下内容摘自<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96" target="_blank" rel="noopener">直接内存访问</a>：</p>
<blockquote>
<p>直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。</p>
</blockquote>
<hr>
<ol start="19">
<li>循环扫描算法（C-SCAN）对硬盘访问带来的好处在U盘上不存在。（√）</li>
</ol>
<blockquote>
<p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。（<a href="http://gengning938.blog.163.com/blog/static/128225381201161884614990/" target="_blank" rel="noopener">磁盘调度算法</a>）</p>
</blockquote>
<blockquote>
<p>对于U盘和SSD等随机访问的Flash半导体存储器，采用FCFS（先来先服务）调度策略更高效。 因为Flash的半导体存储器的物理结构不需要考虑寻道时间和旋转延迟，可直接按I/O请求的先后顺序服务。（<a href="https://www.nowcoder.com/questionTerminal/64fe6441b3fe47708803354979645a36" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/64fe6441b3fe47708803354979645a36</a>）</p>
</blockquote>
<hr>
<ol start="20">
<li>访问频率置换算法（Frequency-based Replacement）的基本思路是，在短周期中使用LFU算法，而在长周期中使用LRU算法。（×）</li>
</ol>
<p>其实我现在还没有学到这里，但似乎这个描述反了，应该是短周期使用LRU，长周期使用LFU。</p>
<h2 id="填空题20分"><a class="markdownIt-Anchor" href="#填空题20分"></a> 填空题（20分）</h2>
<h3 id="21"><a class="markdownIt-Anchor" href="#21"></a> 21</h3>
<p>在基于x86-32的ucore操作系统中，一般函数调用的参数通过（<strong>1.1</strong>）传递，系统调用的参数通过（<strong>1.2</strong>）传递，将系统调用号存放在（<strong>1.3</strong>），通过（<strong>1.4</strong>）指令进入内核态。此时还应该保存执行现场，需要在<code>trapframe</code>里保存（<strong>1.5</strong>）、（<strong>1.6</strong>）、（<strong>1.7</strong>）等信息（填三项即可）。</p>
<ol>
<li>栈</li>
<li>寄存器和栈</li>
<li>eax寄存器</li>
<li><code>int 0x80</code></li>
<li>通用寄存器</li>
<li>EFLAGS寄存器</li>
<li>EIP</li>
</ol>
<hr>
<p>以下内容摘自<a href="https://blog.csdn.net/xinghun_4/article/details/8288321" target="_blank" rel="noopener">系统调用和函数参数传递</a>：</p>
<blockquote>
<p>系统调用参数传递：</p>
</blockquote>
<ul>
<li>x86_32
<ul>
<li>通过中断（int 0x80）来实现</li>
<li>寄存器 eax 中存放系统调用号，同时系统调用返回值也存放在 eax 中</li>
<li>当系统调用参数小于等于6个时，参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi ，ebp中</li>
<li>当系统调用参数大于6个时，全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
</li>
<li>x86_64
<ul>
<li>通过中断（syscall）指令来实现</li>
<li>寄存器 eax 中存放系统调用号，同时系统调用返回值也存放在 eax 中</li>
<li>当系统调用参数小于等于6个时，参数则必须按顺序放到寄存器 rdi，rsi，rdx，r10，r8，r9中</li>
<li>当系统调用参数大于6个时，全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数参数传递：</p>
</blockquote>
<ul>
<li>x86_32
<ul>
<li>C调用约定（即用__cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。</li>
</ul>
</li>
<li>x86_64
<ul>
<li>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前6个与前面一样， 但后面的依次从&quot;右向左&quot;放入栈中。</li>
</ul>
</li>
</ul>
<p><code>struct trapframe</code>的定义如下（摘自<code>kern/trap/trap.h</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">    struct pushregs tf_regs;</span><br><span class="line">    uint16_t tf_gs;</span><br><span class="line">    uint16_t tf_padding0;</span><br><span class="line">    uint16_t tf_fs;</span><br><span class="line">    uint16_t tf_padding1;</span><br><span class="line">    uint16_t tf_es;</span><br><span class="line">    uint16_t tf_padding2;</span><br><span class="line">    uint16_t tf_ds;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_trapno;</span><br><span class="line">    /* below here defined by x86 hardware */</span><br><span class="line">    uint32_t tf_err;</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding4;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">    /* below here only when crossing rings, such as from user to kernel */</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>trapframe</code>中保存的信息包括：</p>
<ul>
<li>通用寄存器（<code>tf_regs</code>，其中保存了edi、esi、ebp、ebx、edx、ecx和eax）</li>
<li>中断错误码（<code>err</code>）</li>
<li>eip（指令指针）</li>
<li>cs（代码段寄存器）</li>
<li>EFLAGS寄存器</li>
<li>esp（栈寄存器，可选）</li>
<li>ss（堆栈段寄存器，可选）</li>
</ul>
<h3 id="22"><a class="markdownIt-Anchor" href="#22"></a> 22</h3>
<p>（<strong>2.1</strong>）是一种将不同文件名链接至同一个文件的机制，它可以使同一文件具有多个不同的名字，而文件系统只存在一个文件内容的副本。（<strong>2.2</strong>）和原文件共享一个相同的inode号（文件在文件系统上的唯一标识）。若原文件删除了，则（<strong>2.3</strong>）不能访问它指向的原文件，而（<strong>2.4</strong>）则是可以的。（<strong>2.5</strong>）可以跨越磁盘分区，但（<strong>2.6</strong>）不具备这个特性。</p>
<ol>
<li>链接</li>
<li><del>软链接</del>硬链接</li>
<li>软链接</li>
<li>硬链接</li>
<li>软链接</li>
<li>硬链接</li>
</ol>
<hr>
<p>以下内容摘自<a href="http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noopener">Linux软连接和硬链接</a>：</p>
<blockquote>
<p>Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。<br>
【硬连接】<br>
硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。<br>
【软连接】<br>
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
</blockquote>
<p>更详细的解释可以参见<a href="https://blog.csdn.net/hairetz/article/details/4168296" target="_blank" rel="noopener">关于硬链接和软连接（符号链接）的区别</a>。</p>
<p>2018.5.25 UPD：经过wj同学的提示，我发现不知为何2抽风写错了。共享inode号的应该是硬链接。</p>
<h3 id="23"><a class="markdownIt-Anchor" href="#23"></a> 23</h3>
<p>RAID是一种机制，即把多块独立的硬盘按某种方式组合，形成硬盘阵列，从而提供比单块硬盘更快的访问性能或更可靠的数据存储能力。组成磁盘阵列的不同方式称为RAID级别，其中，（<strong>3.1</strong>）级别没有数据冗余存储功能，而（<strong>3.2</strong>）的数据可靠性在所有的RAID级别中是最高的。RAID 5是一种存储性能、数据安全和存储成本兼顾的磁盘阵列组成方式。它至少需要（<strong>3.3</strong>）块硬盘。当RAID5的一个磁盘数据发生损坏后，可利用剩下的数据和相应的（<strong>3.4</strong>）信息去恢复被损坏的数据。</p>
<ol>
<li>RAID 0</li>
<li>RAID 6</li>
<li>3</li>
<li>校验</li>
</ol>
<hr>
<ul>
<li>RAID-0：磁盘条带化
<ul>
<li>把数据块分成多个子块，存储在独立的磁盘中</li>
<li>通过独立磁盘上并行数据块访问来提供更大的磁盘带宽</li>
</ul>
</li>
<li>RAID-1：磁盘镜像
<ul>
<li>向两个磁盘写入相同的数据，从任何一个磁盘读取</li>
</ul>
</li>
<li>RAID-4：带校验的磁盘条带化
<ul>
<li>数据块级的磁盘条带化+专用奇偶校验磁盘</li>
</ul>
</li>
<li>RAID-5：带分布式校验的磁盘条带化
<ul>
<li>分摊校验磁盘的带宽限制</li>
<li>把校验和分布在各个磁盘上</li>
</ul>
</li>
<li>RAID-6：每组条带块有两个冗余块，允许两个磁盘错误</li>
</ul>
<h3 id="24"><a class="markdownIt-Anchor" href="#24"></a> 24</h3>
<p>信号提供了异步处理事件的一种方式。例如，用户在终端按下“Ctrl-C”键，会产生可使当前进程终止的SIGINT信号。每一个信号对应一个（<strong>4.1</strong>）数，定义在头文件<code>&lt;signal.h&gt;</code>中。信号处理行为可由三种方式可供选择：（<strong>4.2</strong>）、（<strong>4.3</strong>）、（<strong>4.4</strong>）。</p>
<ol>
<li>整</li>
<li>捕获</li>
<li>忽略</li>
<li>屏蔽</li>
</ol>
<hr>
<p>这部分是第20讲“死锁和进程通信”里的，但是我几乎都忘掉了……总之，信号和“信号号”的对应关系很类似于中断和中断号的关系，但是并没有一个明确的名称，所以我觉得回答“整数”是可以的。（参考<a href="https://blog.csdn.net/jnu_simba/article/details/11746217" target="_blank" rel="noopener">https://blog.csdn.net/jnu_simba/article/details/11746217</a>）</p>
<h2 id="问答题60分"><a class="markdownIt-Anchor" href="#问答题60分"></a> 问答题（60分）</h2>
<h3 id="25-银行家算法10分"><a class="markdownIt-Anchor" href="#25-银行家算法10分"></a> 25. 银行家算法（10分）</h3>
<p>下面是采用银行家算法的操作系统在某一时刻的资源分配状态。</p>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Max矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>7</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Available矩阵：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>5</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>请回答下列问题：</p>
<ol>
<li>请写出当前时刻的Need矩阵的内容是什么？</li>
<li>当前时刻，系统是否处于安全状态？</li>
<li>接下来，如果进程P1发出一个请求(0, 4, 2, 0)。这个请求能否立刻被满足？</li>
</ol>
<hr>
<p>要获得Need矩阵，只需将Allocation矩阵从Max矩阵中减去。于是得到：</p>
<p>Need矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>7</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>下面判断系统是否处于安全状态：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 1, 2] = [1, 5, 3, 2]，Finish[P0] = true</li>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5, 4] = [2, 8, 8, 6]，Finish[P2] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 0, 0, 0] = [3, 8, 8, 6]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 6, 3, 2] = [3, 14, 11, 8]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1, 4] = [3, 14, 12, 12]，Finish[P4] = true</li>
<li>算法结束，系统处于安全状态</li>
</ol>
<p>如果P1发出请求为Request = [0, 4, 2, 0]：</p>
<ol>
<li>Request &lt;= Need[P1]，资源申请未超过限度</li>
<li>Request &lt;= Available，不需等待</li>
<li>假设资源已分配，更新各矩阵内容：</li>
</ol>
<p>Allocation矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P1</td>
<td>1</td>
<td>4</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>6</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Available矩阵：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Need矩阵：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>P1</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>P4</td>
<td>0</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>然后判断当前状态是否为安全状态：</p>
<ol>
<li>Finish[P0] = false，Need[P0] &lt;= Available；于是释放P0资源，Available += [0, 0, 1, 2] = [1, 1, 1, 2]，Finish[P0] = true</li>
<li>Finish[P2] = false，Need[P2] &lt;= Available；于是释放P2资源，Available += [1, 3, 5, 4] = [2, 4, 6, 6]，Finish[P2] = true</li>
<li>Finish[P1] = false，Need[P1] &lt;= Available；于是释放P1资源，Available += [1, 4, 2, 0] = [3, 8, 8, 6]，Finish[P1] = true</li>
<li>Finish[P3] = false，Need[P3] &lt;= Available；于是释放P3资源，Available += [0, 6, 3, 2] = [3, 14, 11, 8]，Finish[P3] = true</li>
<li>Finish[P4] = false，Need[P4] &lt;= Available；于是释放P4资源，Available += [0, 0, 1, 4] = [3, 14, 12, 12]，Finish[P4] = true</li>
<li>算法结束，系统处于安全状态</li>
</ol>
<p>由于分配后系统仍然处于安全状态，这个请求可以立刻被满足。</p>
<h3 id="26-同步互斥10分"><a class="markdownIt-Anchor" href="#26-同步互斥10分"></a> 26. 同步互斥（10分）</h3>
<p>通过软件机制可正确实现互斥机制。</p>
<h4 id="1"><a class="markdownIt-Anchor" href="#1"></a> （1）</h4>
<p>下列二线程互斥机制的伪码实现是否有错？请给出原因分析，如果有错请给出反例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    shared int turn;</span><br><span class="line">    ...</span><br><span class="line">    turn = i ;</span><br><span class="line"></span><br><span class="line">ENTRY PROTOCOL (for Thread i ):</span><br><span class="line">    /* wait until it&apos;s our turn */</span><br><span class="line">    while (turn != i ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">EXIT PROTOCOL (for Thread i ):</span><br><span class="line">    /* pass the turn on */</span><br><span class="line">    turn = j ;</span><br></pre></td></tr></table></figure>
<hr>
<p>事实上这就是第17讲“同步互斥”中“基于软件的同步方法”中介绍的第一种错误做法。这种做法满足“忙则等待”，但不满足“空闲则入”。线程i和j必须轮流访问临界区；如果i始终不进入临界区，则j无法进入，会发生饥饿。</p>
<p>我有时会忽略“空闲则入”这条规则，事实上这也是临界区实现中非常重要的一条规则。</p>
<h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> （2）</h4>
<p>下列N线程互斥机制的伪码实现是否有误？请给出原因分析，如果有错请给出反例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">INITIALIZATION:</span><br><span class="line">    typedef char boolean;</span><br><span class="line">    ...</span><br><span class="line">    shared int num[n];</span><br><span class="line">    ...</span><br><span class="line">    for (j=0; j &lt; n; j++) &#123;</span><br><span class="line">        num[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">ENTRY PROTOCOL (for Thread i):</span><br><span class="line">    /* choose a number */</span><br><span class="line">    num[i] = max(num[0], ..., num[n-1]) + 1;</span><br><span class="line"></span><br><span class="line">    /* for all other Threads */</span><br><span class="line">    for (j=0; j &lt; n; j++) &#123;</span><br><span class="line">        /* wait if the Thread has a number and comes ahead of us */</span><br><span class="line">        if ((num[j] &gt; 0) &amp;&amp;</span><br><span class="line">            ((num[j] &lt; num[i]) ||</span><br><span class="line">            (num[j] == num[i]) &amp;&amp; (j &lt; i))) &#123;</span><br><span class="line">            while (num[j] &gt; 0) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">EXIT PROTOCOL (for Thread i):</span><br><span class="line">    /* clear our number */</span><br><span class="line">    num[i] = 0;</span><br></pre></td></tr></table></figure>
<hr>
<p>这种做法是错误的。假设有两个进程，i&lt;j，Ti正在执行<code>num[i] = max(num[0], ..., num[n-1]) + 1;</code>时，已计算得<code>max(num[0], ..., num[n-1])==0</code>；此时切换到Tj，也计算得<code>max(num[0], ..., num[n-1])==0</code>，随后<code>num[j]=1</code>，Tj先进入临界区。随后切换到Ti，计算得到<code>num[i]=1</code>，检查后Ti也进入临界区，违反互斥。</p>
<p>据说修改num[i]前后应用bool变量choose[i]保护起来，在后面枚举其他进程时先要等待choose[i]完成。这样就可以解决问题了。</p>
<p>（上述解释来自学长答案；这种做法和Eisenberg &amp; Mcquire还是挺不像的）</p>
<h3 id="27-信号量与管程15分"><a class="markdownIt-Anchor" href="#27-信号量与管程15分"></a> 27. 信号量与管程（15分）</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENTATION:</span><br><span class="line">monitor mt &#123;</span><br><span class="line">    -----variable in monitor-----------</span><br><span class="line">    semaphore mutex; // the mutex lock for going into the routines in monitor, should be initialized to 1</span><br><span class="line">    semaphore next; // the next is used to down the signaling proc, some proc should wake up the sleeped cv.signaling proc. should be initialized to 0</span><br><span class="line">    int next_count; // the number of of sleeped signaling proc, should be initialized to 0</span><br><span class="line">    condvar &#123;int count, sempahore sem&#125; cv[N]; // the condvars in monitor, count initial value 0, sem initial value 0</span><br><span class="line">    other shared variables in mt; // shared variables should protected by mutex lock</span><br><span class="line"></span><br><span class="line">    --------condvar wait---------------</span><br><span class="line">    cond_wait (cv) &#123;</span><br><span class="line">        cv.count ++;</span><br><span class="line">        if(mt.next_count&gt;0)</span><br><span class="line">            V(mt.next); // first perform the EXIT PROTOCOL</span><br><span class="line">        else</span><br><span class="line">            V(mt.mutex);</span><br><span class="line">        P(cv.sem); // now wait on the condition waiting queue (cv.sem)</span><br><span class="line">        cv.count --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --------condvar signal--------------</span><br><span class="line">    cond_signal(cv) &#123;</span><br><span class="line">        if(cv.count&gt;0) &#123; // do nothing unless a process is waiting on condition waiting queue (cv.sem)</span><br><span class="line">            mt.next_count ++;</span><br><span class="line">            V(cv.sem);  // release the waiting process which on condition waiting queue (cv.sem)</span><br><span class="line">            P(mt.next); // wait on the &quot;next&quot; waiting queue for cv.signaling proc</span><br><span class="line">            mt.next_count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --------routines in monitor-------------</span><br><span class="line">    routineA_in_mt () &#123;</span><br><span class="line">        P(mt.mutex); // ENTRY PROTOCOL (at the beginning of each monitor routines), wait for exclusive access to the monitor</span><br><span class="line">        ...</span><br><span class="line">        real body of routineA // in here, may access shared variables, call cond_wait OR cond_signal</span><br><span class="line">        ...</span><br><span class="line">        if(next_count&gt;0) // EXIT PROTOCOL (at the end of each monitor function)</span><br><span class="line">            V(mt.next); // if there are processes(sleeped cv.signaling proc) in the &quot;next&quot; queue, release one</span><br><span class="line">        else</span><br><span class="line">            V(mt.mutex); // otherwise, release the monitor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> （1）</h4>
<p>请说明管程的特征。上述管程实现是哪种类型的管程？</p>
<hr>
<p>管程的特征：</p>
<ul>
<li>管程是一种用于多线程互斥访问共享资源的程序结构</li>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<p>很显然，这就是ucore Lab7中实现的管程，属于Hoare语义。在这种语义下，如果条件变量上有进程正在等待，发出signal的进程会立刻进入等待状态，将控制权交给被唤醒的进程。</p>
<h4 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> （2）</h4>
<p>在上述伪码中，如果有3个线程a，b，c需要访问管程，并会使用管程中的2个条件变量<code>cv[0]</code>，<code>cv[1]</code>。</p>
<ol>
<li>请问<code>cv[i]-&gt;count</code>的含义是什么？<code>cv[i]-&gt;count</code>是否可能<code>&lt;0</code>，是否可能<code>&gt;1</code>？请举例或说明原因。</li>
<li>请问<code>mt-&gt;next_count</code>的含义是什么？<code>mt-&gt;next_count</code>是否可能<code>&lt;0</code>，是否可能<code>&gt;1</code>？请举例或说明原因。</li>
</ol>
<hr>
<p><code>cv[i]-&gt;count</code>的含义是在该条件变量上等待的线程数。显然这个数不可能<code>&lt;0</code>。如果有多于1个线程执行了<code>cond_wait(cv[i])</code>操作且还未被唤醒，这个数是可能<code>&gt;1</code>的。</p>
<p><code>mt-&gt;next_count</code>的含义是发出signal后暂时进入等待状态的线程的个数。显然，这个数不可能<code>&lt;0</code>。假设b执行<code>cond_wait(cv[0])</code>开始等待，c也执行<code>cond_wait(cv[0])</code>开始等待。a进入管程，执行<code>cond_signal(cv[0])</code>，唤醒b，a进入signal队列；b被唤醒后，立即执行<code>cond_signal(cv[0])</code>，唤醒c，b也进入signal队列。此时<code>mt-&gt;next_count=2</code>。</p>
<h3 id="28-stride调度算法10分"><a class="markdownIt-Anchor" href="#28-stride调度算法10分"></a> 28. stride调度算法（10分）</h3>
<p>请描述stride调度算法的思路？stride算法的特征是什么？stride调度算法是如何避免stride溢出问题的？</p>
<hr>
<p>思路：</p>
<ul>
<li>每个进程有两个属性：
<ul>
<li>pass：当前位置</li>
<li>stride：一次要前进的步数</li>
<li>stride ∝ 1 / priority</li>
</ul>
</li>
<li>选择进程的方法：
<ul>
<li>执行当前pass最小的进程</li>
<li>该进程的pass += stride</li>
<li>重复该过程</li>
</ul>
</li>
</ul>
<p>特征：</p>
<ul>
<li>stride越小（优先级越高），被调度的次数会越多</li>
<li>基于优先级（priority-based）</li>
<li>调度选择是确定的（deterministic）</li>
</ul>
<p>避免stride溢出的方法：</p>
<ul>
<li>uint32存储、int32相减比较</li>
<li>最大步进值-最小步进值&lt;无符号整数/2</li>
<li>具体可参见Piazza帖子<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=357" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=357</a></li>
</ul>
<h3 id="29-文件系统15分"><a class="markdownIt-Anchor" href="#29-文件系统15分"></a> 29. 文件系统（15分）</h3>
<h4 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> （1）</h4>
<p>试以图示描述ucore操作系统中的SFS文件系统的文件组织方式。</p>
<hr>
<p><img src="sfs-inode.jpg" alt="SFS文件系统的索引分配"></p>
<p>呃，这个怎么描述，不会啊。。。</p>
<p><del>总之据说是链式分配……</del></p>
<p>2018.5.25 UPD：<br>
在ssh同学的提醒下，我想起来SFS使用的是索引分配这回事了……</p>
<h4 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> （2）</h4>
<p>下面是SFS的磁盘索引节点数据结构定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_disk_inode &#123;</span><br><span class="line">    uint32_t size;</span><br><span class="line">    uint16_t type;</span><br><span class="line">    uint16_t nlinks;</span><br><span class="line">    uint32_t blocks;</span><br><span class="line">    uint32_t direct[SFS_NDIRECT];</span><br><span class="line">    uint32_t indirect;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假定ucore里SFS_NDIRECT的取值是16，而磁盘上数据块大小为1KB。请计算这时ucore支持的最大文件大小。请给出计算过程。（这样可给步骤分）</p>
<hr>
<p>以下内容摘自ucore docs Lab8：</p>
<p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。首先我们看看在硬盘上的索引节点的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_disk_inode &#123;</span><br><span class="line">    uint32_t size; // 如果inode表示常规文件，则size是文件大小</span><br><span class="line">    uint16_t type; // inode的文件类型</span><br><span class="line">    uint16_t nlinks; // 此inode的硬链接数</span><br><span class="line">    uint32_t blocks; // 此inode的数据块数的个数</span><br><span class="line">    uint32_t direct[SFS_NDIRECT]; // 此inode的直接数据块索引值（ 有SFS_NDIRECT个）</span><br><span class="line">    uint32_t indirect; // 此inode的一级间接数据块索引值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<p>默认的，ucore里SFS_NDIRECT是12，即直接索引的数据页大小为12 * 4k = 48k；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 12 * 4k + 1024 * 4k = 48k + 4m。数据索引表内，0表示一个无效的索引，inode里blocks表示该文件或者目录占用的磁盘的block的个数。indiret为0时，表示不使用一级索引块。（因为 block 0用来保存super block，它不可能被其他任何文件或目录使用，所以这么设计也是合理的）</p>
<p>显然，在题设中，最大可能的文件大小为使用一级间接数据块索引时，为(16 + 1KB/4B) * 1KB = 272KB。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://github.com/chyyuu/simple_os_book/blob/master/zh/chapter-4/what_is_thread.md" target="_blank" rel="noopener">【原理】线程的属性与特征分析</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-29-summary-lock-based-concurrent-data-structures/">
              
                  OSTEP第29章总结：Lock-Based Concurrent Data Structures
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-26
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章主要介绍了如何以锁为基础，将常见的数据结构改造为线程安全的。</p>
<ul>
<li>一种通用的解决方法</li>
<li>性能：缩放（scaling）问题</li>
<li>并发计数器</li>
<li>并发链表</li>
<li>并发队列</li>
<li>并发哈希表</li>
</ul>
<p>最后强调了几点经验教训：</p>
<ul>
<li>在控制流变化的时候不要忘记释放锁（见并发链表的错误实现）</li>
<li>提高并发性不等于提升性能（见交替上锁的链表）</li>
<li>在编写多线程应用时，正确性比效率更重要，需要避免过早优化（premature optimization）</li>
</ul>
<h2 id="一种通用的解决方法"><a class="markdownIt-Anchor" href="#一种通用的解决方法"></a> 一种通用的解决方法</h2>
<p>很容易想到，使常见的数据结构线程安全的最简单的方法，就是在对该数据结构执行任何操作之前都上锁，执行完之后再释放锁。</p>
<p>以计数器为例。一个普通的计数器的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在计数器上加入一个操作锁，此时程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">    Pthread_mutex_init(&amp;c-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> rc = c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现方法显然是简单且正确的。</p>
<h2 id="性能缩放scaling问题"><a class="markdownIt-Anchor" href="#性能缩放scaling问题"></a> 性能：缩放（scaling）问题</h2>
<p>上述简单粗暴的实现显然会降低并发性，因为有些操作完全是可以并行执行的（如多个<code>get</code>操作）。对于这一问题，给出一形式化的定义如下：</p>
<p><strong>完全缩放</strong>（perfect scaling）：对于一个线程安全的数据结构，如果需要访问它的线程数量小于系统中处理器的数量，且满足多个线程并发访问该数据结构的运行时间不多于只有单个线程访问该数据结构时的运行时间，则称该数据结构是完全缩放的。</p>
<p>实验结果表明，上述实现方法完全做不到完全缩放，多线程并发访问的时间随线程数量而线性增加（在线程数&lt;CPU数的前提下）。这是符合逻辑的。</p>
<h2 id="并发计数器"><a class="markdownIt-Anchor" href="#并发计数器"></a> 并发计数器</h2>
<p>我个人认为精确的计数器实现是很难（或者说不可能？）做到完全缩放的，因为这些操作本身已经足够简单，很难再有并行优化的余地。书中给出了一种不精确的计数器的实现，称为“sloppy counter”。</p>
<p>这一计数器的基本思想如下：</p>
<ul>
<li>每个CPU拥有一个本地计数器，除此之外，有一个全局计数器；每个计数器各有一个锁</li>
<li>当某个CPU上运行的线程需要执行<code>increment</code>操作时，获得本地计数器的锁，执行操作，并释放锁</li>
<li>当某个本地计数器的值达到阈值S时，则获得该计数器和全局计数器的锁，全局计数器+=本地计数器，本地计数器清零；释放锁</li>
<li>全局计数器中存放的是计数器的一个估计值，读取时需要先获得全局计数器的锁。可以通过获得全部锁来获得计数器当前的真实值，但这一操作显然是非缩放的</li>
</ul>
<p>下面是一个S=5，4个线程的执行示例：<br>
<img src="tracing-the-sloppy-counters.png" alt></p>
<p>可以看出，S的值越小，该实现方法越类似于直接加锁的实现（当S=1时基本退化为直接加锁的实现）；S的值越大，该方法的缩放性越强，性能越好，但全局计数器的值就会偏离真实值更远。</p>
<p><img src="scaling-sloppy-counters.png" alt="4个线程，4个CPU，分别increment一百万次，执行时间随S的变化"></p>
<p>下面给出一种简单的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> global; <span class="comment">// global count</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> glock; <span class="comment">// global lock</span></span><br><span class="line">    <span class="keyword">int</span> local[NUMCPUS]; <span class="comment">// local count (per cpu)</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> llock[NUMCPUS]; <span class="comment">// ... and locks</span></span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init: record threshold, init locks, init values</span></span><br><span class="line"><span class="comment">// of all local counts and global count</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    c-&gt;threshold = threshold;</span><br><span class="line">    c-&gt;global = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;glock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMCPUS; i++) &#123;</span><br><span class="line">        c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_init(&amp;c-&gt;llock[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update: usually, just grab local lock and update local amount</span></span><br><span class="line"><span class="comment">// once local count has risen by ’threshold’, grab global</span></span><br><span class="line"><span class="comment">// lock and transfer local values to it</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu = threadID % NUMCPUS;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;llock[cpu]);</span><br><span class="line">    c-&gt;local[cpu] += amt; <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;local[cpu] &gt;= c-&gt;threshold) &#123; <span class="comment">// transfer to global</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[cpu];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[cpu] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;llock[cpu]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get: just return global amount (which may not be perfect)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">int</span> val = c-&gt;global;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">return</span> val; <span class="comment">// only approximate!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发链表"><a class="markdownIt-Anchor" href="#并发链表"></a> 并发链表</h2>
<p>书中给出了一种错误的实现，在此不再摘录了。该错误的问题在于，如果获得锁之后未能成功进行相应操作，则直接返回，忘记释放锁了。我们可以从中得出如下教训：</p>
<ul>
<li>不要扩大锁覆盖的范围，只覆盖关键区就可以了</li>
<li>安排好代码的执行顺序，对于有多个出口点的代码，最好将出口点汇总在一起，这样不容易忘记释放锁；在具体实现的时候，可以记录返回值，并配合goto语句</li>
</ul>
<p>下面是正确的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> *L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronization not needed</span></span><br><span class="line">    <span class="keyword">node_t</span> *<span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是原先出错的位置，现在已移出上锁区域</span></span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// just lock critical section</span></span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> *L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> *curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出口点集合</span></span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">// now both success and failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表的缩放性"><a class="markdownIt-Anchor" href="#链表的缩放性"></a> 链表的缩放性</h3>
<p>显然上述实现并不具有完全缩放性。另一种想法是采用交替上锁（hand-over-hand locking）技术：为每个结点都初始化一个锁，需要访问结点时，则获取该结点对应的锁。这个想法虽然听起来很好，极大地增加了并发性，但在实际操作中效率很低，因为请求/释放锁的操作耗时太多。如果采取一种混合策略（如每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>个结点上一个锁），就可以在并发性和效率之间取得一种平衡。</p>
<h2 id="并发队列"><a class="markdownIt-Anchor" href="#并发队列"></a> 并发队列</h2>
<p>书中给出了一种比较巧妙的实现。一般来说，入队操作只会访问队头，出队操作只会访问队尾，因此可以对这两种操作分别建立一个锁，一个队头锁，一个队尾锁；在进行操作时分别上锁。</p>
<p>代码中的细节是，为了将两种操作分离开，在队列的头部增加了一个伪结点；所以出队的时候返回的是队头的下一个结点的值；然后删除队头，它原来的下一个结点成为队头，也成为伪结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">node_t</span> *tail;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> headLock;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> tailLock;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Init</span><span class="params">(<span class="keyword">queue_t</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;head = q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;headLock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;q-&gt;tailLock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Queue_Enqueue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;tailLock);</span><br><span class="line">    q-&gt;tail-&gt;next = tmp;</span><br><span class="line">    q-&gt;tail = tmp;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;tailLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue_Dequeue</span><span class="params">(<span class="keyword">queue_t</span> *q, <span class="keyword">int</span> *value)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="keyword">node_t</span> *tmp = q-&gt;head;</span><br><span class="line">    <span class="keyword">node_t</span> *newHead = tmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    *value = newHead-&gt;value;</span><br><span class="line">    q-&gt;head = newHead;</span><br><span class="line">    pthread_mutex_unlock(&amp;q-&gt;headLock);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发哈希表"><a class="markdownIt-Anchor" href="#并发哈希表"></a> 并发哈希表</h2>
<p>并发哈希表的实现借用了上述并发链表的实现，这一实现是比较简化的。由于不同的槽对应的链表的操作是可以并行的（相当于每个槽对应一个锁），因此这一实现的并发性是比较高的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash_Init</span><span class="params">(<span class="keyword">hash_t</span> *H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123;</span><br><span class="line">        List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Lookup</span><span class="params">(<span class="keyword">hash_t</span> *H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h2>
<p>没写。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-28-summary-locks/">
              
                  OSTEP第28章总结：Locks
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-18
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章主要介绍了锁的基础知识，以及各种锁的实现方法和评价标准：</p>
<ul>
<li>硬件支持
<ul>
<li>关中断</li>
<li>TS指令实现自旋锁</li>
<li>CS指令实现自旋锁</li>
<li>LL/SC指令实现自旋锁</li>
<li>FA指令实现无饥饿的自旋锁</li>
</ul>
</li>
<li>硬件和OS支持
<ul>
<li>从自旋锁到yield</li>
<li>使用队列和睡眠</li>
<li>Linux中的实际例子</li>
<li>两阶段锁</li>
</ul>
</li>
</ul>
<h2 id="锁的基本定义和用法"><a class="markdownIt-Anchor" href="#锁的基本定义和用法"></a> 锁的基本定义和用法</h2>
<p>锁是一个变量。在任意时刻，该变量中都存储着锁的状态：</p>
<ul>
<li>可获得（或者说释放，开锁的，说明没有线程持有该锁）</li>
<li>不可获得（未被释放，上锁的，说明有一个线程持有该锁，很可能处于关键区内）</li>
</ul>
<p>锁的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock_t mutex; // some globally-allocated lock &apos;mutex&apos;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + 1;  // 关键区</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p><code>lock()</code>的语义：</p>
<ul>
<li>尝试获得锁</li>
<li>如果该锁未被获得，则获得该锁，进入关键区，该线程成为锁的拥有者</li>
<li>如果该锁已被获得，则在锁被释放之前始终阻塞，防止多个线程同时进入关键区<br>
<code>unlock()</code>的语义：</li>
<li>释放线程当前持有的锁</li>
<li>如果还有其他线程在等待锁，则通知其中一个进程开始运行，获得锁，并进入关键区</li>
</ul>
<p>锁能够帮助程序员更多地获得对线程的控制权。</p>
<h2 id="锁的评价标准"><a class="markdownIt-Anchor" href="#锁的评价标准"></a> 锁的评价标准</h2>
<ol>
<li>基本要求：提供互斥访问功能</li>
<li>公平性：是否会出现线程饥饿的状况？</li>
<li>性能：不同场景下的时间开销</li>
<li>单线程获取并释放锁</li>
<li>多线程请求同一个锁</li>
<li>多CPU上的多线程请求同一个锁</li>
</ol>
<h2 id="锁的实现方法"><a class="markdownIt-Anchor" href="#锁的实现方法"></a> 锁的实现方法</h2>
<p>本章中给出了一种单纯用现有非特权指令（加载和存储）实现锁的方法，但是失败了。当然，其实这样是可以成功的（Dekker和Peterson算法），也做过一些研究，但是这些算法对硬件也有一些假设，而且人们已经发现，在硬件中提供一些支持会方便很多。所以就不赘述了。</p>
<h3 id="用硬件原语实现锁"><a class="markdownIt-Anchor" href="#用硬件原语实现锁"></a> 用硬件原语实现锁</h3>
<h4 id="关中断"><a class="markdownIt-Anchor" href="#关中断"></a> 关中断</h4>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void lock() &#123;</span><br><span class="line">	DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line">void unlock() &#123;</span><br><span class="line">	EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：简单</p>
<p>缺点：</p>
<ul>
<li>需要线程执行特权指令，可能被滥用，OS无法得到控制权</li>
<li>不适用于多处理器系统</li>
<li>关中断太久可能导致重要的中断请求被丢失</li>
<li>效率低，因为现代CPU开关中断的速度比较慢</li>
</ul>
<p>目前这一方法主要用于OS本身的原子性操作，因为这样就不存在滥用问题。</p>
<h4 id="使用tstest-and-set指令实现自旋锁"><a class="markdownIt-Anchor" href="#使用tstest-and-set指令实现自旋锁"></a> 使用TS（Test-And-Set）指令实现自旋锁</h4>
<p>TS指令原子地完成以下操作：</p>
<ul>
<li>读出某个地址处的值</li>
<li>将新的值写入该地址</li>
<li>返回旧值</li>
</ul>
<p>用代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int TestAndSet(int *old_ptr, int new) &#123;</span><br><span class="line">    int old = *old_ptr; // fetch old value at old_ptr</span><br><span class="line">    *old_ptr = new; // store &apos;new&apos; into old_ptr</span><br><span class="line">    return old; // return the old value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以利用TS指令实现自旋锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int flag;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void init(lock_t *lock) &#123;</span><br><span class="line">    // 0 indicates that lock is available, 1 that it is held</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)</span><br><span class="line">        ; // spin-wait (do nothing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理是：</p>
<ul>
<li><code>flag</code>变量表示锁是否被持有，0表示空闲</li>
<li>在<code>lock()</code>函数中，不断使用TS指令测试锁是否空闲，空闲则获得锁并将<code>flag</code>置为1；不空闲则自旋等待</li>
<li>在<code>unlock()</code>函数中，只需简单地将<code>flag</code>置为0</li>
</ul>
<h4 id="对自旋锁的评价"><a class="markdownIt-Anchor" href="#对自旋锁的评价"></a> 对自旋锁的评价</h4>
<ol>
<li>正确性：显然是正确的</li>
<li>公平性：无法保证，可能会导致饥饿</li>
<li>性能：</li>
<li>单CPU系统：性能很差</li>
<li>多CPU系统：还不错（如果线程的数量大致与CPU相等）</li>
</ol>
<h4 id="使用cscompare-and-swap指令实现自旋锁"><a class="markdownIt-Anchor" href="#使用cscompare-and-swap指令实现自旋锁"></a> 使用CS（Compare-And-Swap）指令实现自旋锁</h4>
<p>CS指令原子地完成以下操作：</p>
<ul>
<li>读出某个地址处的值</li>
<li>判断它是否与期望的值相等，如果相等，则更新该地址处的值为某给定的值</li>
<li>返回该地址处原有的值</li>
</ul>
<p>用代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CompareAndSwap(int *ptr, int expected, int new) &#123;</span><br><span class="line">	int actual = *ptr;</span><br><span class="line">	if (actual == expected)</span><br><span class="line">		*ptr = new;</span><br><span class="line">	return actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与TS指令类似，可以利用CS指令实现自旋锁（其他函数与TS指令的实现相同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">	while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)</span><br><span class="line">		; // spin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理也类似。</p>
<h4 id="用llload-linked和scstore-conditional指令实现自旋锁"><a class="markdownIt-Anchor" href="#用llload-linked和scstore-conditional指令实现自旋锁"></a> 用LL（Load-Linked）和SC（Store-Conditional）指令实现自旋锁</h4>
<p>这两个指令是MIPS架构下提供的。LL指令类似于普通的加载指令，把某个值从内存中加载到寄存器中；但它会标记这个地址，SC指令更新该地址处的值时，仅在上次LL过后该值还没有被修改过时才会成功。</p>
<p>用代码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LoadLinked(int *ptr) &#123;</span><br><span class="line">    return *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StoreConditional(int *ptr, int value) &#123;</span><br><span class="line">    if (no one has updated *ptr since the LoadLinked to this address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        return 1; // success!</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0; // failed to update</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        while (LoadLinked(&amp;lock-&gt;flag) == 1)</span><br><span class="line">            ; // spin until it&apos;s zero</span><br><span class="line">        if (StoreConditional(&amp;lock-&gt;flag, 1) == 1)</span><br><span class="line">            return; // if set-it-to-1 was a success: all done</span><br><span class="line">        // otherwise: try it all over again</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个线程同时在请求这个锁，则先执行SC指令的线程可以获得锁，另一个线程执行SC指令时就会返回0，需要重新进入请求状态。</p>
<h4 id="用fafetch-and-add指令实现标签锁ticket-lock"><a class="markdownIt-Anchor" href="#用fafetch-and-add指令实现标签锁ticket-lock"></a> 用FA（Fetch-And-Add）指令实现标签锁（ticket lock）</h4>
<p>FA指令原子地完成以下任务：</p>
<ul>
<li>读出某个地址处的值</li>
<li>将这个值+1</li>
<li>重新写回该地址处</li>
<li>返回原来的值</li>
</ul>
<p>用代码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int FetchAndAdd(int *ptr) &#123;</span><br><span class="line">	int old = *ptr;</span><br><span class="line">	*ptr = old + 1;</span><br><span class="line">	return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用该指令可以实现一个思路稍有不同的锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int ticket;</span><br><span class="line">    int turn;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void lock_init(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;ticket = 0;</span><br><span class="line">    lock-&gt;turn = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *lock) &#123;</span><br><span class="line">    int myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    while (lock-&gt;turn != myturn)</span><br><span class="line">        ; // spin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *lock) &#123;</span><br><span class="line">    lock-&gt;turn = lock-&gt;turn + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ticket</code>变量表示曾经请求过锁的线程的个数，<code>turn</code>变量表示当前（应该）是第几个等待线程持有锁。<code>lock()</code>函数中，通过FA指令为本线程获得“排位”（<code>myturn</code>），并等待前面的线程执行完毕。<code>unlock()</code>函数中，只需简单地将<code>turn</code>变量+1（轮到下一个线程了）。</p>
<p>这个实现方法的优点是，不存在饥饿问题，请求同一个锁的线程按请求顺序获得锁。（但是这样会不会有死锁问题？？）</p>
<h3 id="用硬件原语和os的支持实现锁"><a class="markdownIt-Anchor" href="#用硬件原语和os的支持实现锁"></a> 用硬件原语和OS的支持实现锁</h3>
<h4 id="直接把自旋改为yield"><a class="markdownIt-Anchor" href="#直接把自旋改为yield"></a> 直接把自旋改为<code>yield</code></h4>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    flag = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock() &#123;</span><br><span class="line">    while (TestAndSet(&amp;flag, 1) == 1)</span><br><span class="line">        yield(); // give up the CPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock() &#123;</span><br><span class="line">    flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得不到锁的线程不再自旋，而是主动放弃控制权。虽然减少了自旋浪费的时间片，不过仍然耗费了一些切换上下文的时间。</p>
<h4 id="利用队列和睡眠实现锁"><a class="markdownIt-Anchor" href="#利用队列和睡眠实现锁"></a> 利用队列和睡眠实现锁</h4>
<p>现在改为由OS控制当前的锁被释放之后，哪一个线程能够获得锁。为此引入睡眠机制：</p>
<ul>
<li><code>park()</code>系统调用：将调用线程睡眠</li>
<li><code>unpark(ThreadID)</code>系统调用：唤醒某个进程</li>
</ul>
<p>下面是一个使用队列、TS指令、<code>yield</code>、自旋和睡眠机制的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __lock_t &#123;</span><br><span class="line">    int flag;</span><br><span class="line">    int guard;</span><br><span class="line">    queue_t *q;</span><br><span class="line">&#125; lock_t;</span><br><span class="line"></span><br><span class="line">void lock_init(lock_t *m) &#123;</span><br><span class="line">    m-&gt;flag = 0;</span><br><span class="line">    m-&gt;guard = 0;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t *m) &#123;</span><br><span class="line">    while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span><br><span class="line">        ; //acquire guard lock by spinning</span><br><span class="line">    if (m-&gt;flag == 0) &#123;</span><br><span class="line">        m-&gt;flag = 1; // lock is acquired</span><br><span class="line">        m-&gt;guard = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        setpark();  // avoid wakeup/waiting race</span><br><span class="line">        m-&gt;guard = 0;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *m) &#123;</span><br><span class="line">    while (TestAndSet(&amp;m-&gt;guard, 1) == 1)</span><br><span class="line">        ; //acquire guard lock by spinning</span><br><span class="line">    if (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = 0; // let go of lock; no one wants it</span><br><span class="line">    else</span><br><span class="line">        unpark(queue_remove(m-&gt;q)); // hold lock (for next thread!)</span><br><span class="line">    m-&gt;guard = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该锁的内部嵌套了一个用TS指令实现的自旋锁，对应的变量是<code>guard</code>，保护的关键区是对锁的内部状态的修改和更新过程。</p>
<ul>
<li><code>lock()</code>函数：
<ul>
<li>首先尝试进入关键区</li>
<li>如果能获得锁，则离开关键区</li>
<li>如果不能获得锁，则把自己加入队列中，离开关键区，然后放弃CPU（注意，如果先放弃CPU，则guard永远不会变成0，别的进程就无法获得和释放锁了）</li>
</ul>
</li>
<li><code>unlock()</code>函数：
<ul>
<li>首先尝试进入关键区</li>
<li>如果等待队列为空，则直接放弃锁，并离开关键区</li>
<li>否则从队列中唤醒一个线程（注意，此时<code>flag</code>并不会被置为0，因为被唤醒的线程此时回到了<code>park()</code>执行完毕的地方，它已经离开了关键区，因此也不应该尝试把<code>flag</code>设为1；因此，我们直接把锁交给下一个线程，重甲不进行释放）</li>
</ul>
</li>
</ul>
<p>另一个可能存在的问题是，如果没有<code>setpark()</code>一句，且请求锁的线程在<code>park()</code>之前被打断，那么如果此时锁被释放了，重新被唤醒的请求线程会继续执行<code>park()</code>，并永远沉睡下去。<code>setpark()</code>可以解决这个问题：在调用它之后，如果线程在调用<code>park()</code>之前被打断，且其他的线程对它调用了<code>unpark()</code>，那么该线程随后对<code>park()</code>的调用会立即返回。</p>
<h4 id="一个实际的锁的实现"><a class="markdownIt-Anchor" href="#一个实际的锁的实现"></a> 一个实际的锁的实现</h4>
<p>这个实现利用了Linux中的两个函数：</p>
<ul>
<li><code>futex_wait(address, expected)</code>：如果address处的值与expected相等，则睡眠，否则返回</li>
<li><code>futex_wake(address)</code>：唤醒一个在该地址的队列中等待的线程</li>
</ul>
<p>这个实现中，一个整数（mutex）用于跟踪锁是否被持有（最高位）和等待该锁的线程数（其他所有位）。所以，如果mutex为负数，则锁被持有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void mutex_lock (int *mutex) &#123;</span><br><span class="line">	int v;</span><br><span class="line">	/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span><br><span class="line">	if (atomic_bit_test_set (mutex, 31) == 0)</span><br><span class="line">		return;</span><br><span class="line">	atomic_increment (mutex);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		if (atomic_bit_test_set (mutex, 31) == 0) &#123;</span><br><span class="line">			atomic_decrement (mutex);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		/* We have to wait now. First make sure the futex value</span><br><span class="line">		we are monitoring is truly negative (i.e. locked). */</span><br><span class="line">		v = *mutex;</span><br><span class="line">		if (v &gt;= 0)</span><br><span class="line">			continue;</span><br><span class="line">		futex_wait (mutex, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mutex_unlock (int *mutex) &#123;</span><br><span class="line">	/* Adding 0x80000000 to the counter results in 0 if and only if there are not other interested threads */</span><br><span class="line">	if (atomic_add_zero (mutex, 0x80000000))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* There are other threads waiting for this mutex,</span><br><span class="line">	wake one of them up. */</span><br><span class="line">	futex_wake (mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mutex_lock</code>函数：
<ul>
<li>如果该锁空闲，则返回</li>
<li>否则等待线程数+1，并开始循环</li>
<li>在每次循环中，如果发现该锁空闲，则获得该锁（使用的是TS指令），等待线程数-1，并返回</li>
<li>如果发现该锁不空闲，在等待之前重新进行一次检查，如果发现锁空闲则继续循环；否则开始睡眠</li>
</ul>
</li>
<li><code>mutex_unlock</code>函数：
<ul>
<li>将最高位置0的同时检查是否有其他线程在等待，如果没有，则直接返回</li>
<li>如果有，则唤醒一个等待中的线程</li>
</ul>
</li>
</ul>
<p>其中，在尝试睡眠的过程中，<code>futex_wait</code>函数的特性保证了“wakeup/waiting race”不会发生：首先读出<code>mutex</code>处的值，确保此时锁不空闲；即使此时被打断，<code>mutex</code>处的值被修改，<code>futex_wait</code>也会因为两个值不相等而返回，不会永远进入睡眠状态。</p>
<h4 id="两阶段锁"><a class="markdownIt-Anchor" href="#两阶段锁"></a> 两阶段锁</h4>
<p>这个锁的原理是混合了自旋锁和队列睡眠机制。好像没有什么好说的。</p>
<h2 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h2>
<p>没有做。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-2018-midterm-summary/">
              
                  《操作系统》2018年期中考试总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-04-17
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>考试题来自<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring/MidExam?action=AttachFile&amp;do=view&amp;target=20180412-%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE-v8.pdf" target="_blank" rel="noopener">2018年春季学期操作系统课期中考试</a>。</p>
<h2 id="对错题"><a class="markdownIt-Anchor" href="#对错题"></a> 对错题</h2>
<ol>
<li>进程执行系统调用，从用户态切换到内核态执行时，将切换页表和栈。（×）</li>
</ol>
<p>从用户态切换到内核态执行时并不切换页表。大概是因为直接使用了映射的内核空间。</p>
<hr>
<ol start="2">
<li>进程切换的具体执行过程发生在内核态。（√）</li>
</ol>
<p>显然uCore中确实是这么实现的。而且进程切换需要特权指令（如写CR3寄存器），因此必须在内核态下进行。</p>
<hr>
<ol start="3">
<li>OS不能让运行在OS内核空间的内核线程和用户线程之间进行进程切换。（×）</li>
</ol>
<p>事实上是可以的。Lab5中，就是在创建了用户进程之后，从内核线程切换到用户进程的。</p>
<hr>
<ol start="4">
<li>OS在建立页表并使能页机制时，需要特权指令才能最终完成。（√）</li>
</ol>
<p>对于X86和MIPS架构，使能页机制的指令都是特权指令。</p>
<hr>
<ol start="5">
<li>如果用户态进程一直执行死循环将导致OS内核一直无法控制CPU。（×）</li>
</ol>
<p>只要硬件提供了硬件中断的支持，OS就可以中断该用户态进程了。</p>
<hr>
<ol start="6">
<li>二次机会（时钟）页面替换算法有Belady异常现象。（√）</li>
</ol>
<p>（从未听说过二次机会这个名字。）时钟算法和扩展的时钟算法都有Belady现象。反例来自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=214" target="_blank" rel="noopener">Piazza</a>。</p>
<p>因如果所有页的访问位都为1时，clock算法将退化为FIFO，可以构造如下序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d,a,b,e,a,b,c,d,e</span><br></pre></td></tr></table></figure>
<p>当物理页帧为3时，缺页次数为9次，当物理页帧为4时，缺页次数为10次。</p>
<hr>
<ol start="7">
<li>OS内核会直接杀死产生内存访问异常的用户进程。（×）</li>
</ol>
<p>显然，内存访问异常有多种情况，权限错误，地址不合法，或者是缺页。访问越界这种情况确实会导致OS杀死进程（SEGMENTATION FAULT==），但缺页异常下肯定不是杀死这个进程，而是将缺的页换入，重新执行产生缺页异常的指令。</p>
<hr>
<ol start="8">
<li>由于栈的原因，在OS内核中不能执行系统调用（syscall）来获得OS内核的服务。（×）</li>
</ol>
<p>系统调用可以在同特权级下进行，此时不进行栈的切换。</p>
<hr>
<ol start="9">
<li>对于子进程而言，<code>fork()</code>执行不成功后的返回值&lt;0。（√）</li>
</ol>
<p>我觉得这道题的脑回路很奇异。按照一般的想法，父进程执行<code>fork()</code>之后，如果成功，则创建子进程，父进程处<code>fork()</code>的返回值为子进程的PID，子进程处<code>fork()</code>的返回值为0。如果父进程执行<code>fork()</code>不成功，则返回负值，此时也就没有子进程了。所以这道题不知如何选。</p>
<p>而老师解释说，这道题目说的是“fork出来的子进程再次进行fork的情况”。这就只不过是普通的<code>fork()</code>而已了。</p>
<hr>
<ol start="10">
<li>如果不考虑执行性能，ucore on x86-32可实现LRU页替换算法。（√）</li>
</ol>
<p>因为<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1183" target="_blank" rel="noopener">有人真的实现了</a>，所以是对的。大致的思路是，强制每次页访问都触发一个页访问异常，利用这个页访问就可以知道究竟发生了什么样的访存操作，以及这些操作的先后次序。这样的方案能够得到准确的LRU信息。</p>
<h2 id="填空题"><a class="markdownIt-Anchor" href="#填空题"></a> 填空题</h2>
<p>小强同学认真上课听讲，参与讨论，并完成了从lab0~lab3的所有实验，在学习过程中，了解和学到了很多知识。下面是他的学习心得，请补充完整。</p>
<h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3>
<p>小强发现完成实验需要在Linux下操作很多命令行工具，于是他认真学习了lab0中的知识，了解到Linux中在命令行模式下可以通过执行命令（<strong>1.1</strong>）来显示当前目录的路径，如果我们编写的程序有语法错误，编译器（<strong>1.2</strong>）会报错，根据错误信息，我们可以修改我们的程序，可以通过硬件模拟器工具（<strong>1.3</strong>）来执行我们的ucore操作系统。</p>
<hr>
<ol>
<li>pwd</li>
<li>gcc</li>
<li>qemu (system i386)</li>
</ol>
<p>这些都很简单，做了实验的人应该都会（虽然pwd其实很少用，因为prompt前面一般都会显示路径……）</p>
<h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3>
<p>在完成lab 1的过程中，通过分析硬件模拟器工具对CPU状态的输出信息，可了解到基于80386的计算机在加电后执行BIOS代码时处于（<strong>2.1</strong>）模式。而os lab 1中的bootloader通过建立（<strong>2.2</strong>）表可让计算机进入（<strong>2.3</strong>）模式，从而可以充分利用80386 CPU提供的保护能力和32位内存寻址空间。os lab 1中的ucore os为了能够对异常／中断等进行有效管理，需要建立（<strong>2.4</strong>）表，才能使能中断，让ucore os进行进一步的中断处理。在学习80386特权级时，对CPL、RPL和DPL需要满足如下两个公式确保系统安全：访问（<strong>2.5</strong>）时，CPL&lt;=DPL[门] &amp; CPL&gt;=DPL[段]；访问（<strong>2.6</strong>）时，MAX(CPL, RPL)&lt;=DPL。</p>
<hr>
<ol>
<li>8086模式/实模式</li>
<li>段表/GDT表/全局描述符表</li>
<li>保护模式</li>
<li>中断描述符表/IDT表</li>
<li>中断门</li>
<li>段</li>
</ol>
<h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3>
<p>1.3在完成lab2的过程中，需要了解x86-32的内存大小与布局，页机制，页表结构等。硬件模拟器提供了128MB的内存，并设定页目录表的起始地址存放（<strong>3.1</strong>）寄存器中，页目录表和页表的地址按（<strong>3.2</strong>）字节对齐。在一个页目录表占用（<strong>3.3</strong>）个Byte，一个页表占用（<strong>3.4</strong>）个Byte。ucore<br>
通过x86-32 CPU中的（<strong>3.5</strong>）寄存器可以获得发生页面访问错误时的线性地址。</p>
<hr>
<ol>
<li>CR3</li>
<li>4K</li>
<li>4K</li>
<li>4K</li>
<li>CR2</li>
</ol>
<h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3>
<p>在完成lab3的过程中，ucore操作系统在页机制基础上，并利用异常机制建立了虚存管理策略与机制。如果一个页（4KB/页）被置换到了硬盘某8个连续扇区（0.5KB/扇区），该页对应的页表项（PTE）的最低位——present（存在位）应该为（<strong>4.1</strong>），表示虚实地址映射关系不存在，而原来用来表示页帧号的高（<strong>4.2</strong>）位，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。</p>
<hr>
<ol>
<li>0</li>
<li>20</li>
</ol>
<h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3>
<p>在学习进程的概念中，了解到在支持多进程的操作系统（包括ucore)中，每个进程有两个堆栈，分别是（<strong>5.1</strong>）栈和（<strong>5.2</strong>）栈。操作系统通过建立（<strong>5.3</strong>）这个核心数据结构来支持对进程的管理。对于进程的三状态模型，是指进程在执行过程中会具有（<strong>5.4</strong>），（<strong>5.5</strong>），（<strong>5.6</strong>）三种状<br>
态。在操作系统具有进程地址空间为单位的swap in/out虚存管理机制，可建立进程的五状态模型，将增加（<strong>5.7</strong>），（<strong>5.8</strong>）。</p>
<hr>
<ol>
<li>内核</li>
<li>用户</li>
<li>PCB/进程控制块</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>就绪挂起态</li>
<li>就绪等待态</li>
</ol>
<h2 id="问答题"><a class="markdownIt-Anchor" href="#问答题"></a> 问答题</h2>
<h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h3>
<p>在Linux环境下，下列程序调用<code>magic</code>函数的次数是多少？如果一个程序死循环调用<code>fork()</code>系统调用，会出现什么情况？请说明原因。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        fork();</span><br><span class="line">    magic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="fork_bomb.jpg" alt="调用过程图"></p>
<p>如上图，最终会得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">2^10 = 1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span>个进程，即进行<code>fork()</code>系统调用1024次。</p>
<p>一个程序死循环调用<code>fork()</code>系统调用，则被称为“<code>fork()</code>炸弹”，因为进程会以指数级别增加。在实际的机器上尝试<code>fork()</code>炸弹的后果是：机器不会死机，但是无法创建新的程序了，因为进程控制块资源耗尽了。这不会导致失去对电脑控制权，仍然可以通过Ctrl+C终止程序。</p>
<h3 id="用户线程"><a class="markdownIt-Anchor" href="#用户线程"></a> 用户线程</h3>
<p>用户线程是指由一组用户线程管理库函数来完成线程的管理功能，包括线程的创建、终止、同步和调度等。假设处于仅通过用户线程管理库管理用户线程的操作系统环境，请回答下列问题：</p>
<ol>
<li>操作系统内核是否需要知道用户线程的存在？请说明理由。</li>
<li>用户线程管理库实现的线程切换是否需要进入内核态，通过操作系统内核来完成？请说明理由。</li>
<li>用户态线程管理库是否可以随时打断用户态线程，完成线程调度与切换？请阐述理由或方法。</li>
</ol>
<hr>
<ol>
<li>OS内核不需要知道用户库维护的线程的存在，如果它知道，也就没有用户线程的意义了，变成了内核线程。</li>
<li>线程切换不需要进入内核态，因为线程的页表是共享的，其他现场信息不需要特权指令来保存，所以可以在用户态切换。</li>
<li>能，因为OS可以通知线程管理库发生中断（发出软件中断）。也可以回答不能，因为在用户态不能实现中断。重点是自圆其说。</li>
</ol>
<h3 id="页表访问时间"><a class="markdownIt-Anchor" href="#页表访问时间"></a> 页表访问时间</h3>
<p>在一个只有一级页表的请求页式存储管理系统中，假定页表内容如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">页框（Page Frame）号</th>
<th style="text-align:center">有效位（存在位）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">123H</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">254H</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>页面大小为4KB，一次内存的访问时间是100ns，一次快表（TLB）的访问时间是10ns，处理一次缺页的平均时间为1e7ns（己经包含更新TLB和页表的时间），进程的驻留集大小固定为2，采用最近最少使用置换算法(LRU)和局部淘汰策略。假设：</p>
<ul>
<li>TLB初始为空；</li>
<li>地址转换时先访问TLB，若TLB没有命中，再访问页表（忽略访问页表之后的TLB更新时间）；</li>
<li>有效位为0表示页面不在内存，产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行。</li>
</ul>
<p>设有虚地址访问序列2362H，1565H，25A5H，请问：</p>
<ol>
<li>依次访问上述三个虚地址，各需要多少时间？给出计算过程？</li>
<li>基于上述访问序列，虚地址1565H的物理地址是多少？请说明理由。</li>
</ol>
<hr>
<p>首先访问2362H，页号为2H，偏移量为362H。查找TLB未命中（10ns），查找页表得到页框号为254H（100ns），更新TLB（略），计算出物理地址为254362H，访存（100ns），总时间为210ns。</p>
<p>然后访问1565H，页号为1H，偏移量为565H。查找TLB未命中（10ns），查找页表发现缺页（100ns），根据LRU算法，将第0页换出，将第1页换入到页号为123H的物理页帧，更新TLB和页表（1e7ns），访存（100ns），总时间约为1e7ns。</p>
<p>最后访问25A5H，页号为2H，偏移量为5A5H。查找TLB命中（10ns），计算出物理地址为2545A5H，访存（100ns），总时间为110ns。</p>
<p>由于第1页现在位于页号为123H的物理页帧中，因此虚地址1565H的物理地址是123565H。</p>
<h3 id="risc-v页表"><a class="markdownIt-Anchor" href="#risc-v页表"></a> RISC-V页表</h3>
<p>2017年图灵奖得主John L. Hennessy和David A. Patterson提出了RISC-V架构的32位小端序CPU设计，它有34位地址总线，使用32位页式存储管理。该计算机的页面大小为4KiB，一个页表大小为4KiB，其中每一个页表项(Page Table Entry，PTE)大小为4B，虚拟地址、物理地址和PTE的结构如下图所示。</p>
<p><img src="page_table_structure.png" alt="虚拟地址、页表项和物理地址结构"></p>
<p>如上图所示，一个虚拟地址由虚拟页号(Virtual Page Number，VPN)和页内偏移组成，物理地址由物理页号(Physical Page Number，PPN)和页内偏移组成，PTE由PPN和一些控制位组成，其中R/W/X三个域分别表示对应页的读/写/执行权限，它们的不同组合可以表示不同的属性，如下表所示：</p>
<table>
<thead>
<tr>
<th>X</th>
<th>W</th>
<th>R</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>This PTE points to next level of page table.</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>Read-only page.</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>Read-write page.</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Execute-only page.</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>Read-execute page.</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Read-write-execute page.</td>
</tr>
</tbody>
</table>
<p>请回答下列问题：</p>
<ol>
<li>32-bit的RISC-V架构CPU使用34位物理地址而不是32位物理地址，这样做的好处是什么？</li>
<li>设页目录基址为0x90000000，部分物理内存的内容如下图所示，试给出虚拟地址0x3A69A4D2和0x3A8EB00C所对应的物理地址和它们所在页的类型。请写出计算过程。</li>
</ol>
<p><img src="memory_content.png" alt="部分内存中的内容"></p>
<hr>
<p>第一题的答案是显然的：34位物理地址可以寻址16G的内存，这显然是好的。</p>
<p>第二题就比较复杂了。首先计算出两个虚拟地址对应的各项。由于单个页表项的大小是4B，可以通过VPN[1]计算出页表项所在的地址为<code>0x90000000+4*VPN[1]</code>，并读出页表项（注意是<strong>小端</strong>存储）。</p>
<table>
<thead>
<tr>
<th>虚拟地址</th>
<th>VPN[1]</th>
<th>VPN[0]</th>
<th>offset</th>
<th>PTE地址</th>
<th>PTE</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3A69A4D2</td>
<td>0xE9</td>
<td>0x29A</td>
<td>0x4D2</td>
<td>0x900003A4</td>
<td>0x28000001</td>
</tr>
<tr>
<td>0x3A8EB00C</td>
<td>0xEA</td>
<td>0xEB</td>
<td>0x00C</td>
<td>0x900003A8</td>
<td>0x3EB0000F</td>
</tr>
</tbody>
</table>
<p>可以发现，0x28000001的XWR=000，因此它是一个一级页表项，指向的是一个二级页表，它的基地址是0xA0000000。二级页表项的地址<code>=0xA0000000+4*VPN[0]=0xA0000A68</code>，读出二级页表项为0x37AB6C09，它指向一个可执行的页，页的基地址为0xDEADB000。物理地址=页基地址+偏移量=0xDEADB000+0x4D2=0xDEADB4D2。</p>
<p>而0x3EB0000F的XWR=111，也就是说，它指向一个可写可读可执行的页。不妨进行大胆的猜测：这个页的大小是4MB，虚拟地址中的<code>VPN[0]</code>和offset共同作为页内的偏移量；而页表项中的<code>PPN[1]</code>就是页基址的高12位。由此可得，页基址<code>=0xFAC00000</code>，物理地址=页基址+偏移量<code>=0xFAC00000+0xEB00C=0xFACEB00C</code>。</p>
<p>关于RISC-V内存管理的更多内容可以参见<a href="https://en.wikipedia.org/wiki/RISC-V#Memory_access" target="_blank" rel="noopener">wiki</a>或RISC-V的文档，不过我一时是懒得去读了。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>我觉得今年的题目比去年的难度更大，特别是最后一题，如果没有仔细阅读过硬件内存管理部分，很难想象到一级页表项管理的页是特殊的，大小为4MB。其余的部分都比较基础了。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/tags/OS/">
                      <section class="post prev">
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  2 / 3
              </p>
              
                  <a class="next" rel="next" href="/tags/OS/page/3/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
    console.log("mathjax did loaded!");
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
