<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Tag: OS | 张慕晖的博客</title>
  
  

  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  
  <!-- link -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css">

  
  
  <link rel="undefined" href>
  
  

  


  
  <link rel="stylesheet" href="/style.css">
  

  



  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-119345306-1', 'https://zhanghuimeng.github.io/');
      ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class="wrapper">
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href="/">
        
          张慕晖的博客
        
      </a>
			<div class="menu">
				<ul class="h-list">
          
  					
  						<li>
								<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
									<i class="fas fa-home fa-fw"></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a id="tags" class="nav flat-box" href="/tags/">
									<i class="fas fa-rss fa-fw"></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a id="archives" class="nav flat-box" href="/archives/">
									<i class="fas fa-archive fa-fw"></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a id="categories" class="nav flat-box" href="/categories/">
									<i class="fas fa-users fa-fw"></i>&nbsp;分类
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索">
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class="switcher h-list">
				
					<li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li>
				
				<li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>

		<div class="nav-sub container container--flex">
			<a class="logo flat-box"></a>
			<ul class="switcher h-list">
				<li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li>
				<li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
              
                  <li>
										<a id="https:zhanghuimeng.github.io" class="nav flat-box" href="https://zhanghuimeng.github.io/">
											<i class="fas fa-home fa-fw"></i>&nbsp;主页
										</a>
                  </li>
              
                  <li>
										<a id="tags" class="nav flat-box" href="/tags/">
											<i class="fas fa-rss fa-fw"></i>&nbsp;标签
										</a>
                  </li>
              
                  <li>
										<a id="archives" class="nav flat-box" href="/archives/">
											<i class="fas fa-archive fa-fw"></i>&nbsp;归档
										</a>
                  </li>
              
                  <li>
										<a id="categories" class="nav flat-box" href="/categories/">
											<i class="fas fa-users fa-fw"></i>&nbsp;分类
										</a>
                  </li>
              
       
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            
    <script>
        window.subData= { title:'标签 : OS'}
    </script>




  <section class="post-list">
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      



      

      

      
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-05-homework-coding-process-apis/">
              
                  OSTEP第05章作业：Coding: Process APIs
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-08-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章作业见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf</a>。</p>
<hr>
<p>在本次作业中，你将熟悉刚讲到的进程管理API的用法。这可是很有趣的，代码写得越多越好。所以赶紧去写吧。</p>
<p>（以下代码运行结果来自Ubuntu 16.04）</p>
<h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h2>
<p>写一个程序，调用<code>fork()</code>。在调用<code>fork()</code>之前，让主进程设置一个变量（如<code>x</code>）的值（如100）。子进程中这个变量的值是多少？当子进程和父进程都修改<code>x</code>的值时，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw01.c" target="_blank" rel="noopener">hw01.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw01</span><br><span class="line">x = 100 (pid:2597)</span><br><span class="line">parent: x = 100 (pid:2597)</span><br><span class="line">parent: x = 101 (pid:2597)</span><br><span class="line">child: x = 100 (pid:2598)</span><br><span class="line">child: x = 99 (pid:2598)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，子进程中<code>x</code>的值仍然为100，且父进程和子进程对<code>x</code>的修改是互相独立的。这是因为<code>fork()</code>系统调用把内存空间复制了一份（或者大概用了COW机制，不过这个暂时并不重要）。</p>
<h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h2>
<p>写一个程序，通过<code>open()</code>系统调用打开一个文件，并调用<code>fork()</code>创建一个新的进程。子进程和父进程可以同时访问<code>open()</code>返回的文件描述符吗？如果它们同时写这个文件，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw02.c" target="_blank" rel="noopener">hw02.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw02</span><br><span class="line">prompt&gt; cat hw02.output</span><br><span class="line">I am parent</span><br><span class="line">I am child</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，子进程和父进程可以同时访问这个文件，且输出结果基本是正常的。Linux实际上并不会保证并发的文件操作不出问题。不过，其实Linux的内部实现保证了<code>read()</code>和<code>write()</code>操作是串行执行的。详情可见<a href="https://stackoverflow.com/questions/2751734/how-do-filesystems-handle-concurrent-read-write" target="_blank" rel="noopener">How do filesystems handle concurrent read/write?</a>。</p>
<h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h2>
<p>再写一个调用<code>fork()</code>的程序。令子进程打印<code>&quot;hello&quot;</code>，父进程打印<code>&quot;goodbye&quot;</code>。你能否在父进程中不调用<code>wait()</code>的情况下保证子进程总是先打印？</p>
<hr>
<p>我感觉上一道题暗示我们，让子进程打印一点东西到文件中，然后在父进程中不断查看该文件中是否含有希望的信息。但我感觉这个做法可能不太可取。查了一些资料之后，我尝试让父进程用<a href="https://linux.die.net/man/2/kill" target="_blank" rel="noopener">kill(2)</a>检查子进程是否正在运行，但是我发现这也不可行，因为对僵尸进程进行这一检查也会返回<code>0</code>。事实上最科学的做法就是<code>wait()</code>系统调用了……所以我干脆用<code>waitpid()</code>好了。</p>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw03.c" target="_blank" rel="noopener">hw03.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw03</span><br><span class="line">Hello, I am child</span><br><span class="line">Goodbye, I am parent</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h2>
<p>写一个程序，调用<code>fork()</code>，然后通过某种形式的<code>exec()</code>运行<code>/bin/ls</code>。你能否尝试使用<code>exec()</code>的所有变形，包括<code>execl()</code>、<code>execle()</code>、<code>execlp()</code>、<code>execv()</code>、<code>execp()</code>和<code>execvpe()</code>？这个调用为何有这么多种形式？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw04.c" target="_blank" rel="noopener">hw04.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw04</span><br><span class="line">Parent: ready for execl(const char *path, const char *arg, ... /* (char  *) NULL */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execlp(const char *file, const char *arg, ... /* (char  *) NULL */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */)</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execv(const char *path, char *const argv[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execvp(const char *file, char *const argv[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">Parent: ready for execvpe(const char *file, char *const argv[], char *const envp[])</span><br><span class="line">bin    etc	   lib32       media  root  sys  vmlinuz</span><br><span class="line">boot   home	   lib64       mnt    run   tmp</span><br><span class="line">cdrom  initrd.img  libx32      opt    sbin  usr</span><br><span class="line">dev    lib	   lost+found  proc   srv   var</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>我猜这些形式主要是为了满足用户不同的需求。实际上，<code>exec</code>后面的那些后缀的含义是这样的（参见了<a href="http://www.cnblogs.com/mickole/p/3187409.html" target="_blank" rel="noopener">linux系统编程之进程（五）：exec系列函数（execl,execlp,execle,execv,execvp)使用</a>）：</p>
<ul>
<li><code>l</code>：参数以可变参数列表的形式给出，且以<code>NULL</code>结束（<code>execl()</code>，<code>execle()</code>，<code>execlp()</code>）</li>
<li>没有<code>l</code>：参数以<code>char *arg[]</code>形式给出，且<code>arg</code>最后一个元素必须为<code>NULL</code>（<code>execv()</code>，<code>execp()</code>，<code>execvpe()</code>）</li>
<li><code>p</code>：第一个参数不用输入完整路径，给出命令名即可，程序会在环境变量PATH当中查找命令（<code>execlp()</code>，<code>execp()</code>，<code>execvpe()</code>）</li>
<li>没有<code>p</code>：第一个参数需要输入完整路径（<code>execl()</code>，<code>execle()</code>，<code>execv()</code>）</li>
<li><code>e</code>：将环境变量传递给新进程（<code>execle()</code>，<code>execvpe()</code>）</li>
<li>没有<code>e</code>：不传递环境变量（<code>execl()</code>，<code>execlp()</code>，<code>execv()</code>，<code>execp()</code>）</li>
</ul>
<h2 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h2>
<p>写一个程序，让父进程调用<code>wait()</code>，等待子进程完成。<code>wait()</code>将返回什么？如果在子进程中调用<code>wait()</code>，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw05.c" target="_blank" rel="noopener">hw05.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw05</span><br><span class="line">I am parent (pid:4154)</span><br><span class="line">I am child (pid:4155)</span><br><span class="line">Child: wait() returns -1</span><br><span class="line">Parent: wait() returns 4155</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>如果<a href="http://man7.org/linux/man-pages/man2/waitpid.2.html" target="_blank" rel="noopener">wait(2)</a>找到了至少一个状态已经变化的子进程，则它会返回这个子进程的PID（因此此处父进程返回了子进程的PID，4155）；而子进程自己没有子进程，因此调用失败，返回<code>-1</code>。</p>
<h2 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h2>
<p>稍微修改一下上一题中的程序，改为使用<code>waitpid()</code>，而不是<code>wait()</code>。<code>waitpid()</code>何时是有用的？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw06.c" target="_blank" rel="noopener">hw06.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw06</span><br><span class="line">I am parent (pid:4368)</span><br><span class="line">I am child (pid:4369)</span><br><span class="line">Child: waitpid(-1) returns -1</span><br><span class="line">Parent: waitpid(4369) returns 4369</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>在需要等待某一个子进程执行完毕时，可以使用<code>waitpid()</code>。调用<code>waitpid(-1)</code>的效果与<code>wait()</code>基本是类似的。</p>
<h2 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h2>
<p>写一个程序，创建一个子进程，并在子进程中关闭标准输出（<code>STDOUT_FILENO</code>）。在关闭该文件描述符之后，如果子进程调用<code>printf()</code>来打印输出，会发生什么？</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw07.c" target="_blank" rel="noopener">hw07.c</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw07</span><br><span class="line">I am parent</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>结果，无论是关闭之前还是关闭之后的<code>printf</code>都没有在屏幕打印出结果。我并没有查到为什么……</p>
<h2 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h2>
<p>写一个程序，创建两个子进程，通过<code>pipe()</code>系统调用，把其中一个进程的标准输出连接到另一个的标准输入。</p>
<hr>
<p>程序代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/blob/master/ch05_Process-API/hw08.c" target="_blank" rel="noopener">hw08.c</a>，参考了<a href="http://sealbird.iteye.com/blog/867908" target="_blank" rel="noopener">UNIX管道编程——使用pipe函数，dup函数，dup2函数</a>。</p>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./hw08</span><br><span class="line">Child 1 (pid=4727), writing to pipe.</span><br><span class="line">Child 2 (pid=4728), reading from pipe.</span><br><span class="line">Hello world , this is transported by pipe.</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-04-homework-simulation-process-run-py/">
              
                  OSTEP第04章作业：Simulation: process-run.py
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-08-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章作业见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a>和<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/HW-CPU-Intro.tgz" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/HW-CPU-Intro.tgz</a>。</p>
<hr>
<p>作业说明和模拟器代码见<a href="https://github.com/zhanghuimeng/ostep-hw-translation/tree/master/ch04_Process-Intro" target="_blank" rel="noopener">https://github.com/zhanghuimeng/ostep-hw-translation/tree/master/ch04_Process-Intro</a>。</p>
<p>这次作业没有明确地说明调度策略——这也是因为现在还没有介绍到调度策略这么复杂的东西。通过阅读代码，我发现选择下一个运行进程的策略是通过PID进行循环查找：从当前进程的PID开始，如果这个进程处于就绪态，则选择它；否则<code>PID = (PID + 1) % 进程总数</code>。这个策略不太实际（有点类似于FIFO，但是优先级依赖于PID），但显然对于手动模拟比较方便。</p>
<h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h2>
<p>用以下参数运行程序：<code>./process-run.py -l 5:100,5:100</code>。CPU利用率（CPU处于使用状态的时间比例）是多少？为什么？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>我猜测Process0会先运行5个时间片；Process0运行完之后，Process1再运行5个时间片，也会结束。因为CPU运行完Process0就运行了Process1，中间没有空闲的时间，因此CPU利用率为100%。</p>
<p>运行结果如下（因为是win环境，所以用的是python）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 5:100,5:100 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2     RUN:cpu      READY          1</span><br><span class="line">  3     RUN:cpu      READY          1</span><br><span class="line">  4     RUN:cpu      READY          1</span><br><span class="line">  5     RUN:cpu      READY          1</span><br><span class="line">  6        DONE    RUN:cpu          1</span><br><span class="line">  7        DONE    RUN:cpu          1</span><br><span class="line">  8        DONE    RUN:cpu          1</span><br><span class="line">  9        DONE    RUN:cpu          1</span><br><span class="line"> 10        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 10</span><br><span class="line">Stats: CPU Busy 10 (100.00%)</span><br><span class="line">Stats: IO Busy  0 (0.00%)</span><br></pre></td></tr></table></figure>
<p>可以看出这个推测是正确的。</p>
<h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h2>
<p>用以下参数运行程序：<code>./process-run.py -l 4:100,1:0</code>。这些参数给定了两个进程，其中一个包含4条CPU指令，另一个只发出一个I/O请求并等待请求结束。两个进程都结束执行需要多长时间？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>Process0不发出I/O请求，因此它会一直执行到结束，共花费4个时间片。Process1发出一个I/O请求（1个时间片），I/O请求执行完毕需要5个时间片；因此，一共需要10个时间片结束执行。</p>
<p>运行结果如下（实际上刚才的结果参考了运行结果，因为我不知道所谓的“I/O请求花费5个时间片”算不算发出请求的指令的时间……当然从情理上和实验上来说都是不算的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 4:100,1:0 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2     RUN:cpu      READY          1</span><br><span class="line">  3     RUN:cpu      READY          1</span><br><span class="line">  4     RUN:cpu      READY          1</span><br><span class="line">  5        DONE     RUN:io          1</span><br><span class="line">  6        DONE    WAITING                     1</span><br><span class="line">  7        DONE    WAITING                     1</span><br><span class="line">  8        DONE    WAITING                     1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 10</span><br><span class="line">Stats: CPU Busy 5 (50.00%)</span><br><span class="line">Stats: IO Busy  4 (40.00%)</span><br></pre></td></tr></table></figure>
<h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h2>
<p>现在切换进程的顺序：<code>./process-run.py -l 1:0,4:100</code>。切换顺序对于结束执行的时间有影响吗？继续用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>显然有影响，因为Process0发出一个I/O请求（花费1个时间片）后，就会切换到Process1开始执行（4个时间片）；与此同时，I/O请求需要5个时间片完成。因此执行时间减少到了6个时间片。这说明了进程切换的必要性，因为增加了并行性，可以增加各种设备的利用率。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 6</span><br><span class="line">Stats: CPU Busy 5 (83.33%)</span><br><span class="line">Stats: IO Busy  4 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h2>
<p>下面我们探索一下其他的参数。参数<code>-S</code>指定了进程发出I/O请求时系统的反应策略。当该参数的值为<code>SWITCH_ON_END</code>时，系统不会在当前进程发出I/O请求时切换到另一个进程，而是等待进程结束之后再切换。如果你用以下参数运行程序（<code>-l 1:0,4:100 -c -S SWITCH_ON_END</code>），会发生什么？</p>
<hr>
<p>这道题的进程配置和上一道题一样，但是如果在进程发出I/O请求时不切换，就相当于必须执行完当前进程才能切换到下一个，这样设备利用率显然会下降，而运行时间会增加。Process0执行完需要6个时间片，Process1需要4个时间片，因此总时间为10个时间片，与进程顺序颠倒时相同。</p>
<p>运行结果如下（好吧，这说明我的分析有一点问题，这似乎与结束的总时间如何计算有关）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING      READY                     1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6*       DONE    RUN:cpu          1</span><br><span class="line">  7        DONE    RUN:cpu          1</span><br><span class="line">  8        DONE    RUN:cpu          1</span><br><span class="line">  9        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 9</span><br><span class="line">Stats: CPU Busy 5 (55.56%)</span><br><span class="line">Stats: IO Busy  4 (44.44%)</span><br></pre></td></tr></table></figure>
<h2 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h2>
<p>现在把<code>-S</code>参数的值置为SWITCH_ON_IO，此时只要进程发出I/O请求，就会切换到别的进程。（参数为<code>-l 1:0,4:100 -c -S SWITCH_ON_IO</code>）。那么，会发生什么呢？用参数<code>-c</code>和<code>-p</code>验证你的回答的正确性。</p>
<hr>
<p>把参数设置成这样似乎就是默认值。结论是和第4题的分析相同吧？</p>
<p>运行结果如下（是的，的确如此）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 6</span><br><span class="line">Stats: CPU Busy 5 (83.33%)</span><br><span class="line">Stats: IO Busy  4 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h2>
<p>I/O请求结束时系统的执行策略也很重要。如果将参数<code>-I</code>的值置为<code>IO_RUN_LATER</code>，则I/O请求完成时，发出请求的进程不会立刻开始执行，当前运行中的进程会继续运行。如果使用以下参数组合，会发生什么？（<code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER</code>）</p>
<hr>
<p><code>IO_RUN_LATER</code>似乎就是默认值。Process0首先发出一个I/O请求（1个时间片），之后Process1，Process2和Process3依次执行完毕（共15个时间片）；最后Process0再重新开始执行，花费10个时间片进行两个I/O请求。然后，似乎因为最后一条指令为I/O指令，所以需要多花一个时间片确认为DONE（这一点是根据运行结果凑出来的）。因此总时间为27个时间片。</p>
<p>这个调度方法比较愚蠢，如果把Process0的I/O请求分散开，可以提高CPU和I/O设备的利用率。这说明在设计调度策略的时候，我们应当考虑到I/O密集型进程和CPU密集型进程的不同特点。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1     PID: 2     PID: 3        CPU        IOs</span><br><span class="line">  1      RUN:io      READY      READY      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  3     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  4     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  5     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  6*      READY    RUN:cpu      READY      READY          1</span><br><span class="line">  7       READY       DONE    RUN:cpu      READY          1</span><br><span class="line">  8       READY       DONE    RUN:cpu      READY          1</span><br><span class="line">  9       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 10       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 11       READY       DONE    RUN:cpu      READY          1</span><br><span class="line"> 12       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 13       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 14       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 15       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 16       READY       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 17      RUN:io       DONE       DONE       DONE          1</span><br><span class="line"> 18     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 19     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 20     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 21     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 22*     RUN:io       DONE       DONE       DONE          1</span><br><span class="line"> 23     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 24     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 25     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 26     WAITING       DONE       DONE       DONE                     1</span><br><span class="line"> 27*       DONE       DONE       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 27</span><br><span class="line">Stats: CPU Busy 18 (66.67%)</span><br><span class="line">Stats: IO Busy  12 (44.44%)</span><br></pre></td></tr></table></figure>
<h2 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h2>
<p>将参数<code>-I</code>的值换成<code>IO_RUN_IMMEDIATE</code>，重新执行上述命令，此时，当I/O请求完成时，发出请求的进程会立刻抢占CPU。现在程序的运行结果有何不同？为什么让刚刚执行完I/O的进程立刻开始运行可能是个好主意？</p>
<hr>
<p>就像上一题所分析的那样，如果把I/O请求分散开来，则可以提高设备的利用率。在设计调度策略的时候应当考虑到进程的I/O密集程度，这个思路见于多级反馈队列调度算法中——如果进程用完了时间片则下移一个队列；否则，如果在时间片结束之前就发出了I/O请求，则保留在当前队列中。此时花费的总时间就是3条I/O指令加上15条CPU指令的时间。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p</span><br><span class="line">Time     PID: 0     PID: 1     PID: 2     PID: 3        CPU        IOs</span><br><span class="line">  1      RUN:io      READY      READY      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  3     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  4     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  5     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  6*     RUN:io      READY      READY      READY          1</span><br><span class="line">  7     WAITING    RUN:cpu      READY      READY          1          1</span><br><span class="line">  8     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line">  9     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 10     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 11*     RUN:io       DONE      READY      READY          1</span><br><span class="line"> 12     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 13     WAITING       DONE    RUN:cpu      READY          1          1</span><br><span class="line"> 14     WAITING       DONE       DONE    RUN:cpu          1          1</span><br><span class="line"> 15     WAITING       DONE       DONE    RUN:cpu          1          1</span><br><span class="line"> 16*       DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 17        DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"> 18        DONE       DONE       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 18</span><br><span class="line">Stats: CPU Busy 18 (100.00%)</span><br><span class="line">Stats: IO Busy  12 (66.67%)</span><br></pre></td></tr></table></figure>
<h2 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h2>
<p>用下列随机生成的参数组合运行程序，比如<code>-s 1 -l 3:50,3:50</code>，<code>-s 2 -l 3:50,3:50</code>和<code>-s 3 -l 3:50,3:50</code>。你能否预测程序运行结果？将<code>-I</code>参数的值分别置为<code>IO_RUN_IMMEDIATE</code>和<code>IO_RUN_LATER</code>时，运行结果有何区别？将<code>-S</code>参数的值分别置为<code>SWITCH_ON_IO</code>和<code>SWITCH_ON_END</code>时，运行结果有何区别？</p>
<hr>
<h3 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h3>
<p>使用参数<code>-s 1 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  cpu</span><br><span class="line">  cpu</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50 -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING    RUN:cpu          1          1</span><br><span class="line">  4     WAITING    RUN:cpu          1          1</span><br><span class="line">  5     WAITING    RUN:cpu          1          1</span><br><span class="line">  6     WAITING       DONE                     1</span><br><span class="line">  7*     RUN:io       DONE          1</span><br><span class="line">  8     WAITING       DONE                     1</span><br><span class="line">  9     WAITING       DONE                     1</span><br><span class="line"> 10     WAITING       DONE                     1</span><br><span class="line"> 11     WAITING       DONE                     1</span><br><span class="line"> 12*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 12</span><br><span class="line">Stats: CPU Busy 6 (50.00%)</span><br><span class="line">Stats: IO Busy  8 (66.67%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时结果相同，因为Process0发出的I/O请求在Process1完全执行结束之后才完成：</p>
<p><code>-S SWITCH_ON_IO</code>时结果也相同，因为这个是默认值。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间变长，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 1 -l 3:50,3:50 -S SWITCH_ON_END -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6     WAITING      READY                     1</span><br><span class="line">  7*     RUN:io      READY          1</span><br><span class="line">  8     WAITING      READY                     1</span><br><span class="line">  9     WAITING      READY                     1</span><br><span class="line"> 10     WAITING      READY                     1</span><br><span class="line"> 11     WAITING      READY                     1</span><br><span class="line"> 12*       DONE    RUN:cpu          1</span><br><span class="line"> 13        DONE    RUN:cpu          1</span><br><span class="line"> 14        DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 14</span><br><span class="line">Stats: CPU Busy 6 (42.86%)</span><br><span class="line">Stats: IO Busy  8 (57.14%)</span><br></pre></td></tr></table></figure>
<h3 id="82"><a class="markdownIt-Anchor" href="#82"></a> 8.2</h3>
<p>使用参数<code>-s 2 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时，输出如下，出现了两个进程同时I/O的情况（不过此时我们认为I/O是可以并行的，不存在等待I/O设备的问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50 -I IO_RUN_LATER -p -c</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING    RUN:cpu          1          1</span><br><span class="line">  3     WAITING     RUN:io          1          1</span><br><span class="line">  4     WAITING    WAITING                     2</span><br><span class="line">  5     WAITING    WAITING                     2</span><br><span class="line">  6*     RUN:io    WAITING          1          1</span><br><span class="line">  7     WAITING    WAITING                     2</span><br><span class="line">  8*    WAITING     RUN:io          1          1</span><br><span class="line">  9     WAITING    WAITING                     2</span><br><span class="line"> 10     WAITING    WAITING                     2</span><br><span class="line"> 11*    RUN:cpu    WAITING          1          1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 13</span><br><span class="line">Stats: CPU Busy 6 (46.15%)</span><br><span class="line">Stats: IO Busy  11 (84.62%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时，输出完全相同（因为I/O请求很多，所以当前I/O结束之后，CPU处于空闲状态，可以直接开始执行下一条指令）。</p>
<p><code>-S SWITCH_ON_IO</code>时输出完全相同（因为这是默认值……）。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间大大增加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 2 -l 3:50,3:50 -S SWITCH_ON_END -p -c</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1      RUN:io      READY          1</span><br><span class="line">  2     WAITING      READY                     1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6*     RUN:io      READY          1</span><br><span class="line">  7     WAITING      READY                     1</span><br><span class="line">  8     WAITING      READY                     1</span><br><span class="line">  9     WAITING      READY                     1</span><br><span class="line"> 10     WAITING      READY                     1</span><br><span class="line"> 11*    RUN:cpu      READY          1</span><br><span class="line"> 12        DONE    RUN:cpu          1</span><br><span class="line"> 13        DONE     RUN:io          1</span><br><span class="line"> 14        DONE    WAITING                     1</span><br><span class="line"> 15        DONE    WAITING                     1</span><br><span class="line"> 16        DONE    WAITING                     1</span><br><span class="line"> 17        DONE    WAITING                     1</span><br><span class="line"> 18*       DONE     RUN:io          1</span><br><span class="line"> 19        DONE    WAITING                     1</span><br><span class="line"> 20        DONE    WAITING                     1</span><br><span class="line"> 21        DONE    WAITING                     1</span><br><span class="line"> 22        DONE    WAITING                     1</span><br><span class="line"> 23*       DONE       DONE</span><br><span class="line"></span><br><span class="line">Stats: Total Time 23</span><br><span class="line">Stats: CPU Busy 6 (26.09%)</span><br><span class="line">Stats: IO Busy  16 (69.57%)</span><br></pre></td></tr></table></figure>
<h3 id="83"><a class="markdownIt-Anchor" href="#83"></a> 8.3</h3>
<p>使用参数<code>-s 3 -l 3:50,3:50</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 3 -l 3:50,3:50</span><br><span class="line">Produce a trace of what would happen when you run these processes:</span><br><span class="line">Process 0</span><br><span class="line">  cpu</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Process 1</span><br><span class="line">  io</span><br><span class="line">  io</span><br><span class="line">  cpu</span><br><span class="line"></span><br><span class="line">Important behaviors:</span><br><span class="line">  System will switch when the current process is FINISHED or ISSUES AN IO</span><br><span class="line">  After IOs, the process issuing the IO will run LATER (when it is its turn)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_LATER</code>时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; python process-run.py -s 3 -l 3:50,3:50 -I IO_RUN_LATER -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING     RUN:io          1          1</span><br><span class="line">  4     WAITING    WAITING                     2</span><br><span class="line">  5     WAITING    WAITING                     2</span><br><span class="line">  6     WAITING    WAITING                     2</span><br><span class="line">  7*    RUN:cpu    WAITING          1          1</span><br><span class="line">  8*       DONE     RUN:io          1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10        DONE    WAITING                     1</span><br><span class="line"> 11        DONE    WAITING                     1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 13</span><br><span class="line">Stats: CPU Busy 6 (46.15%)</span><br><span class="line">Stats: IO Busy  9 (69.23%)</span><br></pre></td></tr></table></figure>
<p><code>-I IO_RUN_IMMEDIATE</code>时输出不变，因为I/O请求结束的时间又一次恰好和CPU被占用的时间错开了。</p>
<p><code>-S SWITCH_ON_IO</code>时输出不变（因为这仍然是默认值）。</p>
<p><code>-S SWITCH_ON_END</code>时运行时间仍然会增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">python process-run.py -s 3 -l 3:50,3:50 -S SWITCH_ON_END -c -p</span><br><span class="line">Time     PID: 0     PID: 1        CPU        IOs</span><br><span class="line">  1     RUN:cpu      READY          1</span><br><span class="line">  2      RUN:io      READY          1</span><br><span class="line">  3     WAITING      READY                     1</span><br><span class="line">  4     WAITING      READY                     1</span><br><span class="line">  5     WAITING      READY                     1</span><br><span class="line">  6     WAITING      READY                     1</span><br><span class="line">  7*    RUN:cpu      READY          1</span><br><span class="line">  8        DONE     RUN:io          1</span><br><span class="line">  9        DONE    WAITING                     1</span><br><span class="line"> 10        DONE    WAITING                     1</span><br><span class="line"> 11        DONE    WAITING                     1</span><br><span class="line"> 12        DONE    WAITING                     1</span><br><span class="line"> 13*       DONE     RUN:io          1</span><br><span class="line"> 14        DONE    WAITING                     1</span><br><span class="line"> 15        DONE    WAITING                     1</span><br><span class="line"> 16        DONE    WAITING                     1</span><br><span class="line"> 17        DONE    WAITING                     1</span><br><span class="line"> 18*       DONE    RUN:cpu          1</span><br><span class="line"></span><br><span class="line">Stats: Total Time 18</span><br><span class="line">Stats: CPU Busy 6 (33.33%)</span><br><span class="line">Stats: IO Busy  12 (66.67%)</span><br></pre></td></tr></table></figure>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-05-summary-interlude-process-api/">
              
                  OSTEP第05章总结：Interlude: Process API
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-07
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf</a>。</p>
<hr>
<p>本章的内容是“幕间休息”（interlude）：这些章节讲的是OS中与具体API相关的内容，和原理关系不大，如果不想了解这些具体内容，可以跳过。（但是最好还是不跳过，因为实践出真知，对吧？）本章主要介绍了以下三个与进程创建相关的UNIX系统调用，以及它们的设计原理：</p>
<ul>
<li><code>fork()</code></li>
<li><code>wait()</code></li>
<li><code>exec()</code></li>
</ul>
<h2 id="fork系统调用通过复制来创建新进程"><a class="markdownIt-Anchor" href="#fork系统调用通过复制来创建新进程"></a> fork系统调用：通过复制来创建新进程</h2>
<p>下面的例子说明了<code>fork()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// p1.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        printf(&quot;hello, I am parent of %d (pid:%d)\n&quot;,</span><br><span class="line">        rc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，程序开始执行的时候打印了一条信息，其中包含了<strong>进程标识符</strong>（process identifier，PID）。该进程的PID是29146。在UNIX系统中，PID是进程的唯一标识。然后进程调用了<code>fork()</code>系统调用，通过拷贝当前进程创建了一个新进程。有趣的是，这两个进程几乎相同，都正准备从<code>fork()</code>系统调用返回。新进程（称为子进程；原来的进程称为父进程）不会从<code>main()</code>开始运行（因为<code>hello world</code>只被打印了一次），而是好像自己已经调用了<code>fork()</code>一样。这样设计的原因，将在后面进行解释。</p>
<p>子进程和父进程几乎相同（地址空间、寄存器、PC），只有一点区别：<code>fork()</code>调用的返回值不同。父进程的返回值是子进程的PID，而子进程的返回值是0。这一区别使得我们可以撰写代码分别处理这两种情况。</p>
<p>值得注意的另一点是，p1.c的输出是<strong>不确定的</strong>（nondeterminism）：当子进程创建的时候，系统中出现了两个活跃进程，而CPU调度器选择哪一个先开始运行是不确定的。因此，如果子进程被创建之后立刻开始运行，上述程序的输出就会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="wait系统调用等待子进程退出"><a class="markdownIt-Anchor" href="#wait系统调用等待子进程退出"></a> wait系统调用：等待子进程退出</h2>
<p>下面的例子说明了<code>wait()</code>系统调用的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// p2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (wc:29267) (pid:29266)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，父进程调用<code>wait()</code>，使得它在子进程结束执行之后才继续执行。当子进程结束之后，<code>wait()</code>调用才返回。此时，上述代码的输出显然是确定（deterministic）的了。如果父进程先运行，它会立刻调用<code>wait()</code>，等待子进程运行结束；因此子进程必然先运行。</p>
<h2 id="exec系统调用通过覆盖改变当前进程的内容"><a class="markdownIt-Anchor" href="#exec系统调用通过覆盖改变当前进程的内容"></a> exec系统调用：通过覆盖改变当前进程的内容</h2>
<p>下面的例子说明了<code>exec()</code>系统调用的使用方法，它一般和<code>fork()</code>一起使用，用于创建新进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p3.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child (new process)</span><br><span class="line">        printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">        printf(&quot;this shouldn’t print out&quot;);</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">        printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span><br><span class="line">        rc, wc, (int) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (wc:29384) (pid:29383)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>事实上，在Linux中，<code>exec()</code>是一类系统调用的总称，一共有6个变种：<code>execl()</code>，<code>execlp()</code>，<code>execle()</code>，<code>execv()</code>，<code>execvp()</code>和<code>execvpe()</code>。详情见<a href="http://man7.org/linux/man-pages/man3/exec.3.html" target="_blank" rel="noopener">exec(3)</a></p>
<p>在这个例子中，在调用<code>fork()</code>创建子进程后，子进程调用了<code>execvp()</code>，用程序<code>wc</code>覆盖自己并开始执行该程序。<code>wc</code>是字数统计（word counting）程序，此处它被用来统计源文件<code>p3.c</code>中行、词和字节的数量。</p>
<p><code>fork()</code>系统调用的设计固然很怪，它的“同伙”<code>exec()</code>也有够怪的。事实上，<code>exec()</code>所做的事情是这样的：给定一个可执行文件的名字（如<code>wc</code>）和一些参数（如<code>p3.c</code>），它会<strong>加载</strong>（load）这个可执行文件的代码（和静态数据），覆盖当前进程的代码段和静态数据，并且重新初始化进程的堆栈和其他内存空间。然后OS把参数作为新进程的<code>argv</code>数组，直接开始运行新程序。所以<code>exec()</code>调用并没有创建一个新进程；它只是把当前正在运行的进程（<code>p3</code>）换成了一个新的程序（<code>wc</code>）。在子进程执行<code>exec()</code>调用之后，<code>p3.c</code>就好像从未运行过一样了；对<code>exec()</code>的成功调用是不会返回的。</p>
<h2 id="fork和exec的设计原因方便shell和管道的实现"><a class="markdownIt-Anchor" href="#fork和exec的设计原因方便shell和管道的实现"></a> fork和exec的设计原因：方便shell和管道的实现</h2>
<p>我们为什么要这样设计创建新进程的API呢？事实上，对于UNIX shell来说，在创建新进程的过程中把<code>fork()</code>和<code>exec()</code>分开是非常必要的，因为这样shell才能在调用<code>fork()</code>之后，调用<code>exec()</code>的过程之前运行一些代码来改变即将运行的程序的环境，这就使得我们可以创造很多有趣的特性。</p>
<p>shell是一个帮助你执行程序（命令）的用户程序。它显示一个<strong>命令提示符</strong>（prompt），然后等待你在里面打字。你在里面打一个命令（比如可执行程序的名字和参数）；然后，shell一般会找到这个可执行程序在文件系统中的位置，调用<code>fork()</code>创建一个新的子进程，然后（子进程）调用<code>exec()</code>的某个变种开始执行命令，最后（父进程）调用<code>wait()</code>等待命令执行结束。当子进程运行结束之后，shell（父进程）从<code>wait()</code>返回，再次打印出命令提示符，等待你的下一条指令。</p>
<p>把<code>fork()</code>和<code>exec()</code>分开使得shell能在其间够做很多有用的东西。比如，我们执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; wc p3.c &gt; newfile.txt</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>wc</code>的输出被<strong>重定向</strong>（redirect）到输出文件<code>newfile.txt</code>中。shell完成这个任务的方法很简单：在创建子进程之后，调用<code>exec()</code>之前，shell关闭<strong>标准输出</strong>（standard output）并打开文件<code>newfile.txt</code>。这样，即将被执行的程序<code>wc</code>的任何输出都会被发送到这个文件而不是屏幕。</p>
<p>下面的代码实现了子进程输出的重定向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// p4.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int rc = fork();</span><br><span class="line">    if (rc &lt; 0) &#123; // fork failed; exit</span><br><span class="line">        fprintf(stderr, &quot;fork failed\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125; else if (rc == 0) &#123; // child: redirect standard output to a file</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        // now exec &quot;wc&quot;...</span><br><span class="line">        char *myargs[3];</span><br><span class="line">        myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count)</span><br><span class="line">        myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count</span><br><span class="line">        myargs[2] = NULL; // marks end of array</span><br><span class="line">        execvp(myargs[0], myargs); // runs word count</span><br><span class="line">    &#125; else &#123; // parent goes down this path (main)</span><br><span class="line">        int wc = wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p4</span><br><span class="line">prompt&gt; cat p4.output</span><br><span class="line">32 109 846 p4.c</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>这种方法的工作原理与OS管理文件描述符的方法相关。UNIX系统在分配文件描述符时，会从0开始寻找空闲的文件描述符。<a href="/post/ostep-ch-04-summary-the-abstraction-the-process">上一章</a>中曾经讲过，对于一个进程，默认有三个文件描述符是开启的：标准输入（<code>STDIN_FILENO=0</code>）、标准输出（<code>STDOUT_FILENO=1</code>）和标准错误输出（<code>STDERR_FILENO=2</code>）。关闭标准输出之后，在调用<code>open()</code>分配新的文件描述符时，<code>STDOUT_FILENO=1</code>就成了第一个可用的文件描述符，于是它就指向了我们需要的输出文件<code>./p4.output</code>。于是，子进程之后对标准输出文件描述符的写操作会被透明地指向新打开的文件。（真是有趣的设计啊）</p>
<p>UNIX<strong>管道</strong>（pipe）机制的实现方法类似。通过<code>pipe()</code>系统调用，一个进程的输出被连接到一个内核管道（pipe）中，另一个进程的输入也连接到这个相同的管道；这样，一个进程的输出就无缝连接到另一个进程的输入了。下面的例子通过管道命令实现了在文件中查找词并计算这个词出现次数的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o foo file | wc -l</span><br></pre></td></tr></table></figure>
<h2 id="温馨提示"><a class="markdownIt-Anchor" href="#温馨提示"></a> 温馨提示</h2>
<h3 id="rtfm"><a class="markdownIt-Anchor" href="#rtfm"></a> RTFM</h3>
<p>我们刚才只是大概介绍了这些系统调用的基本原理，还有许多细节没有涉及到。为了了解这些细节，你应当去阅读手册。作为一个系统程序员，阅读<strong>手册</strong>（manual/man pages）是非常重要的，因为里面提供了很多细节，而且还可以帮助你减少烦你的同事的次数。如果你直接去问他们细节问题，他们可能会回答你：“<a href="https://zh.wikipedia.org/zh/RTFM" target="_blank" rel="noopener">RTFM</a>。”（Read the fucking manual！）</p>
<h3 id="get-it-right"><a class="markdownIt-Anchor" href="#get-it-right"></a> Get it right</h3>
<p>兰普森（<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%89%B9%E5%8B%92%C2%B7%E8%98%AD%E6%99%AE%E6%A3%AE" target="_blank" rel="noopener">Butler W. Lampson</a>）在他那篇广受好评的论文“<a href="https://microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf" target="_blank" rel="noopener">Hints for Computer Systems Design</a>”中这样说：“做正确的事。（<strong>Get it right.</strong>）抽象和简化都不能代替正确的做法。”</p>
<p>实际上，设计进程创建API有很多方法，但是UNIX的设计者选择了正确的那一种。（虽然我觉得本章中并没有充分论述它的正确性）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-04-summary-the-abstraction-the-process/">
              
                  OSTEP第04章总结：The Abstraction: The Process
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-04
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a>。</p>
<hr>
<p>这一章主要讲了OS的一种基本抽象模型：进程（Process）。</p>
<ul>
<li>进程的定义</li>
<li>与进程相关的API</li>
<li>进程的创建过程和状态（生命周期）</li>
<li>进程的数据结构（进程控制块和进程状态队列）</li>
</ul>
<h2 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h2>
<p>我们首先给出一个进程的非正式定义：进程是一个正在运行的程序。</p>
<p>我们通常希望同时运行多个（甚至成百上千个）程序。这样用起来很方便，但是我们遇到的挑战是：如何创造这样由很多个虚拟CPU的假象？</p>
<p>OS通过对CPU进行虚拟化创造这一假象。它不断地运行一个程序，暂停，然后再运行下一个。这被称作CPU的分时共享（time sharing），这种技术允许程序的并发，同时也会牺牲一定的性能，因为一个程序的运行时间肯定会慢得多。</p>
<p>我们可以把实现CPU的虚拟化的过程拆分成两个步骤：</p>
<ul>
<li>机制（mechanism）：这是实现一种功能的底层方法或协议；如上下文切换（context switch），这是一种分时机制（time-sharing mechanism），用于帮助OS实现暂停一个程序后切换到下一个的功能</li>
<li>策略（policy）：这是利用底层机制，在OS内进行决策的算法；如调度（scheduling）算法会利用历史信息、程序信息和性能评价方式进行决策</li>
</ul>
<p>这是一种模块化的程序设计思路。不过，本节中我们似乎既没有讲机制也没有讲策略，而是讲了一些抽象内容（进程）的基本概念。</p>
<h2 id="进程的正式定义"><a class="markdownIt-Anchor" href="#进程的正式定义"></a> 进程的正式定义</h2>
<p>上面给出的那个定义是正确的，然而并不全面。如何更具体地描述一个进程？一般来说，我们可以通过记录进程在运行过程中访问或影响的系统部分来描述一个进程。于是我们可以定义进程的机器状态（machine state）：</p>
<ul>
<li>内存（地址空间）：包含指令和程序读写的数据</li>
<li>寄存器：通用寄存器和一些特殊寄存器，如PC（program counter）和栈指针、帧指针</li>
<li>I/O信息：进程开启的文件列表</li>
</ul>
<h2 id="与进程相关的api"><a class="markdownIt-Anchor" href="#与进程相关的api"></a> 与进程相关的API</h2>
<p>既然进程是OS为我们提供的一种抽象，那么显然需要一些使用它的方法。因此下面介绍了一些与进程相关的API，一般来说，任何现代OS都提供了这些API：</p>
<ul>
<li>创建（create）：创建新进程</li>
<li>销毁（destroy）：强制终止进程，对于失控的进程来说是很必要的</li>
<li>等待（wait）：等待其他进程结束运行</li>
<li>其他控制（miscellaneous control）：除了杀死或等待进程以外的控制方式，如将进程挂起后恢复运行的机制</li>
<li>状态（status）：通常会提供一些能够获得进程状态信息的接口，包括运行时间和状态</li>
</ul>
<h2 id="进程的生命周期"><a class="markdownIt-Anchor" href="#进程的生命周期"></a> 进程的生命周期</h2>
<h3 id="进程的创建过程"><a class="markdownIt-Anchor" href="#进程的创建过程"></a> 进程的创建过程</h3>
<p>为了启动一个进程，OS需要做以下事情：</p>
<ol>
<li>将程序的代码和静态数据（初始化了的变量）加载到进程地址空间中。通常程序以某种可执行文件格式存储在磁盘（或者SSD）中，所以OS需要从磁盘读取数据。</li>
</ol>
<ul>
<li>此时有一个加载策略的选择问题：积极加载（eager load）还是懒惰加载（lazy load）</li>
<li>积极加载：将所有代码和数据在运行之前就全部装入内存中，是早期和简单OS的做法</li>
<li>懒惰加载：用到对应的代码和数据时才加载，是现代OS的做法。</li>
<li>这个问题与分页（paging）和交换（swapping）有关，之后还会谈到。</li>
</ul>
<ol start="2">
<li>为程序的运行栈分配内存；对栈进行初始化（比如把<code>main</code>函数的<code>argc</code>和<code>argv</code>放进去）</li>
<li>为程序的堆分配内存。堆用于在程序运行中动态分配内存，程序调用<code>malloc()</code>请求内存，调用<code>free()</code>释放内存。</li>
<li>对I/O进行初始化：对于类UNIX系统，每个进程默认有三个打开的文件描述符（file descriptor），用于标准输入、标准输出和标准错误输出，这使得进程能够从终端读入输入并打印到屏幕。我们将在本书的第三部分（持久化）中更多的谈到这个问题。</li>
<li>跳转到<code>main()</code>函数的起始点，将CPU的控制权交给新创建的进程。</li>
</ol>
<h3 id="进程的状态模型"><a class="markdownIt-Anchor" href="#进程的状态模型"></a> 进程的状态模型</h3>
<p>创建了一个进程之后，它的状态（state）会不断变化。一个简化的进程三状态模型如下：</p>
<ul>
<li>运行态（running）：进程正在处理器上运行，正在执行指令。</li>
<li>就绪态（ready）：进程已经准备好执行了，但由于某些原因，OS现在并没有运行它。</li>
<li>等待态（blocked）：进程执行了一些操作，使得它不能继续运行，直到发生某些其他事件为止。例如，进程启动对磁盘的I/O请求时，它就被阻塞了，此时其他的进程可以使用处理器。</li>
</ul>
<p><img src="fig4-2_process-state-transitins.png" alt="进程在状态之间的迁移"></p>
<p>上图说明了这个简化模型中进程如何在状态间迁移：</p>
<ul>
<li>OS可以通过调度使进程在运行态和就绪态之间转换</li>
<li>如果进程进入了等待态，则只有对应的事件发生时才会进入就绪态</li>
</ul>
<p>下面举两个例子进行说明。在第一个例子中，两个进程只使用CPU而不进行I/O；调度策略是进程0执行完之后进程1才能开始执行。</p>
<p><img src="fig4-3_tracing-process-state-cpu-only.png" alt="只使用CPU的两个进程的状态变化"></p>
<p>在第二个例子中，进程会进行I/O操作。当进程0进行I/O之后，它进入阻塞状态。于是进程1开始运行。进程0的I/O完成之后，它进入就绪态，等待进程1执行结束之后继续执行。</p>
<p><img src="fig4-4_tracing-process-state-cpu-and-io.png" alt="使用CPU并进行I/O的两个进程的状态变化"></p>
<p>事实上，在上述过程中，OS采用了以下两种策略：</p>
<ul>
<li>在进程0进行I/O时切换到进程1：这个决策看起来是明智的，因为可以增加CPU使用率</li>
<li>在进程0的I/O操作结束之后，没有立即切换回切换0：这个策略的好坏很难说</li>
</ul>
<p>（上述内容将出现在作业中）</p>
<h2 id="进程的数据结构"><a class="markdownIt-Anchor" href="#进程的数据结构"></a> 进程的数据结构</h2>
<p>上面的内容可以说是非常抽象了。所以下面会讲到，这些抽象的内容如何用OS中具体的数据结构来表示。</p>
<h3 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h3>
<p>我们把进程信息对应的数据结构称为进程控制块（Process Control Block，PCB）。下面是xv6教学OS中一个实际的进程控制块的定义（也就是说，会涉及大量<strong>底层机制</strong>内容）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// the registers xv6 will save and restore</span><br><span class="line">// to stop and subsequently restart a process</span><br><span class="line">struct context &#123;</span><br><span class="line">    int eip;</span><br><span class="line">    int esp;</span><br><span class="line">    int ebx;</span><br><span class="line">    int ecx;</span><br><span class="line">    int edx;</span><br><span class="line">    int esi;</span><br><span class="line">    int edi;</span><br><span class="line">    int ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// the different states a process can be in</span><br><span class="line">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line">// the information xv6 tracks about each process</span><br><span class="line">// including its register context and state</span><br><span class="line">struct proc &#123;</span><br><span class="line">    char *mem;                  // Start of process memory</span><br><span class="line">    uint sz;                    // Size of process memory</span><br><span class="line">    char *kstack;               // Bottom of kernel stack</span><br><span class="line">                                // for this process</span><br><span class="line">    enum proc_state state;      // Process state</span><br><span class="line">    int pid;                    // Process ID</span><br><span class="line">    struct proc *parent;        // Parent process</span><br><span class="line">    void *chan;                 // If non-zero, sleeping on chan</span><br><span class="line">    int killed;                 // If non-zero, have been killed</span><br><span class="line">    struct file *ofile[NOFILE]; // Open files</span><br><span class="line">    struct inode *cwd;          // Current directory</span><br><span class="line">    struct context context;     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;       // Trap frame for the</span><br><span class="line">                                // current interrupt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面对其中一些比较重要的内容给出说明。首先可以看到，<code>context</code>中存储了通用寄存器的内容，用于上下文切换（保存一个暂停的进程的寄存器的值；在进程恢复运行时，这些值将被重新加载到寄存器中），这是之前讲到的。其次可以发现，这里定义了6种状态，和之前讲到的三状态模型不完全相符（这可能也体现了抽象策略和底层机制的区别）。除了运行态、就绪态和等待态以外，此处还定义了其他的状态，如初始（initial）态（进程刚被创建时的状态，对应的大概是上述代码中的EMBRYO态）和终止（final）态（进程已经退出，但尚未被完全清理，在类UNIX系统中，这一状态被称为僵尸（zombie）态）。进入终止态的进程允许其他进程（通常是创建这个进程的父进程）检查进程的返回值，查看它是否成功结束。父进程在自己结束之前会执行最后一个调用（<code>wait()</code>），等待子进程执行完成（进入终止态），此时OS可以清理子进程相关的数据结构。</p>
<p>（我不知道我有没有理解清楚关于僵尸态的内容）</p>
<h3 id="进程状态队列"><a class="markdownIt-Anchor" href="#进程状态队列"></a> 进程状态队列</h3>
<p>为了管理进程的状态，OS会维护一些进程状态队列，用来跟踪就绪进程、正在运行的进程和阻塞进程，并且在发生事件的时候唤醒正确的进程。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-03-summary-a-dialogue-on-virtualization/">
              
                  OSTEP第03章总结：A Dialogue on Virtualization
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-03
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这篇对话是本书第一部分——虚拟化（Virtualization）——的开头，简单叙述了一下虚拟化的概念。</p>
<p>Professor教授（我今后就这样叫他了，毕竟这位教授的名字就是“Professor”）举了一个这样的例子：假设我们有一个物理的桃子，有很多人都想吃桃子，但桃子只有一个，不能满足所有人的需求。于是我们通过某种神奇的技术，在物理桃子的基础上创造出许多虚拟桃子，仿佛每个人都拥有自己的桃子一般，但事实上只有一个桃子。</p>
<p>这时Student学生（同理）提了一个很好的问题：如果很多人同时共享一个桃子，他们应该会注意到这一点。Professor教授指出，这些人大部分时间都在干别的，所以把桃子直接拿走是完全可行的。</p>
<p>Student学生要求Professor教授举一个具体的例子——那就PCU吧。假定系统里有一个物理CPU，虚拟化技术使得系统里好像有很多虚拟CPU在同时运行。每个进程都认为它独占了一个虚拟CPU，而实际上只有一个物理CPU。OS的工作就是将实际的CPU进行虚拟化。</p>
<p>最后Professor教授表示，今后不会再有这么多桃子的例子，因为他自己也不是很喜欢吃桃子。（但是作者很喜欢吧？）</p>
<hr>
<p>我很想探讨一下这个故事中的比喻到底指代的什么。桃子当然指的是被虚拟化后共享的资源——除了物理CPU之外，物理内存也被进程这样共享。不过桃子和CPU相比有一个小问题：桃子是会被吃完的，也就是说，这是一种不可再生资源，和CPU可以不断重复利用的性质不同。那我们就当这些食客只是在舔桃子好啦……</p>
<p>所谓“很多人同时共享一个桃子会被注意到”也许只是Student学生随口一说的结果，但我觉得这一点说的更像是同步互斥问题。毕竟进程没有思想和感受，它们之间一般是相互隔离的，所谓“注意到”必然是进程通信或共享资源的结果，而这种时候是一定会出现同步互斥问题的。但是，如果这样认为，Professor教授给出的解决方案就有点儿怪了——这些人大部分时间都在干别的？我想这说的是CPU运行进程和设备I/O的并行化——I/O需要的时间很多，所以在需要进行I/O时，进程就主动放弃控制权，切换别的进程来继续占用CPU。这一点当然很好，不过好像并不能解决同步互斥问题。</p>
<p>不过这也并没有那么重要，希望Professor教授和Student在书里过得开心，吃点自己想吃的水果好啦。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-02-summary-introduction-to-operating-systems/">
              
                  OSTEP第02章总结：Introduction to Operating Systems
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf</a>。</p>
<hr>
<p>这一章对全书内容做了一些简单的概括：</p>
<ul>
<li>用三个程序概括了本书将讲到的三个基本概念（虚拟化、并发、持久化）</li>
<li>讲了一些OS的设计目标和OS的历史</li>
</ul>
<h2 id="基本概念概述"><a class="markdownIt-Anchor" href="#基本概念概述"></a> 基本概念概述</h2>
<h3 id="虚拟化"><a class="markdownIt-Anchor" href="#虚拟化"></a> 虚拟化</h3>
<p>虚拟化是本书第一部分的主题。</p>
<h4 id="cpu的虚拟化"><a class="markdownIt-Anchor" href="#cpu的虚拟化"></a> CPU的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: cpu &lt;string&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char *str = argv[1];</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">        Spin(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中调用的<code>Spin()</code>函数（具体程序见本章附带的<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Code/code.intro.tgz" target="_blank" rel="noopener">代码</a>）会在运行1秒后返回。这个程序会不断运行，每秒输出一个<code>A</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o cpu cpu.c -Wall</span><br><span class="line">prompt&gt; ./cpu &quot;A&quot;</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">ˆC</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>
<p>如果同时运行不同的程序实例，CPU会不断在程序之间切换，使得每个程序都认为自己独占了CPU，这被称为CPU的<strong>虚拟化</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./cpu A &amp; ; ./cpu B &amp; ; ./cpu C &amp; ; ./cpu D &amp;</span><br><span class="line">[1] 7353</span><br><span class="line">[2] 7354</span><br><span class="line">[3] 7355</span><br><span class="line">[4] 7356</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而OS选择什么程序来运行是一种<strong>策略</strong>，之后我们会学到相关内容（进程调度）。</p>
<h4 id="内存的虚拟化"><a class="markdownIt-Anchor" href="#内存的虚拟化"></a> 内存的虚拟化</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: mem &lt;value&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int *p;                   // memory for pointer is on &quot;stack&quot;</span><br><span class="line">    p = malloc(sizeof(int));  // malloc&apos;d memory is on &quot;heap&quot;</span><br><span class="line">    assert(p != NULL);</span><br><span class="line">    printf(&quot;(pid:%d) addr of p:        %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) &amp;p);</span><br><span class="line">    printf(&quot;(pid:%d) addr stored in p: %llx\n&quot;, (int) getpid(),</span><br><span class="line">        (unsigned long long) p);</span><br><span class="line">    *p = atoi(argv[1]);       // assign value to addr stored in p</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        Spin(1);</span><br><span class="line">        *p = *p + 1;</span><br><span class="line">        printf(&quot;(pid:%d) value of p: %d\n&quot;, getpid(), *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代机器的内存模型就是一个数组，读写都需要给出地址。</p>
<p>上述程序所做的事很简单：</p>
<ul>
<li>分配一些内存</li>
<li>打印内存的地址，以及程序的PID</li>
<li>将数0放入新分配的内存的第一个位置（4字节的int）中</li>
<li>循环，将p中存储的值+1</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem</span><br><span class="line">(2134) address pointed to by p: 0x200000</span><br><span class="line">(2134) p: 1</span><br><span class="line">(2134) p: 2</span><br><span class="line">(2134) p: 3</span><br><span class="line">(2134) p: 4</span><br><span class="line">(2134) p: 5</span><br><span class="line">ˆC</span><br></pre></td></tr></table></figure>
<p>如果仍然同时运行几个程序的实例，则会发现，每个程序都在同一地址处分配内存，而且对这一内存处存储的值的更新是相互独立的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./mem &amp;; ./mem &amp;</span><br><span class="line">[1] 24113</span><br><span class="line">[2] 24114</span><br><span class="line">(24113) address pointed to by p: 0x200000</span><br><span class="line">(24114) address pointed to by p: 0x200000</span><br><span class="line">(24113) p: 1</span><br><span class="line">(24114) p: 1</span><br><span class="line">(24114) p: 2</span><br><span class="line">(24113) p: 2</span><br><span class="line">(24113) p: 3</span><br><span class="line">(24114) p: 3</span><br><span class="line">(24113) p: 4</span><br><span class="line">(24114) p: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这说明OS对内存进行了虚拟化，每个进程访问的是自己的虚拟地址空间。</p>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;common_threads.h&quot;</span><br><span class="line"></span><br><span class="line">volatile int counter = 0;</span><br><span class="line">int loops;</span><br><span class="line"></span><br><span class="line">void *worker(void *arg) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">        counter = counter + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: threads &lt;loops&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    loops = atoi(argv[1]);</span><br><span class="line">    pthread_t p1, p2;</span><br><span class="line">    printf(&quot;Initial value : %d\n&quot;, counter);</span><br><span class="line">    Pthread_create(&amp;p1, NULL, worker, NULL);</span><br><span class="line">    Pthread_create(&amp;p2, NULL, worker, NULL);</span><br><span class="line">    Pthread_join(p1, NULL);</span><br><span class="line">    Pthread_join(p2, NULL);</span><br><span class="line">    printf(&quot;Final value   : %d\n&quot;, counter);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一程序通过调用<code>Pthread_create</code>创建了两个线程，分别将一个计数器自增N次，然后将计数器的结果输出。显然，正常情况下程序输出应该为2N。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; gcc -o thread thread.c -Wall -pthread</span><br><span class="line">prompt&gt; ./thread 1000</span><br><span class="line">Initial value : 0</span><br><span class="line">inal value : 2000</span><br></pre></td></tr></table></figure>
<p>但如果两个线程执行的次数N比较大，则程序的输出可能不再会为2N，而且会不太稳定。这是由于+1的操作不是原子的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 143012 // huh??</span><br><span class="line">prompt&gt; ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 137298 // what the??</span><br></pre></td></tr></table></figure>
<p>这体现了并发中可能出现的一些问题，我们将要在本书的第二部分讲到这些问题。</p>
<h3 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void do_work() &#123;</span><br><span class="line">    int fd = open(&quot;/tmp/file&quot;, O_WRONLY | O_CREAT | O_TRUNC,</span><br><span class="line">		  S_IRUSR | S_IWUSR);</span><br><span class="line">    assert(fd &gt;= 0);</span><br><span class="line">    char buffer[20];</span><br><span class="line">    sprintf(buffer, &quot;hello world\n&quot;);</span><br><span class="line">    int rc = write(fd, buffer, strlen(buffer));</span><br><span class="line">    assert(rc == strlen(buffer));</span><br><span class="line">    printf(&quot;wrote %d bytes\n&quot;, rc);</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    do_work();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会创建文件<code>/tmp/file</code>，并在里面写入字符串<code>hello world</code>。</p>
<p>内存是一种易失性存储，所以需要能够持续性地存储程序的硬件和软件，也就是硬盘（SSD）和文件系统。</p>
<p>和虚拟化的内存地址空间相比，因为用户通常会使用文件来共享信息，所以OS并不会为每个应用进程创建虚拟化的磁盘。OS向硬盘写数据的过程是十分复杂的，但OS对此进行了抽象，可以通过系统调用来访问设备。因此OS可以被看成是一个标准库。</p>
<h2 id="os的设计目标"><a class="markdownIt-Anchor" href="#os的设计目标"></a> OS的设计目标</h2>
<ul>
<li>抽象：使系统更易用</li>
<li>高性能</li>
<li>保护：在应用程序之间，以及应用程序和系统之间提供保护和隔离</li>
<li>可靠性</li>
<li>节能、安全性、可移动性……</li>
</ul>
<h2 id="os的历史"><a class="markdownIt-Anchor" href="#os的历史"></a> OS的历史</h2>
<ul>
<li>早期操作系统（大型机批处理系统）：基本只是标准库，需要操作员参与管理</li>
<li>中期操作系统：提供了文件系统和保护机制，系统调用和硬件特权级的概念出现了</li>
<li>多道程序系统：内存保护和并发的概念</li>
<li>现代操作系统：……</li>
</ul>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/ostep-ch-01-summary-a-dialogue-on-the-book/">
              
                  OSTEP第01章总结：A Dialogue on the Book
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-07-01
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <p>本章课本见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-virtualization.pdf</a>。</p>
<hr>
<p>这是全书开头的第一章，奠定了全书逗比的基调（雾）。这一章主要只是用来扯皮的，真正的介绍性内容在下一章。</p>
<p>本章讲述了一位叫“Professor”的教授和一位叫“Student”的学生的故事。</p>
<p>Professor指出，“Three Easy Pieces”这个题目是为了致敬费曼的“Six Easy Pieces”这本书。因为操作系统只有物理学的一半那么难，所以核心概念也只有物理学的一半那么多。（真的吗？）</p>
<p>我们将要讲授的3个核心概念是：虚拟化（virtualization），并发（concurrency）和持久化（persistence）。</p>
<p>我们将要学到OS如何工作，具体内容包括：</p>
<ul>
<li>OS如何决定下一个将在CPU上运行的是什么程序</li>
<li>如何在虚拟内存系统中处理内存过载</li>
<li>如何管理磁盘上的信息</li>
<li>如何建立一个可靠的分布式系统</li>
<li>等等</li>
</ul>
<p>Professor对学习者的建议：</p>
<ul>
<li>上课，听讲</li>
<li>每周结束时读这本书</li>
<li>考试之前再读一遍书（虽然可能我没有那么多的时间，我就没有）</li>
<li>做教授留的作业和项目</li>
</ul>
<p>Professor：“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣。”（荀子《儒效篇》）</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
                    <a href="/tags/OSTEP/"><i class="fas fa-hashtag fa-fw"></i>OSTEP</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-14-summary/">
              
                  《操作系统》第14讲：“实验5-用户线程管理”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-25
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>TODO</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-quiz.md" target="_blank" rel="noopener">lab5 用户进程 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-spoc-discussion.md" target="_blank" rel="noopener">lab5 spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>下列叙述中正确的是()</strong></p>
<ul>
<li>lab5建立了用户进程，且0~3GB都是用户可访问空间，用户进程可进行正常读写</li>
<li>lab5建立了用户进程，且3GB~4GB都是内核可访问空间，内核可进行正常读写</li>
<li><strong>lab5中的第一个用户进程是内核创建的。</strong></li>
<li><strong>lab5中的用户进程可通过fork创建新的用户进程。</strong></li>
</ul>
<p>lab5中建立了用户进程这一点没啥问题。用户和内核可访问的空间这点有问题。简单来说，内核虚拟内存空间处于0xC0000000<sub>0xF8000000位置（KERNBASE</sub>KERNTOP），用户进程可访问的虚拟内存空间位于0x0080000<sub>-0xB0000000位置（UTEXT</sub>USERTOP）。</p>
<blockquote>
<p>这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（ 即应用程序的执行代码） 和数据（ 即应用程序的全局变量等） 放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</p>
</blockquote>
<hr>
<p><strong>lab5通过<code>do_execve</code>函数执行新的程序，为此需要完成（）</strong></p>
<ul>
<li><strong>更新用户进程的context</strong></li>
<li><strong>更新用户进程的代码内容</strong></li>
<li><strong>更新用户进程的数据内容</strong></li>
<li><strong>更新用户进程的页表基址</strong></li>
</ul>
<p>Lab5中的<code>do_execve</code>函数的主要功能就是，放弃当前程序的一切内存空间等资源，将新的程序填充到自己里面。所以显然上述内容都要更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// do_execve - call exit_mmap(mm)&amp;put_pgdir(mm) to reclaim memory space of current process</span><br><span class="line">//           - call load_icode to setup new memory space accroding binary prog.</span><br><span class="line">int</span><br><span class="line">do_execve(const char *name, size_t len, unsigned char *binary, size_t size) &#123;</span><br><span class="line">    struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char local_name[PROC_NAME_LEN + 1];</span><br><span class="line">    memset(local_name, 0, sizeof(local_name));</span><br><span class="line">    memcpy(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    if (mm != NULL) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        if (mm_count_dec(mm) == 0) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int ret;</span><br><span class="line">    if ((ret = load_icode(binary, size)) != 0) &#123;</span><br><span class="line">        goto execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(&quot;already exit: %e.\n&quot;, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ucore docs中指出，此函数的主要工作流程如下：</p>
<blockquote>
<p>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。<br>
接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</p>
</blockquote>
<hr>
<p><strong>lab5通过<code>do_icode</code>函数执行新的程序，为此需要完成（）</strong></p>
<ul>
<li><strong>设置用户堆栈</strong></li>
<li><strong>修改页表</strong></li>
<li><strong>根据ELF执行文件的格式描述分配内存并填写内容</strong></li>
<li><strong>设置用户态的EFLAG寄存器不可屏蔽中断</strong></li>
</ul>
<p>ucore docs中给出的函数工作流程：</p>
<blockquote>
<ol>
<li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
</ol>
</blockquote>
<ol start="2">
<li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（ boot_pgdir所指） 的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等） 的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li>
</ol>
<p>其中设置中断帧这一步是Lab5的练习1。</p>
<hr>
<p><strong>关于进程管理的COW(Copy On Write)机制叙述正确的是（）</strong></p>
<ul>
<li>父进程创建子进程需要复制父进程的内存空间</li>
<li>父进程创建子进程需要给子进程分配内核堆栈</li>
<li>父进程创建子进程需要给子进程分配用户堆栈</li>
<li><strong>父进程创建子进程需要创建子进程的页表,但不复制父进程内存空间</strong></li>
</ul>
<p>总之不需要复制也不需要分配，只是创建一个新的页表，然后和父进程页表指向相同位置。需要进行写时就新创建一页。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>第一个用户进程创建有什么特殊的？</strong></p>
<blockquote>
<p>用户态代码段的初始化</p>
</blockquote>
<p>好吧，答案是这么说的，但是我并不认同……总之，本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行<br>
码覆盖到initproc的用户虚拟内存空间来创建的。具体的大概方法是调用<code>kernel_execve()</code>函数，触发<code>SYS_exec</code>系统中断，然后继续调用<code>do_execve()</code>和<code>load_icode()</code>函数完成这一过程。其他用户进程是用户进程通过<code>SYS_fork</code>系统调用创建的（大概）。</p>
<hr>
<p><strong>系统调用的参数传递过程？</strong></p>
<p>参见：用户态函数syscall()中的汇编代码。下面的代码摘自<code>user/libs/syscall.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">syscall(<span class="keyword">int</span> num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %1;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"a"</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"d"</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"c"</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"b"</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"D"</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"S"</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，参数是这样传递的：</p>
<ul>
<li>触发INT 0x80中断（T_SYSCALL）</li>
<li>eax中存放系统调用号</li>
<li>edx、ecx、ebx、edi、esi中按照顺序存放前五个参数</li>
<li>返回值存放在eax中</li>
</ul>
<p>令人感到奇怪的是，这与Linux系统在x86架构下一般的习惯并不相符。（<a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6" target="_blank" rel="noopener">https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6</a>，其中给出的顺序是ebx、ecx、edx、esi、edi）。不过这并不是很重要，总之这个顺序与<code>kern/syscall/syscall.c</code>中对应的代码是相符的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void) &#123;</span><br><span class="line">    struct trapframe *tf = current-&gt;tf;</span><br><span class="line">    uint32_t arg[5];</span><br><span class="line">    int num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    if (num &gt;= 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        if (syscalls[num] != NULL) &#123;</span><br><span class="line">            arg[0] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[1] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[2] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[3] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[4] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ref: <a href="https://www.ibm.com/developerworks/library/l-ia/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/l-ia/index.html</a></p>
<hr>
<p><strong>getpid的返回值放在什么地方了？</strong></p>
<blockquote>
<p>参见：用户态函数syscall()中的汇编代码</p>
</blockquote>
<p>这个问题很平凡，只是放在eax里面了而已。（又不是fork……）</p>
<hr>
<p><strong>ucore的内存布局中，页表、用户栈、内核栈在逻辑地址空间中的位置？</strong></p>
<p>参见<code>kern/mm/memlayout.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define VPT 0xFAC00000</span><br><span class="line"></span><br><span class="line">#define KSTACKPAGE 2 // # of pages in kernel stack</span><br><span class="line"></span><br><span class="line">#define KSTACKSIZE (KSTACKPAGE * PGSIZE) // sizeof kernel stack</span><br><span class="line"></span><br><span class="line">#define USERTOP 0xB0000000</span><br><span class="line"></span><br><span class="line">#define USTACKTOP USERTOP</span><br><span class="line"></span><br><span class="line">#define USTACKPAGE 256 // # of pages in user stack</span><br><span class="line"></span><br><span class="line">#define USTACKSIZE (USTACKPAGE * PGSIZE) // sizeof user stack</span><br></pre></td></tr></table></figure>
<p>事实上，页表位于内核虚拟空间0xFAC00000<sub>0xFB000000位置，用户栈位于用户虚拟空间?</sub>0xB0000000位置（因为栈是向下增长的），内核栈位于内核虚拟空间……诶怎么没说内核栈在什么位置？我猜是在~0xF8000000位置吧。</p>
<p>这个字符画的水平十分高超：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * Virtual memory map:                                          Permissions</span><br><span class="line"> *                                                              kernel/user</span><br><span class="line"> *</span><br><span class="line"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |         Empty Memory (*)        |</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            +---------------------------------+ 0xFB000000</span><br><span class="line"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="line"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="line"> *                            |           User stack            |</span><br><span class="line"> *                            +---------------------------------+</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            :                                 :</span><br><span class="line"> *                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line"> *                            :                                 :</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                            |       User Program &amp; Heap       |</span><br><span class="line"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *                            |  - - - - - - - - - - - - - - -  |</span><br><span class="line"> *                            |    User STAB Data (optional)    |</span><br><span class="line"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --/--</span><br><span class="line"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.</span><br><span class="line"> *</span><br><span class="line"> * */</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>在do_execve中的的当前进程如何清空地址空间内容的？在什么时候开始使用新加载进程的地址空间？</strong></p>
<blockquote>
<p>清空进程地址空间是在initproc所在进程地址空间<br>
CR3设置成新建好的页表地址后，开始使用新的地址空间</p>
</blockquote>
<p>这个答案简直语无伦次……总之上面已经说过<code>do_execve()</code>函数的流程了。清空地址空间是通过释放<code>mm_struct</code>结构完成的（虽然initproc并不会这么做，因为它直接用的是内核的<code>mm_struct</code>）。至于页表，<code>do_execve()</code>在释放<code>mm_struct</code>之前会先换成内核自己的页表；<code>load_icode()</code>中，设置进程的新<code>mm_struct</code>时会加载新页表（第5步）。</p>
<hr>
<p><strong>新加载进程的第一级页表的建立代码在哪？</strong></p>
<p>在<code>load_icode()</code>的第2步中，调用了<code>setup_pgdir(mm)</code>。</p>
<hr>
<p><strong>do_execve在处理中是如何正确区分出用户进程和线程的？并为此采取了哪些不同的处理？</strong></p>
<p>我猜这道题说的是内核线程吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lcr3(boot_cr3);</span><br><span class="line">    <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">        exit_mmap(mm);</span><br><span class="line">        put_pgdir(mm);</span><br><span class="line">        mm_destroy(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核线程的<code>mm</code>直接借用了内核自己的<code>mm</code>，所以这里处理了这一点。</p>
<hr>
<p><strong>第一个内核线程和第一个用户进程的创建有什么不同？</strong></p>
<ul>
<li>相应线程的内核栈创建时，多了SS和ESP的设置；</li>
<li>用户进程需要创建用户地址空间，并把用户代码复制到用户地址空间；</li>
</ul>
<p>设置ss和esp对应lab5的练习1：在用户进程的内核栈中存放的<code>trapframe</code>中填写对应的寄存器。其次就是要<code>load_icode</code>了，不能直接调用内核中的函数。而且不能和内核共用页表，要新建自己的页表。</p>
<hr>
<p><strong>尝试跟踪分析新创建的用户进程的开始执行过程？</strong></p>
<p>……反正我写的实验报告中是这么说的：</p>
<p><code>load_icode</code>函数成功结束运行后，系统中断返回到<code>exit</code>的第一行代码。<code>exit</code>本身的执行过程在此暂时忽略。</p>
<p><code>exit</code>线程执行结束之后，系统切换到<code>initproc</code>线程，它进行检查并退出。</p>
<p>差不多吧。</p>
<hr>
<p><strong>为什么新进程的内核堆栈可以先于进程地址空间复制进行创建？</strong></p>
<p>内核栈在进程的内核地址空间，而各进程的内核地址空间是共享的。</p>
<hr>
<p><strong>进程复制的代码在哪？复制了哪些内容？</strong></p>
<p>以下代码来自<code>lab5/kern/process/proc.c</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) &#123;</span><br><span class="line">    int ret = -E_NO_FREE_PROC;</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    if (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        goto fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    //    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">	proc = alloc_proc();</span><br><span class="line">	if (proc == NULL) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto fork_out;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;parent = current;  // 参考了答案</span><br><span class="line">	//    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">	if (setup_kstack(proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto bad_fork_cleanup_proc;</span><br><span class="line">	&#125;</span><br><span class="line">	//    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">	// CLONE_VM表示分享；实际上因为都在内核态所以什么都没做，只是assert NULL了</span><br><span class="line">	if (copy_mm(clone_flags, proc) != 0) &#123;  // 参考答案添加了错误处理</span><br><span class="line">		goto bad_fork_cleanup_kstack;</span><br><span class="line">	&#125;</span><br><span class="line">	//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">	copy_thread(proc, stack, tf);</span><br><span class="line">	//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">	// 参考了答案：关中断的原因是，进程号要求唯一性，此操作需要为原子操作，防止被打断而重复添加</span><br><span class="line">	// 所以参考答案是很有必要的。但是我认为在实验指导书中也应该说明一下。</span><br><span class="line">	bool intr_flag;</span><br><span class="line">	local_intr_save(intr_flag);</span><br><span class="line">	&#123;</span><br><span class="line">		proc-&gt;pid = get_pid();</span><br><span class="line">		hash_proc(proc);</span><br><span class="line">		// list_add_before(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">		set_links(proc);</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">	//    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">	wakeup_proc(proc);</span><br><span class="line">	//    7. set ret vaule using child proc&apos;s pid</span><br><span class="line">	ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    return ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，以上代码中复制的主要内容是<code>mm_struct</code>内存管理结构（相当于复制了一份虚拟内存及其中的内容）。</p>
<hr>
<p><strong>进程复制过程中有哪些修改？为什么要修改？</strong></p>
<p>参见上一题的代码，需要修改的内容包括：</p>
<ul>
<li>为新进程分配一个新的进程控制块</li>
<li>分配一个新的内核栈</li>
<li>修改内核栈中存储的<code>trapframe</code>的内容</li>
<li>分配一个新的PID</li>
</ul>
<hr>
<p><strong>分析第一个用户进程的创建流程，说明进程切换后执行的第一条是什么。</strong></p>
<p>以下内容摘自ucore docs Lab5：</p>
<blockquote>
<p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的。<br>
initproc的执行主体是<code>init_main</code>函数，这个函数在缺省情况下是执行宏<code>KERNEL_EXECVE(hello)</code>，而这个宏最终会调用<code>kernel_execve</code>函数来执行SYS_exec系统调用。<br>
ucore收到此系统调用后，最终通过<code>do_execve</code>函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
</blockquote>
<ol>
<li>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li>接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。<br>
load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</li>
<li>调用<code>mm_create</code>函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
<li>调用<code>setup_pgdir</code>来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（<code>boot_pgdir</code>所指）的内容拷贝到此新目录表中，最后让<code>mm-&gt;pgdir</code>指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用<code>mm_map</code>函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等） 的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
<li>需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；<br>
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。</li>
</ol>
<hr>
<p><strong>什么是写时复制？</strong></p>
<blockquote>
<p>写时复制（Copy-on-Write，也缩写为COW），顾名思义，就是在写入时才真正复制一份内存进行修改。COW最早应用在*nix系统中对线程与内存使用的优化，后面广泛的被使用在各种编程语言中，如C++的STL等。在PHP内核中，COW也是主要的内存优化手段。在前面关于变量和内存的讨论中，引用计数对变量的销毁与回收中起着至关重要的标识作用。引用计数存在的意义，就是为了使得COW可以正常运作，从而实现对内存的优化使用。（<a href="https://blog.csdn.net/ghostlv/article/details/51249494" target="_blank" rel="noopener">50-写时复制COW机制</a>）</p>
</blockquote>
<hr>
<p><strong>写时复制的页表在什么时候进行复制？共享地址空间和写时复制有什么不同？</strong></p>
<p>在发生写操作时进行复制。共享地址空间并不在意是否发生写操作……</p>
<hr>
<p><strong>存在有多个（n&gt;2）进程具有父子关系，且采用了COW机制的情况。这个情况与只有父子两个进程的情况相比，在设计COW时，需要注意的新问题是什么？有何解决方案？</strong></p>
<p>大概发生一次写操作可能有多个页表发生修改。</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息和函数调用参数信息，然后在你希望的地方人为触发panic函数，并输出上述信息。</strong></p>
<p>没写。</p>
<hr>
<p><strong>尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围，然后在你希望的地方人为触发panic函数，并输出上述信息。</strong></p>
<p>没写。</p>
<hr>
<p><strong>尝试在进程运行过程中获取内核空间中各进程相同的页表项（代码段）和不同的页表项（内核堆栈）？</strong></p>
<p>没写。。。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-18-summary/">
              
                  《操作系统》第18讲：“信号量与管程”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-25
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<ul>
<li>信号量
<ul>
<li>信号量简介</li>
<li>信号量使用
<ul>
<li>互斥访问</li>
<li>条件同步</li>
</ul>
</li>
</ul>
</li>
<li>管程
<ul>
<li>条件变量</li>
<li>管程的语义</li>
</ul>
</li>
<li>经典问题
<ul>
<li>生产者-消费者问题
<ul>
<li>信号量实现</li>
<li>管程实现</li>
</ul>
</li>
<li>哲学家就餐问题</li>
<li>读者-写者问题</li>
</ul>
</li>
</ul>
<h3 id="信号量semaphore"><a class="markdownIt-Anchor" href="#信号量semaphore"></a> 信号量（Semaphore）</h3>
<p>信号量是操作系统提供的一种协调共享资源访问的方法。它和软件同步的区别是：</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>信号量是由操作系统进行管理的，它的地位高于进程（而非平等协商）</li>
</ul>
<p>信号量由Dijkstra在20世纪60年代提出，目前仍然在OS中被使用。</p>
<h4 id="信号量简介"><a class="markdownIt-Anchor" href="#信号量简介"></a> 信号量简介</h4>
<p>信号是一种抽象数据类型：</p>
<ul>
<li>由一个整型变量（<code>sem</code>）和两个原子操作组成</li>
<li><code>sem</code>：要共享的资源的数目</li>
<li><code>P()</code>操作（Prolaag，尝试减少，请求资源时进行）
<ul>
<li><code>sem-1</code></li>
<li>若<code>sem&lt;0</code>，进入等待，否则继续运行</li>
</ul>
</li>
<li><code>V()</code>操作（Verhoog，增加，释放资源时进行）
<ul>
<li><code>sem+1</code></li>
<li>若<code>sem&lt;=0</code>，则唤醒一个等待进程</li>
</ul>
</li>
</ul>
<p>信号量的一些特点：</p>
<ul>
<li>信号量可以被认为是被保护的整数变量
<ul>
<li>初始化完成后，只能通过P()和V()操作修改</li>
<li>由操作系统保证，PV操作是原子操作</li>
<li>可以保证不受应用进程的干扰</li>
</ul>
</li>
<li>P()操作可能阻塞，但V()操作不会阻塞</li>
<li>通常假定信号量是“公平的”
<ul>
<li>线程不会被无限期阻塞在P()操作（实际系统中有一个最长时限的参数，超时之后错误返回）</li>
<li>假定信号量等待按先进先出排队（但是在实际系统中公平有所偏差）</li>
</ul>
</li>
</ul>
<p>下面给出信号量在原理上的一个实现（之所以是原理上的实现，是因为实际实现时要考虑很多问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">    int sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P() &#123;</span><br><span class="line">    sem--;</span><br><span class="line">    if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    if (sem &gt;= 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量使用"><a class="markdownIt-Anchor" href="#信号量使用"></a> 信号量使用</h4>
<p>信号量一般可分为两类：</p>
<ul>
<li>二进制信号量：资源数目为0或1</li>
<li>资源信号量：资源数目为任何非负值</li>
</ul>
<p>下面讨论两个信号量的使用场景：</p>
<ul>
<li>互斥访问：临界区的互斥访问控制</li>
<li>条件同步：线程间的事件等待</li>
</ul>
<h5 id="互斥访问"><a class="markdownIt-Anchor" href="#互斥访问"></a> 互斥访问</h5>
<p>互斥访问的实现方法非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 每类资源设置一个信号量，其初值为1</span><br><span class="line">mutex = new Semaphore(1);</span><br><span class="line">// 临界区的控制代码如下：</span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section;</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure>
<p>在这种情况下，信号量的使用和锁相同。需要注意以下几点：</p>
<ul>
<li>必须成对使用P()操作和V()操作</li>
<li>P()操作保证互斥访问临界资源</li>
<li>V()操作在使用后释放临界资源</li>
<li>PV操作不能次序颠倒、重复或遗漏</li>
</ul>
<h5 id="条件同步"><a class="markdownIt-Anchor" href="#条件同步"></a> 条件同步</h5>
<p>举例：线程A执行完X模块之后，线程B才能执行Y模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 设置一个初值为0的信号量</span><br><span class="line">condition = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">// Thread A</span><br><span class="line">Module X &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">condition.V();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Thread B</span><br><span class="line">...</span><br><span class="line">condition.P();</span><br><span class="line">Module Y &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管程monitor"><a class="markdownIt-Anchor" href="#管程monitor"></a> 管程（Monitor）</h3>
<p>管程是一种用于多线程互斥访问共享资源的程序结构</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复（这是最大的特点）</li>
</ul>
<p>管程的组成：</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>入口队列：每次只能有一个线程进入</li>
<li>0或多个条件变量：管理共享数据的并发访问</li>
</ul>
<p>下面需要介绍一下条件变量了。</p>
<h4 id="条件变量condition-variable"><a class="markdownIt-Anchor" href="#条件变量condition-variable"></a> 条件变量（Condition Variable）</h4>
<p>条件变量是管程内的等待机制</p>
<ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
<li><code>Wait()</code>操作：
<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互斥访问（即允许另外一个线程进入管程）</li>
</ul>
</li>
<li><code>Signal()</code>操作：
<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空，这就相当于是一个空操作</li>
</ul>
</li>
</ul>
<p>条件变量在原理上的实现和信号量有些类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Condition &#123;</span><br><span class="line">    int numWaiting = 0;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Wait(Lock lock) &#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    Add this thread t to q;</span><br><span class="line">    release(lock);</span><br><span class="line">    schedule(); // need mutex</span><br><span class="line">    acquire(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Signal() &#123;</span><br><span class="line">    if (numWaiting &gt; 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t); // need mutex</span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有很多不同的地方，如：</p>
<ul>
<li>对管程的互斥锁的释放和获得</li>
<li>signal和P语义的不同：PV操作必须是成对的，但signal/wait操作完全不需要保证这一点</li>
<li>wait和V语义的不同：V操作后线程可能会继续执行，但wait操作后，线程必然进入等待队列并阻塞</li>
<li>执行signal/wait时，都默认已经获得了互斥锁</li>
</ul>
<h4 id="管程的语义"><a class="markdownIt-Anchor" href="#管程的语义"></a> 管程的语义</h4>
<p>事实上管程一共有三种语义：</p>
<ul>
<li>Mesa语义</li>
<li>Hoare语义</li>
<li>Hansen语义</li>
</ul>
<p>以下内容参考了<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=894" target="_blank" rel="noopener">Piazza上的讨论</a>和<a href="https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html" target="_blank" rel="noopener">CMU的课件</a>。</p>
<p>考虑如下情况：线程A在条件变量的等待队列中等待资源，此时线程B在该资源（或者说该条件变量）上执行signal操作。</p>
<h5 id="mesa语义"><a class="markdownIt-Anchor" href="#mesa语义"></a> Mesa语义</h5>
<ul>
<li>线程B执行signal之后，不会立刻退出管程，而是执行到lock.release()之后才进入就绪态</li>
<li>线程A会被移动到入口等待队列中</li>
<li>在wait后被唤醒的进程不一定会被立刻调度，因此需要用<code>while</code>来检查条件</li>
<li>大部分实际实现的管程采用的是这一语义</li>
</ul>
<p><img src="monitor_mesa.jpg" alt="Mesa语义下管程的执行过程"></p>
<h5 id="hoare语义"><a class="markdownIt-Anchor" href="#hoare语义"></a> Hoare语义</h5>
<ul>
<li>线程B执行signal之后，迅速唤醒等待中的线程A，自己进入signal队列中（这个队列是此语义特有的）</li>
<li>每次有线程退出时，先到signal队列中调度线程，如果signal队列空，才到入口等待队列调度线程</li>
<li>实际实现中一般不采用，因为需要多一个队列，代价增大了</li>
</ul>
<p><img src="monitor_hoare.jpg" alt="Hoare语义下管程的执行过程"></p>
<h5 id="brinch-hanson语义"><a class="markdownIt-Anchor" href="#brinch-hanson语义"></a> Brinch Hanson语义</h5>
<ul>
<li>线程B退出的同时才执行signal操作</li>
</ul>
<p><img src="monitor_bh.jpg" alt="Brinch Hanson语义下管程的执行过程"></p>
<h3 id="经典问题"><a class="markdownIt-Anchor" href="#经典问题"></a> 经典问题</h3>
<h4 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h4>
<p>有界缓冲区的生产者-消费者问题描述：</p>
<ul>
<li>一个或多个生产者在生成数据后放在一个缓冲区里</li>
<li>单个消费者从缓冲区取出数据处理</li>
<li>任何时候只能有一个生产者或消费者可访问缓冲区</li>
</ul>
<h5 id="信号量实现"><a class="markdownIt-Anchor" href="#信号量实现"></a> 信号量实现</h5>
<p>问题分析：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区，这是临界区（互斥访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<p>用信号量描述每个约束：</p>
<ul>
<li>二进制信号量<code>mutex</code>：互斥</li>
<li>资源信号量<code>fullBuffers</code>：缓冲区为满（信号量的值表示缓冲区中数据的个数）</li>
<li>资源信号量<code>emptyBuffers</code>：缓冲区为空（信号量的值表示缓冲区中空位的个数）</li>
<li>其中<code>fullBuffers+emptyBuffers=缓冲区大小</code></li>
</ul>
<p>（事实上，OSTEP中讨论了如果只使用一个资源信号量会导致死锁的问题，在此不再赘述了）</p>
<p>下面给出（原理上的）代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">    mutex = new Semaphore(1);</span><br><span class="line">    fullBuffers = new Semaphore(0);</span><br><span class="line">    emptyBuffers = new Semaphore(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">    emptyBuffers-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    fullBuffers-&gt;V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    fullBuffers-&gt;P();</span><br><span class="line">    mutex-&gt;P();</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    mutex-&gt;V();</span><br><span class="line">    emptyBuffers-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意P操作之间不能颠倒顺序。V操作不会阻塞，就无所谓了。</p>
<h5 id="管程实现"><a class="markdownIt-Anchor" href="#管程实现"></a> 管程实现</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    int count = 0;</span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    while (count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    while (count == 0)</span><br><span class="line">        notEmpty.Wait(&amp;lock);</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号量和管程实现的对比"><a class="markdownIt-Anchor" href="#信号量和管程实现的对比"></a> 信号量和管程实现的对比</h5>
<p>（以下内容摘自<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">Piazza</a>，修正了一些typo）</p>
<p><img src="sem-vs-monitor.png" alt="生产者-消费者问题的两种实现的对比"></p>
<p>如图，信号量中存有<code>int</code>变量<code>sem</code>以及<code>WaitQueue</code>变量<code>q</code>，根据信号量的实现代码（左下角ppt），我们可以得出<code>sem</code>和<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>sem</code>代表【到目前为止，若所有请求该资源的线程都能够获取该资源，那么资源还剩下多少（这里我们假设资源个数可以为负）】；</li>
<li>对<code>sem</code>也可以有另一种理解：当<code>sem</code>非负时，<code>sem</code>代表剩余资源的个数；当<code>sem</code>为负数时，<code>sem</code>的绝对值代表等待队列<code>q</code>的长度。</li>
</ul>
<p>而当我们使用条件变量解决有限资源问题时，我们通常会在条件变量之外，管程之中加入整型变量<code>count</code>（右上角ppt），来帮助条件变量记录当前剩余多少资源（非负）。查看条件变量的实现代码（右下角ppt），我们可以得出条件变量中整型变量<code>numWaiting</code>以及<code>WaitQueue</code>变量<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>numWaiting</code>代表等待队列<code>q</code>的长度（非负）。</li>
</ul>
<p>结合使用信号量以及条件变量解决有限资源问题的实例（左上及右上ppt），以及以上我们对信号量和条件变量的分析，我们可以得出以下结论：</p>
<ul>
<li>在任一状态，信号量中的<code>q</code>和条件变量中的<code>q</code>完全相同；</li>
<li>当<code>sem</code>非负时，含义与管程中的<code>count</code>相同，此时<code>numWaiting</code>为0；</li>
<li>当<code>sem</code>为负数时，<code>sem</code>的绝对值等于<code>numWaiting</code>，此时<code>count</code>为0。</li>
</ul>
<p>在生产者-消费者这个问题实例中：</p>
<ul>
<li>信号量<code>emptyBuffers</code>与条件变量<code>notFull</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>n - count</code>的形式出现；</li>
<li>信号量<code>fullBuffers</code>与条件变量<code>notEmpty</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>count</code>的形式出现；</li>
</ul>
<p>综上所述，两种解决方法是完全等价的，至于为什么用管程实现更加安全方便，个人认为老师在视频中并没有解释得很清楚，和老师讨论后得出结论如下：</p>
<ul>
<li>用信号量的时候（左上角ppt），所有信号量都要自己维护，并配对好PV；</li>
<li>用管程的时候，我们可以理解为<code>BoundedBuffer</code>继承了一个管程类，因此操作系统会给<code>BoundedBuffer</code>中每一个方法自动加上锁（即右上角ppt中的<code>lock-&gt;Acquire()</code>和<code>lock-&gt;Release()</code>函数并不用自己写，是系统加上的），因此更加安全可控，容易查错。</li>
</ul>
<p>但是个人认为使用条件变量也要根据条件配对好Wait和Signal函数，因此不比使用信号量更容易安全，这个问题见仁见智吧，但如果考试时候问到怎么回答大家懂的~</p>
<p>更新：ucore lab7中实现信号量的<code>sem</code>值非负，这样看来ucore中信号量的<code>sem</code>值和条件变量中的<code>count</code>值应该是完全相等的。</p>
<h4 id="哲学家就餐问题"><a class="markdownIt-Anchor" href="#哲学家就餐问题"></a> 哲学家就餐问题</h4>
<p>问题描述：</p>
<ul>
<li>
<p>5个哲学家围绕在一张圆桌周围</p>
</li>
<li>
<p>桌子上有5根筷子（或者说叉子……随便啦）</p>
</li>
<li>
<p>哲学家的动作包括思考和进餐</p>
</li>
<li>
<p>进餐时一个哲学家需要自己两边的两根筷子</p>
</li>
<li>
<p>如何保证哲学家们的动作有序进行，既不发生饥饿也不发生死锁？</p>
</li>
<li>
<p>方案1：</p>
<ul>
<li>每个筷子用一个信号量表示，sem=1</li>
<li>哲学家先拿第一根筷子，再拿第二根筷子，然后吃，最后放回两根筷子</li>
<li>多数情况下这一算法可行；但极端情况下会出现死锁，比如所有哲学家同时拿左边的筷子</li>
</ul>
</li>
<li>
<p>方案2：</p>
<ul>
<li>除了每根筷子的信号量之外，再加上一个互斥信号量，同时只能有一个哲学家就餐</li>
<li>能够保证顺序吃饭，但是浪费了资源和时间</li>
</ul>
</li>
<li>
<p>方案3：</p>
<ul>
<li>和方案1一样，使用5个信号量表示筷子</li>
<li>哲学家根据编号不同，拿取筷子的顺序不同</li>
<li>此时没有死锁，且允许两个人同时就餐</li>
</ul>
</li>
</ul>
<h5 id="信号量实现-2"><a class="markdownIt-Anchor" href="#信号量实现-2"></a> 信号量实现</h5>
<p>这一实现和ucore lab中给出的使用信号量的实现不太一样，而是参考了OSTEP中的做法（更准确地说是Dijkstra本人的做法）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialization</span></span><br><span class="line">Semaphore forks[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    forks[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper functions</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> (p + <span class="number">1</span>) % <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Philosopher</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch between thinking and eating</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="comment">// get forks</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">4</span>) &#123;  <span class="comment">// break dependency</span></span><br><span class="line">            forks[right(x)].P();</span><br><span class="line">            forks[left(x)].P();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            forks[left(x)].P();</span><br><span class="line">            forks[right(x)].P();</span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line">        <span class="comment">// put forks</span></span><br><span class="line">        forks[left(x)].V();</span><br><span class="line">        forks[right(x)].V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<p>问题描述：对于一个共享数据，有两类使用者</p>
<ul>
<li>读者：只读取数据，不修改（可以同时读）</li>
<li>写者：读取和修改数据（不可以同时写）</li>
<li>读写是互斥的</li>
</ul>
<p>事实上，也需要考虑到，至少有两种可能的策略（而且还会有更多）：</p>
<ul>
<li>读者优先策略：
<ul>
<li>只要有读者正在读状态，后来的读者就能直接进入</li>
<li>如果读者不断进入，则写者就处于饥饿</li>
</ul>
</li>
<li>写者优先策略
<ul>
<li>只要有写者就绪，写者应尽快执行写操作（后来的读者需要阻塞）</li>
<li>如果写者持续不断就绪，则读者就处于饥饿</li>
</ul>
</li>
</ul>
<h5 id="信号量实现-3"><a class="markdownIt-Anchor" href="#信号量实现-3"></a> 信号量实现</h5>
<p>用信号量描述每个约束：</p>
<ul>
<li>信号量<code>WriteMutex</code>
<ul>
<li>控制读写操作的互斥</li>
<li>初始化为1</li>
</ul>
</li>
<li>读者计数<code>Rcount</code>
<ul>
<li>正在进行读操作的读者数目</li>
<li>初始化为0</li>
</ul>
</li>
<li>信号量<code>CountMutex</code>
<ul>
<li>保护对读者计数的互斥修改</li>
<li>初始化为1</li>
</ul>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li>读者的互斥锁只针对于第一个读者，之后不再判断</li>
<li>因为Rcount也需要保护，所以外面也加上互斥锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WriteMutex.P();</span><br><span class="line">    write;</span><br><span class="line">    WriteMutex.V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountMutex.P();</span><br><span class="line">    <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">        WriteMutex.P();</span><br><span class="line">    Rcount++;</span><br><span class="line">    CountMutex.V();</span><br><span class="line"></span><br><span class="line">    read;</span><br><span class="line"></span><br><span class="line">    CountMutex.P();</span><br><span class="line">    Rcount--;</span><br><span class="line">    <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">        WriteMutex.V();</span><br><span class="line">    CountMutex.V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一实现中，只要有读者开始阅读，就必须等到全部读者都离开才能进行写操作。即使有写操作在等待，读者仍然先于写者，说明这是一种读者优先策略。</p>
<h5 id="管程实现-2"><a class="markdownIt-Anchor" href="#管程实现-2"></a> 管程实现</h5>
<p>管程中包括以下内容：</p>
<ul>
<li>一个互斥锁</li>
<li>4个状态变量</li>
<li>2个条件变量：可读/可写</li>
</ul>
<p>从判断条件可以看出，这一实现采用的是写者优先策略。不过其实我还没想明白能否把对<code>AW</code>和<code>WW</code>变量的修改移动到<code>while</code>循环外面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Database &#123;</span><br><span class="line">    Lock lock;  // 管程的互斥锁</span><br><span class="line">    int AR = 0;  // Active Readers</span><br><span class="line">    int AW = 0;  // Active Writers</span><br><span class="line">    int WR = 0;  // Waiting Readers</span><br><span class="line">    int WW = 0;  // Waiting Writers</span><br><span class="line">    Condition okToRead, okToWrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两个基本操作</span><br><span class="line">Database::Read() &#123;</span><br><span class="line">    StartRead();  // Wait until no writers</span><br><span class="line">    read database;</span><br><span class="line">    DoneRead();  // Exit &amp; wake up waiting writers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Database::Write() &#123;</span><br><span class="line">    StartWrite();  // Waite until no readers/writers;</span><br><span class="line">    write database;</span><br><span class="line">    DoneWrite();  // Exit &amp; wake up waiting readers/writers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    while (AW + WW &gt; 0) &#123;</span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.wait(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AR--;</span><br><span class="line">    if (AR == 0 &amp;&amp; WW &gt; 0)</span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    while (AW + AR &gt; 0) &#123;</span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.wait(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AW--;</span><br><span class="line">    if (WW &gt; 0)</span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    else if (AW &gt; 0)</span><br><span class="line">        okToRead.broadcast();</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-quiz.md" target="_blank" rel="noopener">lec18 信号量与管程 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-spoc-discussion.md" target="_blank" rel="noopener">同步互斥(lec 18) spoc 思考题</a>。</p>
<h3 id="选择题"><a class="markdownIt-Anchor" href="#选择题"></a> 选择题</h3>
<p><strong>如果有5个进程共享同一程序段，每次允许3个进程进入该程序段，若用PV操作作为同步机制，则信号量S为-1时表示什么（）</strong></p>
<ul>
<li>有四个进程进入了该程序段</li>
<li>有一个进程在等待</li>
<li><strong>有三个进程进入了程序段，有一个进程在等待</strong></li>
<li>有一个进程进入了该程序段，其余四个进程在等待</li>
</ul>
<p>一般来说，信号量实现中会满足，它的整数值如果为负数，则负数的绝对值表示等待中的线程数量。当然似乎也有些实现不是这么做的。</p>
<hr>
<p><strong>2元信号量可以初始化为（）</strong></p>
<ul>
<li><strong>0或1</strong></li>
<li>0或-1</li>
<li>只能为1</li>
<li>任意值</li>
</ul>
<p>之所以可以初始化为0或1，是因为二元信号量至少有两种不同的使用场景：</p>
<ul>
<li>资源数目为1，如只能互斥访问的代码关键区</li>
<li>代码条件等待，这种情况下有可能会先执行V操作，再执行P操作</li>
</ul>
<hr>
<p><strong>多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（）</strong></p>
<ul>
<li>1个</li>
<li>2个</li>
<li><strong>3个</strong></li>
<li>4个</li>
</ul>
<p>等待进程的数量就是信号量的值的负数。不过这样可以推导出，请求过信号量资源的进程为6个，得到资源的为2个，现在仍在等待的进程为3个，说明信号量的初值为6-2-3=1。</p>
<hr>
<p><strong>(2011年全国统考)有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示；两个操作完成后，x的值（）。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加一操作    		减一操作</span><br><span class="line">Load R1,x  		load R2,x</span><br><span class="line">inc R1     		dec R2</span><br><span class="line">store x,R1 		store x,R2</span><br></pre></td></tr></table></figure>
<ul>
<li>可能为-1或3</li>
<li>只能为1</li>
<li><strong>可能为0、1或2</strong></li>
<li>可能为-1、0、1、1或2</li>
</ul>
<p>分成以下几种情况讨论：</p>
<ul>
<li>P1和P2的执行完全错开（即加载了不同的x的值）：结果正确，x=1</li>
<li>P1和P2加载了相同的x的值：结果依赖于P1先写还是P2先写，如果P1先写则x=2，否则x=0</li>
</ul>
<hr>
<p><strong>管程的主要特点有（）</strong></p>
<ul>
<li><strong>局部数据变量只能被管程的过程访问</strong></li>
<li><strong>一个进程通过调用管程的一个过程进入管程</strong></li>
<li>不会出现死锁</li>
<li><strong>在任何时候，只能有一个进程在管程中执行</strong></li>
</ul>
<p>课上好像没有讲这么多管程的特点……</p>
<hr>
<p><strong>关于管程的叙述正确的是（）</strong></p>
<ul>
<li>管程中的局部数据变量可以被外部直接访问</li>
<li>当一个进程在管程中执行时，调用管程的其他进程都不会被阻塞</li>
<li>在管程中的signal()与信号量中的signal()操作实现及意义完全相同</li>
<li><strong>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有管程才能访问</strong></li>
</ul>
<p>管程中的局部变量只能通过管程的过程访问。一个进程在管程中执行时，调用管程的其他过程都会被阻塞。管程中的signal是通过条件变量实现的，而不是信号量，所以意义有微妙的不同。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>什么是信号量？它与软件同步方法的区别在什么地方？</strong></p>
<p>信号量是由操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象数据类，由一个被保护的整形变量（sem）和P()、V()两个原子操作组成，表示系统资源的数量。</p>
<p>区别：</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制；</li>
<li>信号量是由地位高于进程的管理者OS协调的同步机制。</li>
</ul>
<hr>
<p><strong>自旋锁为什么无法按先来先服务方式使用资源？</strong></p>
<p>原因：自旋锁是由TS指令实现的临界区申请操作，第一个检测到临界区空闲的申请者而不是第一个开始检测的申请者进入。也就是说，访问顺序是由硬件随机决定的。如果要实现FIFO方式，一般都需要一个队列。</p>
<hr>
<p><strong>下面是一种P操作的实现伪码。它能按FIFO顺序进行信号量申请吗？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (s.count == 0) &#123;  //没有可用资源时，进入挂起状态；</span><br><span class="line">        调用进程进入等待队列s.queue;</span><br><span class="line">        阻塞调用进程;</span><br><span class="line">&#125;</span><br><span class="line">s.count--;              //有可用资源，占用该资源；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考回答： 它的问题是，不能按FIFO进行信号量申请。<br>
它的一种出错的情况如下：</p>
</blockquote>
<ul>
<li>一个线程A调用P()原语时，由于线程B正在使用该信号量而进入阻塞状态；注意，这时value的值为0。</li>
<li>线程B放弃信号量的使用，线程A被唤醒而进入就绪状态，但没有立即进入运行状态；注意，这里value为1。</li>
<li>在线程A处于就绪状态时，处理机正在执行线程C的代码；线程C这时也正好调用P()原语访问同一个信号量，并得到使用权。注意，这时value又变回0。</li>
<li>线程A进入运行状态后，重新检查value的值，条件不成立，又一次进入阻塞状态。</li>
<li>至此，线程C比线程A后调用P原语，但线程C比线程A先得到信号量。</li>
</ul>
<p>虽然参考答案是这么说的，但我觉得这有些牵强：事实上这种错误情况取决于V操作的语义。如果V操作能够保证使唤醒的进程立刻抢占处理机，就不会发生以上问题了。这就类似于管程的Hoare语义和Mesa语义的区别。</p>
<p><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1219" target="_blank" rel="noopener">Piazza</a>上有一个类似的讨论。事实上，在一般的Mesa语义下，使用<code>if</code>进行检查根本就是不正确的，需要用<code>while</code>。改用<code>while</code>之后，确实能保证正确性，但是FIFO无法保证了。</p>
<hr>
<p><strong>什么是条件同步？如何使用信号量来实现条件同步？</strong></p>
<p>条件同步是指线程间的事件等待。</p>
<p>条件同步的实现方法：定义初始值为<strong>0</strong>的信号量，事件触发进程使用V()操作表示事件出现，事件等待进程使用P()操作表示开始等待事件。</p>
<p>也就是说，此处P和V操作的顺序是颠倒的。</p>
<hr>
<p><strong>什么是生产者-消费者问题？</strong></p>
<ul>
<li>生产者生成数据，并放入缓冲区</li>
<li>消费者从缓冲区取出数据，进行处理</li>
<li>任何时间只有一个进程访问缓冲区</li>
</ul>
<hr>
<p><strong>为什么在生产者-消费者问题中先申请互斥信号量会导致死锁？</strong></p>
<p>如果先申请互斥信号量，后申请资源信号量，则在两种情况下可能会出现循环等待：</p>
<ul>
<li>生产者获得互斥信号量后检查<code>emptyBuffers</code>资源信号量，发现缓冲区满了，于是进入睡眠状态；此时消费者无法获得互斥信号量，于是无法消耗缓冲区内的资源</li>
<li>消费者获得互斥信号量后检查<code>fullBuffers</code>资源信号量，发现缓冲区空了，于是进入睡眠状态；此时生产者无法获得互斥信号量，于是无法将资源放入缓冲区内</li>
</ul>
<p>按答案中更抽象的说法就是这样：</p>
<blockquote></blockquote>
<ul>
<li>缓冲区空时，生产者等待缓冲区的互斥访问，以便放入数据；消费者占有缓冲区访问权，等待生产者放入的数据</li>
<li>缓冲区满时，生产者占有缓冲区访问权，等待空的缓冲块；消费者等待缓冲区的互斥访问，以便取出数据</li>
</ul>
<hr>
<p><strong>为什么互斥信号量的实现比资源信号量的实现要简单？请说明．</strong></p>
<blockquote>
<p>信号量中的整形变量的取值不同，互斥信号量的最大取值为1；而资源信号量的最大取值为资源总数。</p>
</blockquote>
<p>事实上，互斥信号量和互斥锁是等价的。（如果不考虑sem值和等待进程数量关系的问题）。</p>
<hr>
<p><strong>管程的组成包括哪几部分？入口队列和条件变量等待队列的作用是什么？</strong></p>
<blockquote>
<p>管程是一种并发程序的编程方法，由一个与入口队列对应的锁和若干个与共享数据访问的等待队列对应的条件变量组成，从而实现在任一时刻最多只有一个线程执行管程代码。</p>
</blockquote>
<p>管程的组成部分：</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>入口队列：每次只能有一个线程进入</li>
<li>0或多个条件变量（及其对应的等待队列）：管理共享数据的并发访问</li>
</ul>
<p>入口的等待队列和锁保证任一时刻最多只有一个线程执行管程代码；每个条件变量等待队列表示一种等待的资源。</p>
<hr>
<p><strong>管程与临界区有什么异同？</strong></p>
<ul>
<li>相同点：在任一时刻最多只有一个线程执行管程代码或临界区代码</li>
<li>不同点：正在管程中的线程可临时放弃管程的互斥访问（进入条件变量的等待队列），等待事件出现时恢复；而临界区不支持临时退出</li>
</ul>
<p>（所以其实在管程的概念里面我们已经不谈临界区了？）</p>
<hr>
<p><strong>为什么用管程实现的生产者-消费者问题中，可以在进入管程后才判断缓冲区的状态？</strong></p>
<p>因为管程允许临时放弃管程的互斥访问，而信号量并不支持临时放弃互斥访问权。在具体实现上，在管程内部的条件变量上进行等待时，会将管程的锁作为<code>wait()</code>操作的参数传递过去，此操作会同时放弃锁（返回时又会重新获得锁），因此不会导致死锁。</p>
<hr>
<p><strong>请描述管程条件变量的三种释放处理方式的区别是什么？条件判断中的while和if是如何影响释放处理中的顺序的？</strong></p>
<ul>
<li>Mesa管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程继续执行，被唤醒进程放回入口等待队列队首等待当前进程释放管程访问权</li>
<li>Hoare管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程进入唤醒队列等待，被唤醒进程继续执行直到释放管程访问权；管程空闲时，优先查看唤醒队列中的等待进程，唤醒队列中没有等待进程时再查看入口队列</li>
<li>Hansen管程：占用管程的当前进程只在退出管程时释放占用资源并唤醒相应的等待进程，被唤醒进程继续执行直到释放管程访问权</li>
</ul>
<p>条件判断中while和if对释放处理中的执行顺序影响：</p>
<ul>
<li>在Hansen和Mesa管程中，由于条件变量释放操作signal时并没有立即放弃管程访问权，资源的可用状态可能变化，需使用while()进行重新检查；</li>
<li>在Hoare管程中，由于条件变量释放操作signal同时表示立即放弃管程访问权，资源的可用状态保持不变，可使用if判断，不需要再次检查。</li>
</ul>
<p>Ref: <a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=894" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=894</a></p>
<p>Ref: <a href="https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html" target="_blank" rel="noopener">https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html</a></p>
<p>（不过在上述Piazza帖子中也有人提出了这样的问题：Hansen管程似乎是直接把访问权转移给了等待进程，这样还需要使用if来判断吗？）</p>
<hr>
<p><strong>哲学家就餐问题的方案2和方案3的性能有什么区别？</strong></p>
<ul>
<li>方案2中，最多只有一个哲学家在吃饭</li>
<li>方案3中，最多可以有两个哲学家在同时吃饭</li>
</ul>
<hr>
<p><strong>在读者-写者问题的读者优先和写者优先在行为上有什么不同？</strong></p>
<ul>
<li>读者优先策略：
<ul>
<li>只要有读者正在读状态，后来的读者就能直接进入</li>
<li>如果读者不断进入，则写者就处于饥饿</li>
</ul>
</li>
<li>写者优先策略
<ul>
<li>只要有写者就绪，写者应尽快执行写操作（后来的读者需要阻塞）</li>
<li>如果写者持续不断就绪，则读者就处于饥饿</li>
</ul>
</li>
</ul>
<hr>
<p><strong>在读者-写者问题的读者优先实现中优先于读者到达的写者在什么地方等待？</strong></p>
<p>互斥信号<code>WriteMutex</code>。因为这是控制读写互斥访问的锁。</p>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>请用管程with条件变量来实现信号量。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">    Lock lock;  // 管程的锁</span><br><span class="line">    int count;  // 剩余可用资源个数</span><br><span class="line">    Condition isEmpty;  // 表示是否有可用资源的事件的条件变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::Semaphore(int numRes) &#123;</span><br><span class="line">    count = numRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P() &#123;</span><br><span class="line">    lock.acquire();</span><br><span class="line">    while (count == 0)</span><br><span class="line">        isEmpty.wait(&amp;lock);</span><br><span class="line">    count--;</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    lock.acquire();</span><br><span class="line">    count++;</span><br><span class="line">    isEmpty.signal();</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到可能是Mesa语义的管程，因此进行了<code>while</code>检查。参考了这个<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">Piazza</a>帖子，我认为上述实现可以满足：</p>
<ul>
<li>在任一状态，条件变量的等待队列与信号量的等待队列完全相同</li>
<li>当<code>count != 0</code>时，其含义与信号量中的<code>sem</code>相同，此时条件变量的<code>numWaiting = 0</code></li>
<li>当<code>count = 0</code>时，条件变量的<code>numWaiting</code>等于信号量的<code>sem</code>的相反数（实现保证了count不会为负数）</li>
</ul>
<hr>
<p><strong>请用信号量来实现管程with条件变量。</strong></p>
<p>这个就有一定的难度了。当然，管程的核心是条件变量，其实实现条件变量就可以了。以下内容参考了<a href="https://birrell.org/andrew/papers/ImplementingCVs.pdf" target="_blank" rel="noopener">Implementing Condition Variables with Semaphores</a>这篇文章。</p>
<p>首先用信号量实现一个锁，这是非常容易的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">    Semaphore sm;</span><br><span class="line">    public Lock() &#123; // constructor</span><br><span class="line">        sm = new Semaphore(); sm.count =1; sm.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Acquire() &#123; sm.P(); &#125;</span><br><span class="line">    public void Release() &#123; sm.V(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出一种非常简单但是也非常错误的实现。该实现的显而易见的问题是，wait操作中对锁的释放和当前线程的睡眠不是原子的。然后好像会出现一个叫做“wake-up waiting race”的问题，不过此处好像并不会发生错误。以及，即使在没有线程正在等待时，signal操作也会使得信号量的值增加，这样，下一个等待进程就不会阻塞了，这是不正确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        s = new Semaphore();</span><br><span class="line">        s.count = 0;</span><br><span class="line">        s.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        s.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我们用信号量x作为互斥锁来保护wait操作，同时统计等待进程的个数。但这个实现也有两个问题：</p>
<ul>
<li>由于s信号量的资源个数为1，因此最多只有一个调用wait的进程能够从s.P中返回，其余的都阻塞在s.P上；解决方法是把s的资源个数调到无限大</li>
<li>没有保证先进先出的语义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s, x;</span><br><span class="line">    int waiters = 0;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        s = new Semaphore(); s.count = 0; s.limit = 1;</span><br><span class="line">        x = new Semaphore(); x.count = 1; x.limit = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        x.P();</span><br><span class="line">        waiters++;</span><br><span class="line">        x.V();</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        if (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Broadcast() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        while (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一种实现中，加入了信号量h，它会使发出信号的线程在等待线程离开等待队列之前也阻塞。这个实现是正确的，但是似乎太麻烦了。论文最后表示，他们决定还是在OS中用硬件指令来实现条件变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CV &#123;</span><br><span class="line">    Semaphore s, x;</span><br><span class="line">    int waiters = 0;</span><br><span class="line">    Semaphore h;</span><br><span class="line">    public CV() &#123; // Constructor</span><br><span class="line">        this.m = m;</span><br><span class="line">        s = new Semaphore(); s.count = 0; s.limit = 999999;</span><br><span class="line">        x = new Semaphore(); x.count = 1; x.limit = 1;</span><br><span class="line">        h = new Semaphore(); h.count = 0; h.limit = 999999;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Wait(Lock m) &#123; // Pre-condition: this thread holds “m”</span><br><span class="line">        x.P();</span><br><span class="line">        waiters++;</span><br><span class="line">        x.V();</span><br><span class="line">        m.Release();</span><br><span class="line">        s.P();</span><br><span class="line">        h.V();</span><br><span class="line">        m.Acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Signal() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        if (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            s.V();</span><br><span class="line">            h.P();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Broadcast() &#123;</span><br><span class="line">        x.P();</span><br><span class="line">        for (int i = 0; i &lt; waiters; i++)</span><br><span class="line">            s.V();</span><br><span class="line">        while (waiters &gt; 0) &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">            h.P();</span><br><span class="line">        &#125;</span><br><span class="line">        x.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>请评价如下的实现(用信号量来实现管程with条件变量)是否合理？简要说明理由。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Implementing a Monitor</span><br><span class="line"></span><br><span class="line">CONTROL VARIABLES:</span><br><span class="line"></span><br><span class="line">	mutex: semaphore, initial value 1 (FREE)</span><br><span class="line">	next: record, with 2 fields:</span><br><span class="line">		next.sem: semaphore, initial value 0</span><br><span class="line">		next.count: counter, initial value 0</span><br><span class="line"></span><br><span class="line">	FOR EACH CONDITION x:</span><br><span class="line"></span><br><span class="line">	x: record, with 2 fields:</span><br><span class="line">		x.sem: semaphore, initial value 0</span><br><span class="line">		x.count: counter, initial value 0</span><br><span class="line">ENTRY PROTOCOL (at the beginning of each monitor function):</span><br><span class="line"></span><br><span class="line">	/* wait for exclusive access to the monitor */</span><br><span class="line">	P(mutex);</span><br><span class="line">EXIT PROTOCOL (at the end of each monitor function):</span><br><span class="line"></span><br><span class="line">	/* if there are processes in the &quot;next&quot; queue, release one */</span><br><span class="line">	if (next.count &gt; 0) V(next.sem);</span><br><span class="line"></span><br><span class="line">	/* otherwise, release the monitor */</span><br><span class="line">	else V(mutex);</span><br><span class="line">WAIT ON CONDITION x (x.wait):</span><br><span class="line"></span><br><span class="line">	/* first perform the exit protocol */</span><br><span class="line">	if (next.count &gt; 0) V(next.sem);</span><br><span class="line">	else V(mutex);</span><br><span class="line"></span><br><span class="line">	/* now wait on the condition queue */</span><br><span class="line">	x.count++;</span><br><span class="line">	P(x.sem);</span><br><span class="line">	x.count--;</span><br><span class="line">SIGNAL CONDITION x (x.signal):</span><br><span class="line"></span><br><span class="line">	/* do nothing unless a process is waiting */</span><br><span class="line">	if (x.count &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">		/* release the next waiting process */</span><br><span class="line">		V(x.sem);</span><br><span class="line"></span><br><span class="line">		/* wait on the &quot;next&quot; queue */</span><br><span class="line">		next.count++;</span><br><span class="line">		P(next.sem);</span><br><span class="line">		next.count--;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>每人使用C++或python语言用信号量和条件变量两种手段分别实现<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-2-spoc-pv-problems.md" target="_blank" rel="noopener">40个同步互斥问题</a>中的一题。请先理解<a href="https://github.com/chyyuu/ucore_os_lab/tree/master/related_info/lab7/semaphore_condition" target="_blank" rel="noopener">python threading 机制的介绍和实例</a></strong></p>
<p>参考：<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=391" target="_blank" rel="noopener">2015年操作系统课的信号量问题回答</a></p>
<p>建议参考梁锡豪同学的输出信息显示方式，这种方式的可读性很好。</p>
<p>建议重视测试用例的设计，以检查自己的实现是否有错。</p>
<hr>
<p><strong>设计某个方法，能够动态检查出对于两个或多个进程的同步互斥问题执行中，没有互斥问题，能够同步等，以说明实现的正确性。</strong></p>
<hr>
<p><strong>管程和信号量在解决同步互斥问题上是否等价？请证明/说明你的结论．</strong></p>
<p>Piazza上有两个非常优秀的讨论：</p>
<ul>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=845" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=845</a>：阐述了信号量和条件变量在具体实现和操作层面的异同</li>
<li><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=839" target="_blank" rel="noopener">https://piazza.com/class/i5j09fnsl7k5x0?cid=839</a>：对信号量和条件变量抽象的理解</li>
</ul>
<p>简单来说，就是：信号量可以实现管程，管程可以实现信号量，所以在这个层面，二者等价。</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
          
            <div class="post-wrapper">
              <article class="post reveal ">
    
<section class="meta">
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/os-mooc-lecture-22-summary/">
              
                  《操作系统》第22讲：“实验8-文件系统”总结
              
          </a>
      </h2>
    

    <div class="new-meta-box">
      
        <div class="new-meta-item author">
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class="notlink">
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2018-05-24
          </a>
        </div>
      
      
        
      
      
      
    </div>
    <hr>
  </div>
</section>

    <section class="article typo">
        <h2 id="课程内容概述"><a class="markdownIt-Anchor" href="#课程内容概述"></a> 课程内容概述</h2>
<p>本讲介绍了ucore中的文件系统。</p>
<p>TODO</p>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>来自<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-quiz.md" target="_blank" rel="noopener">lec22 lab8 文件系统 在线练习</a>和<a href="https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-spoc-discussion.md" target="_blank" rel="noopener">lab8 文件系统 (lec 22) spoc 思考题</a>。</p>
<h3 id="选择填空题"><a class="markdownIt-Anchor" href="#选择填空题"></a> 选择填空题</h3>
<p><strong>ucore实现的文件系统抽象包括（）</strong></p>
<ul>
<li><strong>文件</strong></li>
<li><strong>目录项</strong></li>
<li><strong>索引节点</strong></li>
<li><strong>安装点</strong></li>
</ul>
<p>我猜这里主要说的是VFS文件系统中的内容。</p>
<ul>
<li><code>struct file</code>：应用程序能够看到的各种文件信息</li>
<li><code>struct inode</code>：映射到特定文件系统的inode</li>
<li><code>struct fs</code>：保存了具体文件系统的结构、类型和信息</li>
</ul>
<p>然后安装点是个啥我也不知道。</p>
<blockquote>
<p>安装点是一个目录或文件，可在该处访问新文件系统、目录或文件。要安装文件系统或目录，安装点必须为一个目录；要安装文件，那么安装点必须为文件。（<a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.osdevice/mountpoint.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.osdevice/mountpoint.htm</a>）</p>
</blockquote>
<hr>
<p><strong>ucore实现的simple FS（简称SFS）采用的文件分配机制是（）</strong></p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li><strong>索引分配</strong></li>
<li>位图分配</li>
</ul>
<p>SFS使用的是一级索引。</p>
<p>索引分配的定义：为每个文件创建一个索引数据块，指向文件数据块的指针列表；文件头包含了索引数据块指针。</p>
<hr>
<p><strong>关于ucore实现的SFS阐述正确的是（）</strong></p>
<ul>
<li><strong>SFS的超级块保存在硬盘上，在加载simple FS时会读入内存中</strong></li>
<li><strong>SFS的free map结构保存在硬盘上，表示硬盘可用的数据块（扇区）</strong></li>
<li><strong>SFS的root-dir inode结构保存在硬盘上，表示SFS的根目录的元数据信息</strong></li>
<li>硬盘上的SFS ，除保存上述三种结构外，剩下的都用于保存文件的数据内容</li>
</ul>
<p>除了前三种结构，剩下的用于保存文件的inode, dir/file的data。</p>
<hr>
<p><strong>关于ucore实现的Virtual FS（简称VFS）阐述正确的是()</strong></p>
<ul>
<li><strong>已支持磁盘文件系统</strong></li>
<li><strong>已支持设备文件系统</strong></li>
<li>已支持网络文件系统</li>
<li>已支持系统状态文件系统</li>
</ul>
<blockquote>
<p>后两种可实现，但现在还没实现</p>
</blockquote>
<p>哈哈哈哈哈哈……</p>
<hr>
<p><strong>关于ucore文件系统支持的I/O设备包括()</strong></p>
<ul>
<li><strong>串口设备</strong></li>
<li><strong>并口设备</strong></li>
<li><strong>CGA设备</strong></li>
<li><strong>键盘设备</strong></li>
</ul>
<p>总之这些都支持。不过好像从Lab1就有了。</p>
<h3 id="简答题"><a class="markdownIt-Anchor" href="#简答题"></a> 简答题</h3>
<p><strong>与文件系统相关的系统调用接口、虚拟文件系统VFS、简单文件系统SFS和设备I/O等四个部分各实现什么功能？</strong></p>
<ul>
<li>系统调用接口：向应用进程提供文件访问的系统调用</li>
<li>虚拟文件系统VFS：屏蔽具体文件系统差异，对上提供一个统一的文件系统访问接口</li>
<li>简单文件系统SFS：解析和读写磁盘数据块中具体的SFS文件系统存储结构</li>
<li>设备I/O：完成实际磁盘设备上数据块的访问</li>
</ul>
<hr>
<p><strong>文件系统中的文件、目录、索引节点(inode)和安装点(挂载点)这几种数据结构分别支持些什么操作？</strong></p>
<ul>
<li>文件：open/close, read/write</li>
<li>目录：open/close, read</li>
<li>索引节点：lookup, read/write</li>
<li>挂载点：mount/unmount</li>
</ul>
<hr>
<p><strong>请简要阐述ucore文件系统架构的四个组成部分。</strong></p>
<ul>
<li>系统调用接口：用户应用使用封装后的libc库函数，文件访问的libc库函数利用文件访问系统调用来实现</li>
<li>VFS：内核的系统调用（文件、目录接口）会转换成对VFS抽象的文件访问接口（索引节点、文件卷、设备等接口）的调用，VFS再把抽象的VFS接口转换成具体的文件系统SFS的访问接口</li>
<li>SFS：对具体文件系统存储结构进行解析，把SFS对接口（索引节点、文件卷、设备等接口）的访问请求转换成设备数据块的访问</li>
<li>I/O接口：不同具体设备上的数据块访问控制</li>
</ul>
<hr>
<p><strong>请简要说明进程proc_struct、文件file、inode之间的关系。</strong></p>
<ul>
<li>进程控制块数据结构<code>proc_struct</code>中，<code>struct files_struct *filesp</code>指向进程的打开文件表</li>
<li>进程打开文件表中<code>struct file *file</code>指向系统打开文件中的相应文件状态数据</li>
<li>VFS中的系统打开文件表中<code>struct inode *inode</code>维护打开文件的状态信息，并最终对应到磁盘上的存储数据块</li>
</ul>
<hr>
<p><strong>ucore中的进程打开文件表和系统打开文件表对应到具体的哪个数据结构上？</strong></p>
<ul>
<li>进程打开文件表：<code>proc_struct</code>中的<code>struct files_struct *filesp</code></li>
<li>系统打开文件表：不知道</li>
</ul>
<hr>
<p><strong>SFS在硬盘上的四大部分主要是什么，有何作用？</strong></p>
<ul>
<li>superblock：数据块大小、文件卷名字等文件卷信息</li>
<li>root-dir inode：根目录的inode信息（存储位置等）</li>
<li>freemap：数据块占用状态信息</li>
<li>data block：inode/文件数据/目录数据</li>
</ul>
<hr>
<p><strong>硬盘上的SFS是如何加载到ucore中并初始化的？</strong></p>
<p>ucore docs Lab8：</p>
<blockquote>
<p>在<code>sfs_fs.c</code>文件中的<code>sfs_do_mount</code>函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p>
</blockquote>
<hr>
<p><strong>硬盘上的inode和内存中的inode的关系和区别是什么？</strong></p>
<p>内存中的inode数据结构sfs_inode中有一个字段sfs_disk_inode，它对应磁盘上的inode。</p>
<p>ucore docs Lab8：</p>
<blockquote>
<p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。<br>
……<br>
可以看到SFS中的内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
</blockquote>
<hr>
<p><strong>描述file, dir, inode在内存和磁盘上的格式和相关操作。</strong></p>
<p>每一种类型的数据块都在SFS层中有对应的操作函数指针和数据结构定义。</p>
<p>事实上，file、dir和inode在内存和磁盘上都以inode形式存储：</p>
<ul>
<li>内存：<code>struct sfs_disk_inode</code></li>
<li>磁盘：inode</li>
</ul>
<blockquote>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。<br>
对于普通文件，索引值指向的block中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。</p>
</blockquote>
<hr>
<p><strong>file数据结构的主要内容是什么？与进程的关系是什么？</strong></p>
<p><code>struct file</code>数据结构定义在<code>lab8/kern/fs/file.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">    enum &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    bool readable;</span><br><span class="line">    bool writable;</span><br><span class="line">    int fd;</span><br><span class="line">    off_t pos;</span><br><span class="line">    struct inode *node;</span><br><span class="line">    int open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct file</code>数据结构的内容包括：</p>
<ul>
<li><code>status</code>：文件状态</li>
<li><code>bool readable &amp; writable</code>：文件操作类型</li>
<li><code>int fd</code>：文件描述符</li>
<li><code>off_t pos</code>：文件指针</li>
<li><code>struct inode *node</code>：对应系统打开文件表项指针</li>
<li><code>int open_count</code>：文件打开计数</li>
</ul>
<p><code>struct file</code>就是进程打开文件表对应的数据结构。</p>
<hr>
<p><strong>inode数据结构的主要内容是什么？与file的数据结构的关系是什么？</strong></p>
<p><code>struct inode</code>数据结构定义在<code>lab8/kern/fs/vfs/inode.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct device __device_info;</span><br><span class="line">        struct sfs_inode __sfs_inode_info;</span><br><span class="line">    &#125; in_info;</span><br><span class="line">    enum &#123;</span><br><span class="line">        inode_type_device_info = 0x1234,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    int ref_count;</span><br><span class="line">    int open_count;</span><br><span class="line">    struct fs *in_fs;</span><br><span class="line">    const struct inode_ops *in_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct inode</code>数据结构的内容：</p>
<ul>
<li><code>in_info &amp; in_type</code>：文件类型</li>
<li><code>ref_count &amp; open_count</code>：引用计数</li>
<li><code>struct fs *in_fs</code>：对下具体文件操作函数指针</li>
<li><code>const struct inode_ops *in_ops</code>：对上inode操作函数指针</li>
</ul>
<p><code>struct inode</code>就是系统打开文件表对应的数据结构。</p>
<hr>
<p><strong>inode_ops包含哪些与文件相关的操作？</strong></p>
<p><code>struct inode_ops</code>数据结构定义在<code>lab8/kern/fs/vfs/inode.h</code>中，它是上层使用的inode操作函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct inode_ops &#123;</span><br><span class="line">    unsigned long vop_magic;</span><br><span class="line">    int (*vop_open)(struct inode *node, uint32_t open_flags);</span><br><span class="line">    int (*vop_close)(struct inode *node);</span><br><span class="line">    int (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    int (*vop_fsync)(struct inode *node);</span><br><span class="line">    int (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    int (*vop_reclaim)(struct inode *node);</span><br><span class="line">    int (*vop_gettype)(struct inode *node, uint32_t *type_store);</span><br><span class="line">    int (*vop_tryseek)(struct inode *node, off_t pos);</span><br><span class="line">    int (*vop_truncate)(struct inode *node, off_t len);</span><br><span class="line">    int (*vop_create)(struct inode *node, const char *name, bool excl, struct inode **node_store);</span><br><span class="line">    int (*vop_lookup)(struct inode *node, char *path, struct inode **node_store);</span><br><span class="line">    int (*vop_ioctl)(struct inode *node, int op, void *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件中有每个操作的详细注释</p>
<ul>
<li>open：打开文件</li>
<li>close：关闭文件</li>
<li>read：读文件</li>
<li>write：写文件</li>
<li>fstat：读文件信息</li>
<li>fsync：将脏缓存写回持久化存储介质</li>
<li>namefile：计算文件相对于文件系统根目录的路径</li>
<li>getdirentry：从目录中读一个文件名</li>
<li>reclaim：回收inode</li>
<li>gettype：文件种类</li>
<li>tryseek：检查移动文件指针是否合法</li>
<li>truncate：重设文件大小，丢弃多余的数据</li>
<li>create：在目录中新建文件</li>
<li>lookup：在给定目录中按文件名查找文件</li>
<li>ioctl：管理I/O通道（？？）</li>
</ul>
<hr>
<p><strong>VFS是如何把键盘、显示输出和磁盘文件统一到一个系统调用访问框架下的？</strong></p>
<ul>
<li>VFS把键盘、显示和磁盘文件都视为文件，VFS对上提供的访问接口都是文件访问接口</li>
<li>VFS通过区别文件类型、文件操作类型、设备类型等来区别同类操作在不同设备的不同实现</li>
</ul>
<hr>
<p><strong>device数据结构的主要内容是什么？与fs的关系是什么？与inode的关系是什么？</strong></p>
<p>这里的<code>device</code>指的应该是<code>lab8/kern/fs/devs/dev.h</code>中定义的<code>struct device</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Filesystem-namespace-accessible device.</span><br><span class="line"> * d_io is for both reads and writes; the iobuf will indicates the direction.</span><br><span class="line"> */</span><br><span class="line">struct device &#123;</span><br><span class="line">    size_t d_blocks;</span><br><span class="line">    size_t d_blocksize;</span><br><span class="line">    int (*d_open)(struct device *dev, uint32_t open_flags);</span><br><span class="line">    int (*d_close)(struct device *dev);</span><br><span class="line">    int (*d_io)(struct device *dev, struct iobuf *iob, bool write);</span><br><span class="line">    int (*d_ioctl)(struct device *dev, int op, void *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct device</code>数据结构的内容：</p>
<ul>
<li><code>size_t d_blocks</code>：数据块个数</li>
<li><code>size_t d_blocksize</code>：数据块大小</li>
<li>设备操作函数指针（<code>d_open</code>, <code>d_close</code>, <code>d_io</code>, <code>d_ioctl</code>）</li>
</ul>
<p>fs和inode通过device数据结构中的设备操作函数指针实现对设备数据块的访问。</p>
<hr>
<p><strong>比较ucore中I/O接口、SFS文件系统接口和文件系统的系统调用接口的操作函数有什么异同？</strong></p>
<ul>
<li>文件系统的系统调用接口（<code>lab8/kern/syscall/syscall.c</code>）：sys_open, sys_close, sys_read, sys_write, sys_seek, sys_fstat, sys_fsync, sys_chdir, sys_getcwd, sys_mkdir, sys_link, sys_rename, sys_unlink, sys_getdirentry, sys_dup, sys_pipe, sys_mkfifo, sys_mount, sys_umount, sys_ioctl</li>
<li>VFS文件系统接口（<code>lab8/kern/vfs/vfs.h</code>）：vfs_open, vfs_close, vfs_link, vfs_symlink, vfs_readlink, vfs_mkdir, vfs_unlink, vfs_rename, vfs_chdir, vfs_getcwd</li>
<li>SFS文件系统接口（<code>lab8/kern/sfs/sfs.h</code>）：sfs_rblock, sfs_wblock, sfs_rbuf, sfs_wbuf, sfs_sync_super, sfs_sync_freemap, sfs_clear_block, sfs_load_inode</li>
<li>I/O接口（<code>lab8/kern/devs/dev.h</code>）：d_open, d_close, d_io, d_ioctl</li>
</ul>
<h3 id="实践题"><a class="markdownIt-Anchor" href="#实践题"></a> 实践题</h3>
<p><strong>理解文件访问的执行过程，即在ucore运行过程中通过<code>cprintf</code>函数来完整地展现出来读一个文件在ucore中的整个执行过程，(越全面细致越好) 完成代码填写，并形成spoc练习报告，需写练习报告和简单编码，完成后放到git server 对应的git repo中。</strong></p>
<p>啊，这个完全没有时间去写了……</p>
<hr>
<p><strong>在下面的实验代码的基础上，实现基于文件系统的pipe IPC机制。练习用的<a href="https://github.com/chyyuu/ucore_lab/tree/master/labcodes_answer/lab8_result" target="_blank" rel="noopener">lab8 spoc exercise project source code</a></strong></p>
<p>呃，这是lab8的附加题……</p>

        

        
            <div class="full-width auto-padding tags">
                
                    <a href="/tags/OS/"><i class="fas fa-hashtag fa-fw"></i>OS</a>
                
            </div>
        
    </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
              <p class="current">
                  1 / 3
              </p>
              
                  <a class="next" rel="next" href="/tags/OS/page/2/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  



        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class="author">
  <div class="content pure">
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class="category">
    
<header class="pure">
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class="content pure">
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class="name">Codeforces</div><div class="badge">(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class="name">Leetcode</div><div class="badge">(9)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class="name">USACO</div><div class="badge">(1)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class="tagcloud">
    
<header class="pure">
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class="content pure">
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.11px; color: #919191">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.56px; color: #737373">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19.19px; color: #767676">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 14px; color: #999">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.37px; color: #969696">Essay</a> <a href="/tags/Github/" style="font-size: 14.74px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.26px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.63px; color: #585858">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.33px; color: #828282">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 15.11px; color: #919191">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.59px; color: #878787">Machine Translation</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.33px; color: #828282">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.78px; color: #646464">OS</a> <a href="/tags/OSTEP/" style="font-size: 18.07px; color: #7d7d7d">OSTEP</a> <a href="/tags/OldBlog/" style="font-size: 15.11px; color: #919191">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/Paper/" style="font-size: 16.59px; color: #878787">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14.37px; color: #969696">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.48px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.7px; color: #808080">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.37px; color: #969696">SGU</a> <a href="/tags/Sonnet/" style="font-size: 20.67px; color: #6c6c6c">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.74px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 14.37px; color: #969696">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.11px; color: #919191">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.44px; color: #7b7b7b">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.52px; color: #5f5f5f">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.11px; color: #919191">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 22.15px; color: #626262">W.Shakespeare</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Array/" style="font-size: 21.04px; color: #696969">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.85px; color: #8c8c8c">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 15.48px; color: #8f8f8f">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.59px; color: #878787">alg:Binary Search Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.48px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 17.33px; color: #828282">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.37px; color: #969696">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 16.96px; color: #858585">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.3px; color: #6e6e6e">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 21.04px; color: #696969">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.48px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.41px; color: #676767">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 20.67px; color: #6c6c6c">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.11px; color: #919191">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.37px; color: #969696">alg:In-Order Traversal</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.48px; color: #8f8f8f">alg:Linked List</a> <a href="/tags/alg-Math/" style="font-size: 22.89px; color: #5d5d5d">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.37px; color: #969696">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14px; color: #999">alg:Minimax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 15.48px; color: #8f8f8f">alg:Monotonic Stack</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.74px; color: #949494">alg:Queue</a> <a href="/tags/alg-Random/" style="font-size: 14.74px; color: #949494">alg:Random</a> <a href="/tags/alg-Recursion/" style="font-size: 15.48px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.37px; color: #969696">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sort/" style="font-size: 14.74px; color: #949494">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 18.44px; color: #7b7b7b">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 18.81px; color: #787878">alg:String</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Tree/" style="font-size: 19.93px; color: #717171">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14px; color: #999">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 18.07px; color: #7d7d7d">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.48px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.37px; color: #969696">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.74px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14px; color: #999">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.85px; color: #8c8c8c">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.22px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.85px; color: #8c8c8c">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.48px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.7px; color: #808080">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.11px; color: #919191">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.96px; color: #858585">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class="list">
  
<header class="pure">
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class="content pure">
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class="name">
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>


  
    <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
    <script type="text/javascript">
      $(function() {
        const $reveal = $('.reveal');
    		if ($reveal.length === 0) return;
    		const sr = ScrollReveal({ distance: 0 });
    		sr.reveal('.reveal');
      });
    </script>
  
  
    <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
    <script type="text/javascript">
      $(function() {
        Waves.attach('.flat-btn', ['waves-button']);
        Waves.attach('.float-btn', ['waves-button', 'waves-float']);
        Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
        Waves.attach('.flat-box', ['waves-block']);
        Waves.attach('.float-box', ['waves-block', 'waves-float']);
        Waves.attach('.waves-image');
        Waves.init();
      });
    </script>
  
  
    <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>
  
  
  


  
  
  
    
  
  
    <script src="/js/app.js"></script>
<script src="/js/search.js"></script>
  








    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
